{"version":3,"file":"maxrects-packer.js","sources":["../../../../libs/dom/src/maxrects-packer/maxrects-packer.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {Rectangle, IRectangle} from './geom/Rectangle';\nimport {MaxRectsBin} from './maxrects-bin';\nimport {OversizedElementBin} from './oversized-element-bin';\nimport {Bin, IBin} from './abstract-bin';\n\nexport const EDGE_MAX_VALUE = 4096;\nexport const EDGE_MIN_VALUE = 128;\nexport enum PACKING_LOGIC {\n  MAX_AREA = 0,\n  MAX_EDGE = 1,\n}\n\n/**\n * Options for MaxRect Packer\n * @property {boolean} options.smart Smart sizing packer (default is true)\n * @property {boolean} options.pot use power of 2 sizing (default is true)\n * @property {boolean} options.square use square size (default is false)\n * @property {boolean} options.allowRotation allow rotation packing (default is false)\n * @property {boolean} options.tag allow auto grouping based on `rect.tag` (default is false)\n * @property {boolean} options.border atlas edge spacing (default is 0)\n * @property {PACKING_LOGIC} options.logic MAX_AREA or MAX_EDGE based sorting logic (default is MAX_EDGE)\n * @export\n * @interface Option\n */\nexport interface IOption {\n  smart?: boolean;\n  pot?: boolean;\n  square?: boolean;\n  allowRotation?: boolean;\n  tag?: boolean;\n  border?: number;\n  logic?: PACKING_LOGIC;\n}\n\nexport class MaxRectsPacker<T extends IRectangle = Rectangle> {\n  /**\n   * The Bin array added to the packer\n   *\n   * @type {Bin[]}\n   * @memberof MaxRectsPacker\n   */\n  public bins: Bin<T>[];\n\n  /**\n   * Creates an instance of MaxRectsPacker.\n   * @param {number} width of the output atlas (default is 4096)\n   * @param {number} height of the output atlas (default is 4096)\n   * @param {number} padding between glyphs/images (default is 0)\n   * @param {IOption} [options={}] (Optional) packing options\n   * @memberof MaxRectsPacker\n   */\n  constructor(\n    public width: number = EDGE_MAX_VALUE,\n    public height: number = EDGE_MAX_VALUE,\n    public padding: number = 0,\n    public options: IOption = {\n      smart: true,\n      pot: true,\n      square: false,\n      allowRotation: false,\n      tag: false,\n      border: 0,\n      logic: PACKING_LOGIC.MAX_EDGE,\n    },\n  ) {\n    this.bins = [];\n  }\n\n  /**\n   * Add a bin/rectangle object with data to packer\n   * @param {number} width of the input bin/rectangle\n   * @param {number} height of the input bin/rectangle\n   * @param {*} data custom data object\n   * @memberof MaxRectsPacker\n   */\n  public add(width: number, height: number, data: any): T;\n  /**\n   * Add a bin/rectangle object extends IRectangle to packer\n   * @template T Generic type extends IRectangle interface\n   * @param {T} rect the rect object add to the packer bin\n   * @memberof MaxRectsPacker\n   */\n  public add(rect: T): T;\n  public add(...args: any[]): any {\n    if (args.length === 1) {\n      if (typeof args[0] !== 'object') throw new Error('MacrectsPacker.add(): Wrong parameters');\n      const rect = args[0] as T;\n      if (rect.width > this.width || rect.height > this.height) {\n        this.bins.push(new OversizedElementBin<T>(rect));\n      } else {\n        const added = this.bins\n          .slice(this._currentBinIndex)\n          .find((bin) => bin.add(rect) !== undefined);\n        if (!added) {\n          const bin = new MaxRectsBin<T>(this.width, this.height, this.padding, this.options);\n          const tag = rect.data && rect.data.tag ? rect.data.tag : rect.tag ? rect.tag : undefined;\n          if (this.options.tag && tag) bin.tag = tag;\n          bin.add(rect);\n          this.bins.push(bin);\n        }\n      }\n      return rect;\n    } else {\n      const rect: IRectangle = new Rectangle(args[0], args[1]);\n      if (args.length > 2) rect.data = args[2];\n\n      if (rect.width > this.width || rect.height > this.height) {\n        this.bins.push(new OversizedElementBin<T>(rect as T));\n      } else {\n        const added = this.bins\n          .slice(this._currentBinIndex)\n          .find((bin) => bin.add(rect as T) !== undefined);\n        if (!added) {\n          const bin = new MaxRectsBin<T>(this.width, this.height, this.padding, this.options);\n          if (this.options.tag && rect.data.tag) bin.tag = rect.data.tag;\n          bin.add(rect as T);\n          this.bins.push(bin);\n        }\n      }\n      return rect as T;\n    }\n  }\n\n  /**\n   * Add an Array of bins/rectangles to the packer.\n   *\n   * `Javascript`: Any object has property: { width, height, ... } is accepted.\n   *\n   * `Typescript`: object shall extends `MaxrectsPacker.IRectangle`.\n   *\n   * note: object has `hash` property will have more stable packing result\n   *\n   * @param {IRectangle[]} rects Array of bin/rectangles\n   * @memberof MaxRectsPacker\n   */\n  public addArray(rects: T[]) {\n    this.sort(rects, this.options.logic).forEach((rect) => this.add(rect));\n  }\n\n  /**\n   * Reset entire packer to initial states, keep settings\n   *\n   * @memberof MaxRectsPacker\n   */\n  public reset(): void {\n    this.bins = [];\n    this._currentBinIndex = 0;\n  }\n\n  /**\n   * Repack all elements inside bins\n   *\n   * @param {boolean} [quick=true] quick repack only dirty bins\n   * @returns {void}\n   * @memberof MaxRectsPacker\n   */\n  public repack(quick = true): void {\n    if (quick) {\n      const unpack: T[] = [];\n      for (const bin of this.bins) {\n        if (bin.dirty) {\n          const up = bin.repack();\n          if (up) unpack.push(...up);\n        }\n      }\n      this.addArray(unpack);\n      return;\n    }\n    if (!this.dirty) return;\n    const allRects = this.rects;\n    this.reset();\n    this.addArray(allRects);\n  }\n\n  /**\n   * Stop adding new element to the current bin and return a new bin.\n   *\n   * note: After calling `next()` all elements will no longer added to previous bins.\n   *\n   * @returns {Bin}\n   * @memberof MaxRectsPacker\n   */\n  public next(): number {\n    this._currentBinIndex = this.bins.length;\n    return this._currentBinIndex;\n  }\n\n  /**\n   * Load bins to the packer, overwrite exist bins\n   * @param {MaxRectsBin[]} bins MaxRectsBin objects\n   * @memberof MaxRectsPacker\n   */\n  public load(bins: IBin[]) {\n    bins.forEach((bin, index) => {\n      if (bin.maxWidth > this.width || bin.maxHeight > this.height) {\n        this.bins.push(new OversizedElementBin(bin.width, bin.height, {}));\n      } else {\n        const newBin = new MaxRectsBin<T>(this.width, this.height, this.padding, bin.options);\n        newBin.freeRects.splice(0);\n        bin.freeRects.forEach((r) => {\n          newBin.freeRects.push(new Rectangle(r.width, r.height, r.x, r.y));\n        });\n        newBin.width = bin.width;\n        newBin.height = bin.height;\n        if (bin.tag) newBin.tag = bin.tag;\n        this.bins[index] = newBin;\n      }\n    }, this);\n  }\n\n  /**\n   * Output current bins to save\n   * @memberof MaxRectsPacker\n   */\n  public save(): IBin[] {\n    const saveBins: IBin[] = [];\n    this.bins.forEach((bin) => {\n      let saveBin: IBin = {\n        width: bin.width,\n        height: bin.height,\n        maxWidth: bin.maxWidth,\n        maxHeight: bin.maxHeight,\n        freeRects: [],\n        rects: [],\n        options: bin.options,\n      };\n      if (bin.tag) saveBin = {...saveBin, tag: bin.tag};\n      bin.freeRects.forEach((r) => {\n        saveBin.freeRects.push({\n          x: r.x,\n          y: r.y,\n          width: r.width,\n          height: r.height,\n        });\n      });\n      saveBins.push(saveBin);\n    });\n    return saveBins;\n  }\n\n  /**\n   * Sort the given rects based on longest edge or surface area.\n   *\n   * If rects have the same sort value, will sort by second key `hash` if presented.\n   *\n   * @private\n   * @param {T[]} rects\n   * @param {PACKING_LOGIC} [logic=PACKING_LOGIC.MAX_EDGE] sorting logic, \"area\" or \"edge\"\n   * @returns\n   * @memberof MaxRectsPacker\n   */\n  private sort(rects: T[], logic: IOption['logic'] = PACKING_LOGIC.MAX_EDGE) {\n    return rects.slice().sort((a, b) => {\n      const result =\n        logic === PACKING_LOGIC.MAX_EDGE\n          ? Math.max(b.width, b.height) - Math.max(a.width, a.height)\n          : b.width * b.height - a.width * a.height;\n      if (result === 0 && a.hash && b.hash) {\n        return a.hash > b.hash ? -1 : 1;\n      } else return result;\n    });\n  }\n\n  private _currentBinIndex = 0;\n  /**\n   * Return current functioning bin index, perior to this wont accept any new elements\n   *\n   * @readonly\n   * @type {number}\n   * @memberof MaxRectsPacker\n   */\n  get currentBinIndex(): number {\n    return this._currentBinIndex;\n  }\n\n  /**\n   * Returns dirty status of all child bins\n   *\n   * @readonly\n   * @type {boolean}\n   * @memberof MaxRectsPacker\n   */\n  get dirty(): boolean {\n    return this.bins.some((bin) => bin.dirty);\n  }\n\n  /**\n   * Return all rectangles in this packer\n   *\n   * @readonly\n   * @type {T[]}\n   * @memberof MaxRectsPacker\n   */\n  get rects(): T[] {\n    const allRects: T[] = [];\n    for (const bin of this.bins) {\n      allRects.push(...bin.rects);\n    }\n    return allRects;\n  }\n}\n"],"names":[],"mappings":"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"}