{"version":3,"file":"base.js","sources":["../../../../../libs/device/src/device/builder/base.ts"],"sourcesContent":["import { \n  getTextureSampleType,\n  ShaderPrecisionType,\n  ASTExpression,\n  DeclareType,\n  ASTPrimitive,\n  ASTScalar,\n  ASTArrayIndex,\n  ASTLValueArray,\n  ASTLValueHash,\n  ASTLValueScalar,\n  ASTHash,\n  ASTShaderExpConstructor,\n  ASTAssignment\n} from \"./ast\";\nimport { \n  PBTypeInfo,\n  PBPrimitiveType,\n  PBPrimitiveTypeInfo,\n  PBArrayTypeInfo,\n  PBPointerTypeInfo,\n  PBAddressSpace,\n  typeI32\n} from \"./types\";\nimport {\n  PBASTError\n} from \"./errors\";\nimport type { VertexSemantic } from \"../gpuobject\";\nimport type { ProgramBuilder } from \"./programbuilder\";\n\nlet currentProgramBuilder: ProgramBuilder = null;\nconst constructorCache: Map<ShaderTypeFunc, Record<string | symbol, ShaderTypeFunc>> = new Map();\n\n/** @internal */\nexport function setCurrentProgramBuilder(pb: ProgramBuilder) {\n  currentProgramBuilder = pb;\n}\n\n/** @internal */\nexport function getCurrentProgramBuilder(): ProgramBuilder {\n  return currentProgramBuilder;\n}\n\nexport interface ShaderExpTagRecord {\n  [name: string]: ShaderExpTagValue;\n}\nexport type ShaderExpTagValue = string[] | string | ShaderExpTagRecord;\n\nexport type ShaderTypeFunc = {\n  (...args: any[]): PBShaderExp;\n  ptr: ShaderTypeFunc;\n  [dim: number]: ShaderTypeFunc;\n};\n\n/** @internal */\nexport function makeConstructor(typeFunc: ShaderTypeFunc, elementType: PBTypeInfo): ShaderTypeFunc {\n  const wrappedTypeFunc = new Proxy(typeFunc, {\n    get: function (target, prop) {\n      if (typeof prop === 'symbol' || prop in target) {\n        return target[prop];\n      }\n      let entries = constructorCache.get(typeFunc);\n      if (!entries) {\n        entries = {};\n        constructorCache.set(typeFunc, entries);\n      }\n      let ctor = entries[prop];\n      if (!ctor) {\n        if (elementType.isPrimitiveType() || elementType.isStructType() || elementType.isArrayType()) {\n          if (prop === 'ptr') {\n            const pointerType = new PBPointerTypeInfo(elementType, PBAddressSpace.FUNCTION);\n            ctor = function pointerCtor(this: ProgramBuilder, ...args: any[]) {\n              if (args.length === 1 && typeof args[0] === 'string') {\n                return new PBShaderExp(args[0], pointerType);\n              } else {\n                throw new Error(`Invalid pointer type constructor`);\n              }\n            } as ShaderTypeFunc;\n          } else {\n            const dim = Number(prop);\n            if (Number.isInteger(dim) && dim >= 0) {\n              const arrayType = new PBArrayTypeInfo(elementType, dim);\n              const arrayTypeFunc = function arrayCtor(this: ProgramBuilder, ...args: any[]) {\n                if (args.length === 1 && typeof args[0] === 'string') {\n                  return new PBShaderExp(args[0], arrayType);\n                } else {\n                  const exp = new PBShaderExp('', arrayType);\n                  exp.$ast = new ASTShaderExpConstructor(exp.$typeinfo, args.map(arg => arg instanceof PBShaderExp ? arg.$ast : arg));\n                  return exp;\n                }\n              }\n              ctor = makeConstructor(arrayTypeFunc as ShaderTypeFunc, arrayType);\n            }\n          }\n        }\n      }\n      if (ctor) {\n        entries[prop] = ctor;\n      }\n      return ctor;\n    },\n  });\n  return wrappedTypeFunc;\n}\n\nexport abstract class Proxiable<T> {\n  /** @internal */\n  private proxy: Proxiable<T>;\n  constructor() {\n    this.proxy = new Proxy(this, {\n      get: function (target, prop) {\n        return typeof prop === 'string' ? target.$get(prop) : undefined;\n      },\n      set: function (target, prop, value) {\n        return typeof prop === 'string' ? target.$set(prop, value) : false;\n      }\n    }) as Proxiable<T>;\n    return this.proxy;\n  }\n  get $thisProxy(): T {\n    return this.proxy as unknown as T;\n  }\n  /** @internal */\n  protected abstract $get(prop: string): any;\n  /** @internal */\n  protected abstract $set(prop: string, value: any): boolean;\n}\n\nlet uidExp = 0;\n\nexport class PBShaderExp extends Proxiable<PBShaderExp> {\n  /** @internal */\n  $uid: number;\n  /** @internal */\n  $str: string;\n  /** @internal */\n  $location: number;\n  /** @internal */\n  $typeinfo: PBTypeInfo;\n  /** @internal */\n  $global: boolean;\n  /** @internal */\n  $sampleType: 'depth' | 'sint' | 'uint' | 'float' | 'unfilterable-float';\n  /** @internal */\n  $precision: ShaderPrecisionType;\n  /** @internal */\n  $ast: ASTExpression;\n  /** @internal */\n  $inout: string;\n  /** @internal */\n  $memberCache: { [name: string]: PBShaderExp };\n  /** @internal */\n  $attrib: VertexSemantic;\n  /** @internal */\n  $tags: ShaderExpTagValue[];\n  /** @internal */\n  $group: number;\n  /** @internal */\n  $declareType: DeclareType;\n  [name: string]: any;\n  /** @internal */\n  constructor(str: string, typeInfo: PBTypeInfo) {\n    super();\n    if (!str && typeInfo.isPointerType()) {\n      throw new Error('no default constructor for pointer type');\n    }\n    this.$uid = uidExp++;\n    this.$str = str || '';\n    this.$location = 0;\n    this.$global = false;\n    this.$typeinfo = typeInfo;\n    this.$qualifier = null;\n    this.$precision = ShaderPrecisionType.NONE;\n    this.$ast = new ASTPrimitive(this);\n    this.$inout = null;\n    this.$memberCache = {};\n    this.$attrib = null;\n    this.$tags = [];\n    this.$group = null;\n    this.$declareType = DeclareType.DECLARE_TYPE_NONE;\n    if (typeInfo.isTextureType()) {\n      if (typeInfo.isDepthTexture()) {\n        this.$sampleType = 'depth';\n      } else {\n        const t = getTextureSampleType(typeInfo);\n        if (t.primitiveType === PBPrimitiveType.I32) {\n          this.$sampleType = 'sint';\n        } else if (t.primitiveType === PBPrimitiveType.U32) {\n          this.$sampleType = 'uint';\n        } else {\n          this.$sampleType = 'float';\n        }\n      }\n    }\n  }\n  uniform(group: number): PBShaderExp {\n    this.$declareType = DeclareType.DECLARE_TYPE_UNIFORM;\n    this.$group = group;\n    return this;\n  }\n  workgroup(): PBShaderExp {\n    this.$declareType = DeclareType.DECLARE_TYPE_WORKGROUP;\n    return this;\n  }\n  storage(group: number): PBShaderExp {\n    if (!this.$typeinfo.isHostSharable()) {\n      throw new PBASTError(this.$ast, 'type cannot be declared in storage address space');\n    }\n    this.$declareType = DeclareType.DECLARE_TYPE_STORAGE;\n    this.$group = group;\n    return this;\n  }\n  attrib(attr: VertexSemantic): PBShaderExp {\n    this.$declareType = DeclareType.DECLARE_TYPE_IN;\n    this.$attrib = attr;\n    return this;\n  }\n  tag(...args: ShaderExpTagValue[]): PBShaderExp {\n    args.forEach(val => {\n      if (this.$tags.indexOf(val) < 0) {\n        this.$tags.push(val);\n      }\n    });\n    return this;\n  }\n  sampleType(type: 'float' | 'unfilterable-float' | 'sint' | 'uint' | 'depth'): PBShaderExp {\n    if (type) {\n      this.$sampleType = type;\n    }\n    return this;\n  }\n  at(index: number | PBShaderExp) {\n    const varType = this.$ast.getType();\n    if (!varType.isArrayType()) {\n      throw new Error('at() function must be used with array types');\n    }\n    if (typeof index === 'number') {\n      if (!Number.isInteger(index)) {\n        throw new Error('at() array index must be integer type');\n      }\n      if (index < 0 || (varType.dimension > 0 && index >= varType.dimension)) {\n        throw new Error('at() array index out of bounds');\n      }\n    }\n    const result = new PBShaderExp('', varType.elementType);\n    result.$ast = new ASTArrayIndex(this.$ast, typeof index === 'number' ? new ASTScalar(index, typeI32) : index.$ast, varType.elementType);\n    return result;\n  }\n  setAt(index: number | PBShaderExp, val: number | boolean | PBShaderExp) {\n    const varType = this.$ast.getType();\n    if (!varType.isArrayType()) {\n      throw new Error('setAt() function must be used with array types');\n    }\n    if (typeof index === 'number') {\n      if (!Number.isInteger(index)) {\n        throw new Error('setAt() array index must be integer type');\n      }\n      if (index < 0 || (varType.dimension > 0 && index >= varType.dimension)) {\n        throw new Error('setAt() array index out of bounds');\n      }\n    }\n    currentProgramBuilder.currentScope().$ast.statements.push(new ASTAssignment(new ASTLValueArray(new ASTLValueScalar(this.$ast), typeof index === 'number' ? new ASTScalar(index, typeI32) : index.$ast, varType.elementType), val instanceof PBShaderExp ? val.$ast : val));\n  }\n  highp(): PBShaderExp {\n    this.$precision = ShaderPrecisionType.HIGH;\n    return this;\n  }\n  mediump(): PBShaderExp {\n    this.$precision = ShaderPrecisionType.MEDIUM;\n    return this;\n  }\n  lowp(): PBShaderExp {\n    this.$precision = ShaderPrecisionType.LOW;\n    return this;\n  }\n  isVector(): boolean {\n    const varType = this.$ast.getType();\n    return varType.isPrimitiveType() && varType.isVectorType();\n  }\n  numComponents(): number {\n    const varType = this.$ast.getType();\n    return varType.isPrimitiveType() ? varType.cols : 0;\n  }\n  getTypeName(): string {\n    return this.$ast.getType().toTypeName(currentProgramBuilder.getDeviceType());\n  }\n  /** @internal */\n  protected $get(prop: string): any {\n    if (typeof prop === 'string') {\n      if (prop[0] === '$' || prop in this) {\n        return this[prop];\n      } else {\n        let exp = this.$memberCache[prop];\n        if (!exp) {\n          const varType = this.$ast?.getType() || this.$typeinfo;\n          const num = Number(prop);\n          if (Number.isNaN(num)) {\n            if (varType.isStructType()) {\n              const elementIndex = varType.structMembers.findIndex(val => val.name === prop);\n              if (elementIndex < 0) {\n                throw new Error(`unknown struct member '${prop}'`);\n              }\n              const element = varType.structMembers[elementIndex];\n              if (element.type.isStructType()) {\n                const ctor = currentProgramBuilder.structInfo.structs[element.type.structName];\n                exp = ctor.call(currentProgramBuilder, `${this.$str}.${prop}`);\n              } else {\n                exp = new PBShaderExp(`${this.$str}.${prop}`, element.type);\n              }\n              exp.$ast = new ASTHash(this.$ast, prop, element.type);\n            } else {\n              if (!varType.isPrimitiveType() || !varType.isVectorType()) {\n                throw new Error(`invalid index operation: ${this.$ast.toString(currentProgramBuilder.getDeviceType())}[${prop}]`);\n              }\n              if (prop.length === 0\n                || prop.length > varType.cols\n                || ([...prop].some(val => 'xyzw'.slice(0, varType.cols).indexOf(val) < 0)\n                  && [...prop].some(val => 'rgba'.slice(0, varType.cols).indexOf(val) < 0))) {\n                throw new Error(`unknown swizzle target: ${this.$ast.toString(currentProgramBuilder.getDeviceType())}[${prop}]`);\n              }\n              const type = PBPrimitiveTypeInfo.getCachedTypeInfo(varType.resizeType(1, prop.length));\n              exp = new PBShaderExp('', type);\n              exp.$ast = new ASTHash(this.$ast, prop, type);\n            }\n          } else {\n            if (varType.isArrayType()) {\n              exp = this.at(num);\n            } else if (varType.isPrimitiveType() && varType.isVectorType()) {\n              if (num >= varType.cols) {\n                throw new Error(`component index out of bounds: ${this.$str}[${num}]`);\n              }\n              exp = this.$get('xyzw'[num]);\n            } else if (varType.isPrimitiveType() && varType.isMatrixType()) {\n              const type = PBPrimitiveTypeInfo.getCachedTypeInfo(varType.resizeType(1, varType.cols));\n              exp = new PBShaderExp('', type);\n              exp.$ast = new ASTArrayIndex(this.$ast, new ASTScalar(num, typeI32), type);\n            } else {\n              throw new Error(`invalid index operation: ${this.$str}[${num}]`);\n            }\n          }\n          this.$memberCache[prop] = exp;\n        }\n        return exp;\n      }\n    } else {\n      return undefined;\n    }\n  }\n  /** @internal */\n  protected $set(prop: string, value: any): boolean {\n    if (typeof prop === 'string') {\n      if (prop[0] === '$' || prop in this) {\n        this[prop] = value;\n      } else {\n        if ((typeof value !== 'number') && (typeof value !== 'boolean') && !(value instanceof PBShaderExp)) {\n          throw new Error(`Invalid output value assignment`);\n        }\n        const varType = this.$ast?.getType() || this.$typeinfo;\n        const num = Number(prop);\n        if (Number.isNaN(num)) {\n          if (varType.isStructType()) {\n            const elementIndex = varType.structMembers.findIndex(val => val.name === prop);\n            if (elementIndex < 0) {\n              throw new Error(`unknown struct member '${prop}`);\n            }\n            const element = varType.structMembers[elementIndex];\n            let dstAST: ASTExpression;\n            if (typeof value === 'number' || typeof value === 'boolean') {\n              if (!element.type.isPrimitiveType() || !element.type.isScalarType()) {\n                throw new Error(`can not set struct member '${prop}: invalid value type`);\n              }\n              dstAST = new ASTScalar(value, element.type);\n            } else if (value instanceof PBShaderExp) {\n              dstAST = value.$ast;\n            }\n            if (!dstAST) {\n              throw new Error(`can not set struct member '${prop}: invalid value type`);\n            }\n            currentProgramBuilder.currentScope().$ast.statements.push(new ASTAssignment(new ASTLValueHash(new ASTLValueScalar(this.$ast), prop, element.type), dstAST));\n          } else {\n            // FIXME: WGSL does not support l-value swizzling\n            if (prop.length > 1 || ('xyzw'.indexOf(prop) < 0 && 'rgba'.indexOf(prop) < 0)) {\n              throw new Error(`invalid index operation: ${this.$str}[${num}]`);\n            }\n            if (!varType.isPrimitiveType() || !varType.isVectorType()) {\n              throw new Error(`invalid index operation: ${this.$str}[${num}]`);\n            }\n            const type = PBPrimitiveTypeInfo.getCachedTypeInfo(varType.scalarType);\n            currentProgramBuilder.currentScope().$ast.statements.push(new ASTAssignment(new ASTLValueHash(new ASTLValueScalar(this.$ast), prop, type), value instanceof PBShaderExp ? value.$ast : value));\n          }\n        } else {\n          if (varType.isArrayType()) {\n            this.setAt(num, value);\n          } else if (varType.isPrimitiveType() && varType.isVectorType()) {\n            if (num >= varType.cols) {\n              throw new Error(`component index out of bounds: ${this.$str}[${num}]`);\n            }\n            this.$set('xyzw'[num], value);\n          } else if (varType.isPrimitiveType() && varType.isMatrixType()) {\n            if (!(value instanceof PBShaderExp)) {\n              throw new Error(`invalid matrix column vector assignment: ${this.$str}[${num}]`);\n            }\n            const type = PBPrimitiveTypeInfo.getCachedTypeInfo(varType.resizeType(1, varType.cols));\n            currentProgramBuilder.currentScope().$ast.statements.push(new ASTAssignment(new ASTLValueArray(new ASTLValueScalar(this.$ast), new ASTScalar(num, typeI32), type), value.$ast));\n          } else {\n            throw new Error(`invalid index operation: ${this.$str}[${num}]`);\n          }\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n}\n"],"names":[],"mappings":"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"}