{"version":3,"file":"programbuilder.js","sources":["../../../../../libs/device/src/device/builder/programbuilder.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { ShaderType } from '../base_types';\nimport {\n  MAX_BINDING_GROUPS,\n  GPUProgram,\n  BindGroupLayout,\n  BindGroupLayoutEntry,\n  getVertexAttribByName,\n} from '../gpuobject';\nimport { PBReflection, PBReflectionTagGetter } from './reflection';\nimport { PBShaderExp, ShaderExpTagValue, ShaderTypeFunc, setCurrentProgramBuilder, getCurrentProgramBuilder, makeConstructor } from './base';\nimport * as AST from './ast';\nimport * as errors from './errors';\nimport { setBuiltinFuncs } from './builtinfunc';\nimport { setConstructors } from './constructors';\nimport { \n  PBArrayTypeInfo,\n  PBFunctionTypeInfo,\n  PBPrimitiveType,\n  PBPrimitiveTypeInfo,\n  PBSamplerAccessMode,\n  PBStructLayout,\n  PBStructTypeInfo,\n  PBTextureTypeInfo,\n  PBTypeInfo,\n  typeBool,\n  typeF32,\n  typeFrexpResult,\n  typeFrexpResultVec2,\n  typeFrexpResultVec3,\n  typeFrexpResultVec4,\n  typeI32,\n  typeU32,\n  typeVoid,\n  typeTex2D,\n  typeTexCube,\n} from './types';\n\nimport type { DeviceType, Device } from '../device';\nimport type { StorageTextureConstructor } from './constructors';\n\nconst COMPUTE_UNIFORM_NAME = 'ch_compute_block';\nconst VERTEX_UNIFORM_NAME = 'ch_vertex_block';\nconst FRAGMENT_UNIFORM_NAME = 'ch_fragment_block';\nconst SHARED_UNIFORM_NAME = 'ch_shared_block';\ninterface UniformInfo {\n  group: number;\n  binding: number;\n  mask: number;\n  block?: {\n    name: string;\n    dynamicOffset: boolean;\n    exp: PBShaderExp;\n  };\n  texture?: {\n    autoBindSampler: 'sample' | 'comparison';\n    exp: PBShaderExp;\n  }\n  sampler?: PBShaderExp;\n}\n\nexport type ExpValueNonArrayType = number | boolean | PBShaderExp;\nexport type ExpValueType = ExpValueNonArrayType | Array<ExpValueType>;\n\nconst input_prefix = 'ch_input_';\nconst output_prefix = 'ch_output_';\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace ProgramBuilder {\n  export type VertexAttribSet = { [attrib: number]: PBShaderExp };\n  export type VaryingSet = { [name: string]: PBShaderExp };\n  export type ColorOutputs = PBShaderExp[];\n  export type BuildRenderResult = [string, string, BindGroupLayout[], number[]];\n  export type BuildComputeResult = [string, BindGroupLayout[]];\n  export type RenderOptions = {\n    label?: string,\n    vertex: (this: PBGlobalScope) => void,\n    fragment: (this: PBGlobalScope) => void\n  };\n  export type ComputeOptions = {\n    label?: string,\n    workgroupSize: [number, number, number],\n    compute: (this: PBGlobalScope) => void,\n  };\n}\n\ntype StructDef = {\n  structs: { [name: string]: ShaderTypeFunc };\n  types: AST.ASTStructDefine[];\n};\n\nexport interface ProgramBuilder {\n  /* constructors */\n  float: {\n    (): PBShaderExp;\n    (rhs: number): PBShaderExp;\n    (rhs: boolean): PBShaderExp;\n    (rhs: PBShaderExp): PBShaderExp;\n    (name: string): PBShaderExp;\n    ptr: ShaderTypeFunc;\n    [dim: number]: ShaderTypeFunc;\n  },\n  int: {\n    (): PBShaderExp;\n    (rhs: number | boolean | PBShaderExp | string): PBShaderExp;\n    ptr: ShaderTypeFunc;\n    [dim: number]: ShaderTypeFunc;\n  },\n  uint: {\n    (): PBShaderExp;\n    (rhs: number | boolean | PBShaderExp | string): PBShaderExp;\n    ptr: ShaderTypeFunc;\n    [dim: number]: ShaderTypeFunc;\n  },\n  bool: {\n    (): PBShaderExp;\n    (rhs: number | boolean | PBShaderExp | string): PBShaderExp;\n    ptr: ShaderTypeFunc;\n    [dim: number]: ShaderTypeFunc;\n  },\n  vec2: {\n    (): PBShaderExp;\n    (rhs: number | PBShaderExp | string): PBShaderExp;\n    (x: number | PBShaderExp, y: number | PBShaderExp): PBShaderExp;\n    ptr: ShaderTypeFunc;\n    [dim: number]: ShaderTypeFunc;\n  },\n  ivec2: {\n    (): PBShaderExp;\n    (rhs: number | PBShaderExp | string): PBShaderExp;\n    (x: number | PBShaderExp, y: number | PBShaderExp): PBShaderExp;\n    ptr: ShaderTypeFunc;\n    [dim: number]: ShaderTypeFunc;\n  },\n  uvec2: {\n    (): PBShaderExp;\n    (rhs: number | PBShaderExp | string): PBShaderExp;\n    (x: number | PBShaderExp, y: number | PBShaderExp): PBShaderExp;\n    ptr: ShaderTypeFunc;\n    [dim: number]: ShaderTypeFunc;\n  },\n  bvec2: {\n    (): PBShaderExp;\n    (rhs: number | boolean | PBShaderExp | string): PBShaderExp;\n    (x: number | boolean | PBShaderExp, y: number | boolean | PBShaderExp): PBShaderExp;\n    ptr: ShaderTypeFunc;\n    [dim: number]: ShaderTypeFunc;\n  },\n  vec3: {\n    (): PBShaderExp;\n    (name: string): PBShaderExp;\n    (x: number | PBShaderExp): PBShaderExp;\n    (x: number | PBShaderExp, y: number | PBShaderExp, z: number | PBShaderExp): PBShaderExp;\n    (x: number | PBShaderExp, yz: PBShaderExp): PBShaderExp;\n    (xy: PBShaderExp, z: number | PBShaderExp): PBShaderExp;\n    ptr: ShaderTypeFunc;\n    [dim: number]: ShaderTypeFunc;\n  },\n  ivec3: {\n    (): PBShaderExp;\n    (name: string): PBShaderExp;\n    (x: number | PBShaderExp): PBShaderExp;\n    (x: number | PBShaderExp, y: number | PBShaderExp, z: number | PBShaderExp): PBShaderExp;\n    (x: number | PBShaderExp, yz: PBShaderExp): PBShaderExp;\n    (xy: PBShaderExp, z: number | PBShaderExp): PBShaderExp;\n    ptr: ShaderTypeFunc;\n    [dim: number]: ShaderTypeFunc;\n  },\n  uvec3: {\n    (): PBShaderExp;\n    (name: string): PBShaderExp;\n    (x: number | PBShaderExp): PBShaderExp;\n    (x: number | PBShaderExp, y: number | PBShaderExp, z: number | PBShaderExp): PBShaderExp;\n    (x: number | PBShaderExp, yz: PBShaderExp): PBShaderExp;\n    (xy: PBShaderExp, z: number | PBShaderExp): PBShaderExp;\n    ptr: ShaderTypeFunc;\n    [dim: number]: ShaderTypeFunc;\n  },\n  bvec3: {\n    (): PBShaderExp;\n    (name: string): PBShaderExp;\n    (x: boolean | PBShaderExp): PBShaderExp;\n    (x: boolean | PBShaderExp, y: boolean | PBShaderExp, z: boolean | PBShaderExp): PBShaderExp;\n    (x: boolean | PBShaderExp, yz: PBShaderExp): PBShaderExp;\n    (xy: PBShaderExp, z: boolean | PBShaderExp): PBShaderExp;\n    ptr: ShaderTypeFunc;\n    [dim: number]: ShaderTypeFunc;\n  },\n  vec4: {\n    (): PBShaderExp;\n    (name: string): PBShaderExp;\n    (x: number | PBShaderExp): PBShaderExp;\n    (x: number | PBShaderExp, y: number | PBShaderExp, z: number | PBShaderExp, w: number | PBShaderExp): PBShaderExp;\n    (x: number | PBShaderExp, y: number | PBShaderExp, zw: PBShaderExp): PBShaderExp\n    (x: number | PBShaderExp, yz: PBShaderExp, w: number | PBShaderExp): PBShaderExp;\n    (x: number | PBShaderExp, yzw: PBShaderExp): PBShaderExp;\n    (xy: PBShaderExp, z: number | PBShaderExp, w: number | PBShaderExp): PBShaderExp;\n    (xy: PBShaderExp, zw: PBShaderExp): PBShaderExp;\n    (xyz: PBShaderExp, w: number | PBShaderExp): PBShaderExp;\n    ptr: ShaderTypeFunc;\n    [dim: number]: ShaderTypeFunc;\n  },\n  ivec4: {\n    (): PBShaderExp;\n    (name: string): PBShaderExp;\n    (x: number | PBShaderExp): PBShaderExp;\n    (x: number | PBShaderExp, y: number | PBShaderExp, z: number | PBShaderExp, w: number | PBShaderExp): PBShaderExp;\n    (x: number | PBShaderExp, y: number | PBShaderExp, zw: PBShaderExp): PBShaderExp\n    (x: number | PBShaderExp, yz: PBShaderExp, w: number | PBShaderExp): PBShaderExp;\n    (x: number | PBShaderExp, yzw: PBShaderExp): PBShaderExp;\n    (xy: PBShaderExp, z: number | PBShaderExp, w: number | PBShaderExp): PBShaderExp;\n    (xy: PBShaderExp, zw: PBShaderExp): PBShaderExp;\n    (xyz: PBShaderExp, w: number | PBShaderExp): PBShaderExp;\n    ptr: ShaderTypeFunc;\n    [dim: number]: ShaderTypeFunc;\n  },\n  uvec4: {\n    (): PBShaderExp;\n    (name: string): PBShaderExp;\n    (x: number | PBShaderExp): PBShaderExp;\n    (x: number | PBShaderExp, y: number | PBShaderExp, z: number | PBShaderExp, w: number | PBShaderExp): PBShaderExp;\n    (x: number | PBShaderExp, y: number | PBShaderExp, zw: PBShaderExp): PBShaderExp\n    (x: number | PBShaderExp, yz: PBShaderExp, w: number | PBShaderExp): PBShaderExp;\n    (x: number | PBShaderExp, yzw: PBShaderExp): PBShaderExp;\n    (xy: PBShaderExp, z: number | PBShaderExp, w: number | PBShaderExp): PBShaderExp;\n    (xy: PBShaderExp, zw: PBShaderExp): PBShaderExp;\n    (xyz: PBShaderExp, w: number | PBShaderExp): PBShaderExp;\n    ptr: ShaderTypeFunc;\n    [dim: number]: ShaderTypeFunc;\n  },\n  bvec4: {\n    (): PBShaderExp;\n    (name: string): PBShaderExp;\n    (x: boolean | PBShaderExp): PBShaderExp;\n    (x: boolean | PBShaderExp, y: boolean | PBShaderExp, z: boolean | PBShaderExp, w: boolean | PBShaderExp): PBShaderExp;\n    (x: boolean | PBShaderExp, y: boolean | PBShaderExp, zw: PBShaderExp): PBShaderExp\n    (x: boolean | PBShaderExp, yz: PBShaderExp, w: boolean | PBShaderExp): PBShaderExp;\n    (x: boolean | PBShaderExp, yzw: PBShaderExp): PBShaderExp;\n    (xy: PBShaderExp, z: boolean | PBShaderExp, w: boolean | PBShaderExp): PBShaderExp;\n    (xy: PBShaderExp, zw: PBShaderExp): PBShaderExp;\n    (xyz: PBShaderExp, w: boolean | PBShaderExp): PBShaderExp;\n    ptr: ShaderTypeFunc;\n    [dim: number]: ShaderTypeFunc;\n  },\n  mat2: {\n    (): PBShaderExp;\n    (name: string): PBShaderExp;\n    (m00: number | PBShaderExp, m01: number | PBShaderExp,\n      m10: number | PBShaderExp, m11: number | PBShaderExp): PBShaderExp;\n    (m0: PBShaderExp, m1: PBShaderExp): PBShaderExp;\n    ptr: ShaderTypeFunc;\n    [dim: number]: ShaderTypeFunc;\n  },\n  mat2x3: {\n    (): PBShaderExp;\n    (name: string): PBShaderExp;\n    (m00: number | PBShaderExp, m01: number | PBShaderExp, m02: number | PBShaderExp,\n      m10: number | PBShaderExp, m11: number | PBShaderExp, m12: number | PBShaderExp): PBShaderExp;\n    (m0: PBShaderExp, m1: PBShaderExp): PBShaderExp;\n    ptr: ShaderTypeFunc;\n    [dim: number]: ShaderTypeFunc;\n  },\n  mat2x4: {\n    (): PBShaderExp;\n    (name: string): PBShaderExp;\n    (m00: number | PBShaderExp, m01: number | PBShaderExp, m02: number | PBShaderExp, m03: number | PBShaderExp,\n      m10: number | PBShaderExp, m11: number | PBShaderExp, m12: number | PBShaderExp, m13: number | PBShaderExp): PBShaderExp;\n    (m0: PBShaderExp, m1: PBShaderExp): PBShaderExp;\n    ptr: ShaderTypeFunc;\n    [dim: number]: ShaderTypeFunc;\n  },\n  mat3: {\n    (): PBShaderExp;\n    (name: string): PBShaderExp;\n    (m00: number | PBShaderExp, m01: number | PBShaderExp, m02: number | PBShaderExp,\n      m10: number | PBShaderExp, m11: number | PBShaderExp, m12: number | PBShaderExp,\n      m20: number | PBShaderExp, m21: number | PBShaderExp, m22: number | PBShaderExp): PBShaderExp;\n    (m0: PBShaderExp, m1: PBShaderExp, m2: PBShaderExp): PBShaderExp;\n    ptr: ShaderTypeFunc;\n    [dim: number]: ShaderTypeFunc;\n  },\n  mat3x2: {\n    (): PBShaderExp;\n    (name: string): PBShaderExp;\n    (m00: number | PBShaderExp, m01: number | PBShaderExp,\n      m10: number | PBShaderExp, m11: number | PBShaderExp,\n      m20: number | PBShaderExp, m21: number | PBShaderExp): PBShaderExp;\n    (m0: PBShaderExp, m1: PBShaderExp, m2: PBShaderExp): PBShaderExp;\n    ptr: ShaderTypeFunc;\n    [dim: number]: ShaderTypeFunc;\n  },\n  mat3x4: {\n    (): PBShaderExp;\n    (name: string): PBShaderExp;\n    (m00: number | PBShaderExp, m01: number | PBShaderExp, m02: number | PBShaderExp, m03: number | PBShaderExp,\n      m10: number | PBShaderExp, m11: number | PBShaderExp, m12: number | PBShaderExp, m13: number | PBShaderExp,\n      m20: number | PBShaderExp, m21: number | PBShaderExp, m22: number | PBShaderExp, m23: number | PBShaderExp): PBShaderExp;\n    (m0: PBShaderExp, m1: PBShaderExp, m2: PBShaderExp): PBShaderExp;\n    ptr: ShaderTypeFunc;\n    [dim: number]: ShaderTypeFunc;\n  },\n  mat4: {\n    (): PBShaderExp;\n    (name: string): PBShaderExp;\n    (m00: number | PBShaderExp, m01: number | PBShaderExp, m02: number | PBShaderExp, m03: number | PBShaderExp,\n      m10: number | PBShaderExp, m11: number | PBShaderExp, m12: number | PBShaderExp, m13: number | PBShaderExp,\n      m20: number | PBShaderExp, m21: number | PBShaderExp, m22: number | PBShaderExp, m23: number | PBShaderExp,\n      m30: number | PBShaderExp, m31: number | PBShaderExp, m32: number | PBShaderExp, m33: number | PBShaderExp): PBShaderExp;\n    (m0: PBShaderExp, m1: PBShaderExp, m2: PBShaderExp, m3: PBShaderExp): PBShaderExp;\n    ptr: ShaderTypeFunc;\n    [dim: number]: ShaderTypeFunc;\n  },\n  mat4x2: {\n    (): PBShaderExp;\n    (name: string): PBShaderExp;\n    (m00: number | PBShaderExp, m01: number | PBShaderExp,\n      m10: number | PBShaderExp, m11: number | PBShaderExp,\n      m20: number | PBShaderExp, m21: number | PBShaderExp,\n      m30: number | PBShaderExp, m31: number | PBShaderExp): PBShaderExp;\n    (m0: PBShaderExp, m1: PBShaderExp, m2: PBShaderExp, m3: PBShaderExp): PBShaderExp;\n    ptr: ShaderTypeFunc;\n    [dim: number]: ShaderTypeFunc;\n  },\n  mat4x3: {\n    (): PBShaderExp;\n    (name: string): PBShaderExp;\n    (m00: number | PBShaderExp, m01: number | PBShaderExp, m02: number | PBShaderExp,\n      m10: number | PBShaderExp, m11: number | PBShaderExp, m12: number | PBShaderExp,\n      m20: number | PBShaderExp, m21: number | PBShaderExp, m22: number | PBShaderExp,\n      m30: number | PBShaderExp, m31: number | PBShaderExp, m32: number | PBShaderExp): PBShaderExp;\n    (m0: PBShaderExp, m1: PBShaderExp, m2: PBShaderExp, m3: PBShaderExp): PBShaderExp;\n    ptr: ShaderTypeFunc;\n    [dim: number]: ShaderTypeFunc;\n  },\n  tex1D(rhs?: string): PBShaderExp;\n  tex2D(rhs?: string): PBShaderExp;\n  tex3D(rhs?: string): PBShaderExp;\n  texCube(rhs?: string): PBShaderExp;\n  texExternal(rhs?: string): PBShaderExp;\n  tex2DShadow(rhs?: string): PBShaderExp;\n  texCubeShadow(rhs?: string): PBShaderExp;\n  tex2DArray(rhs?: string): PBShaderExp;\n  tex2DArrayShadow(rhs?: string): PBShaderExp;\n  itex1D(rhs?: string): PBShaderExp;\n  itex2D(rhs?: string): PBShaderExp;\n  itex3D(rhs?: string): PBShaderExp;\n  itexCube(rhs?: string): PBShaderExp;\n  itex2DArray(rhs?: string): PBShaderExp;\n  utex1D(rhs?: string): PBShaderExp;\n  utex2D(rhs?: string): PBShaderExp;\n  utex3D(rhs?: string): PBShaderExp;\n  utexCube(rhs?: string): PBShaderExp;\n  utex2DArray(rhs?: string): PBShaderExp;\n  texStorage1D: StorageTextureConstructor;\n  texStorage2D: StorageTextureConstructor;\n  texStorage2DArray: StorageTextureConstructor;\n  texStorage3D: StorageTextureConstructor;\n  sampler(rhs?: string): PBShaderExp;\n  samplerComparison(rhs?: string): PBShaderExp;\n  /** builtin functions */\n  radians(val: number | PBShaderExp): PBShaderExp;\n  degrees(val: number | PBShaderExp): PBShaderExp;\n  sin(val: number | PBShaderExp): PBShaderExp;\n  cos(val: number | PBShaderExp): PBShaderExp;\n  tan(val: number | PBShaderExp): PBShaderExp;\n  asin(val: number | PBShaderExp): PBShaderExp;\n  acos(val: number | PBShaderExp): PBShaderExp;\n  atan(val: number | PBShaderExp): PBShaderExp;\n  atan2(y: number | PBShaderExp, x: number | PBShaderExp): PBShaderExp;\n  sinh(val: number | PBShaderExp): PBShaderExp;\n  cosh(val: number | PBShaderExp): PBShaderExp;\n  tanh(val: number | PBShaderExp): PBShaderExp;\n  asinh(val: number | PBShaderExp): PBShaderExp;\n  acosh(val: number | PBShaderExp): PBShaderExp;\n  atanh(val: number | PBShaderExp): PBShaderExp;\n  pow(x: number | PBShaderExp, y: number | PBShaderExp): PBShaderExp;\n  exp(val: number | PBShaderExp): PBShaderExp;\n  exp2(val: number | PBShaderExp): PBShaderExp;\n  log(val: number | PBShaderExp): PBShaderExp;\n  log2(val: number | PBShaderExp): PBShaderExp;\n  sqrt(val: number | PBShaderExp): PBShaderExp;\n  inverseSqrt(val: number | PBShaderExp): PBShaderExp;\n  abs(val: number | PBShaderExp): PBShaderExp;\n  sign(val: number | PBShaderExp): PBShaderExp;\n  floor(val: number | PBShaderExp): PBShaderExp;\n  ceil(val: number | PBShaderExp): PBShaderExp;\n  fract(val: number | PBShaderExp): PBShaderExp;\n  mod(x: number | PBShaderExp, y: number | PBShaderExp): PBShaderExp;\n  fma(x: number | PBShaderExp, y: number | PBShaderExp, z: number | PBShaderExp): PBShaderExp;\n  round(val: number | PBShaderExp): PBShaderExp;\n  trunc(val: number | PBShaderExp): PBShaderExp;\n  min(x: number | PBShaderExp, y: number | PBShaderExp): PBShaderExp;\n  max(x: number | PBShaderExp, y: number | PBShaderExp): PBShaderExp;\n  clamp(x: number | PBShaderExp, y: number | PBShaderExp, z: number | PBShaderExp): PBShaderExp;\n  mix(x: number | PBShaderExp, y: number | PBShaderExp, z: number | PBShaderExp): PBShaderExp;\n  step(x: number | PBShaderExp, y: number | PBShaderExp): PBShaderExp;\n  smoothStep(x: number | PBShaderExp, y: number | PBShaderExp, z: number | PBShaderExp): PBShaderExp;\n  isnan(x: number | PBShaderExp): PBShaderExp;\n  isinf(x: number | PBShaderExp): PBShaderExp;\n  add_2(x: number | PBShaderExp, y: number | PBShaderExp);\n  add(x: number | PBShaderExp, ...rest: (number | PBShaderExp)[]);\n  sub(x: number | PBShaderExp, y: number | PBShaderExp);\n  mul_2(x: number | PBShaderExp, y: number | PBShaderExp);\n  mul(x: number | PBShaderExp, ...rest: (number | PBShaderExp)[]);\n  div(x: number | PBShaderExp, y: number | PBShaderExp);\n  length(x: number | PBShaderExp): PBShaderExp;\n  distance(x: number | PBShaderExp, y: number | PBShaderExp): PBShaderExp;\n  dot(x: PBShaderExp, y: PBShaderExp): PBShaderExp;\n  cross(x: PBShaderExp, y: PBShaderExp): PBShaderExp;\n  normalize(x: PBShaderExp): PBShaderExp;\n  faceForward(x: PBShaderExp, y: PBShaderExp, z: PBShaderExp): PBShaderExp;\n  reflect(x: PBShaderExp, y: PBShaderExp): PBShaderExp;\n  refract(x: PBShaderExp, y: PBShaderExp, z: number | PBShaderExp): PBShaderExp;\n  frexp(x: number | PBShaderExp): PBShaderExp;\n  outerProduct(x: PBShaderExp, y: PBShaderExp): PBShaderExp;\n  transpose(mat: PBShaderExp): PBShaderExp;\n  determinant(mat: PBShaderExp): PBShaderExp;\n  inverse(mat: PBShaderExp): PBShaderExp;\n  lessThan(x: number | PBShaderExp, y: number | PBShaderExp): PBShaderExp;\n  lessThanEqual(x: number | PBShaderExp, y: number | PBShaderExp): PBShaderExp;\n  greaterThan(x: number | PBShaderExp, y: number | PBShaderExp): PBShaderExp;\n  greaterThanEqual(x: number | PBShaderExp, y: number | PBShaderExp): PBShaderExp;\n  compEqual(x: PBShaderExp, y: PBShaderExp): PBShaderExp;\n  compNotEqual(x: PBShaderExp, y: PBShaderExp): PBShaderExp;\n  equal(x: PBShaderExp | number, y: PBShaderExp | number): PBShaderExp;\n  notEqual(x: PBShaderExp | number, y: PBShaderExp | number): PBShaderExp;\n  and_2(x: PBShaderExp | number | boolean, y: PBShaderExp | number | boolean): PBShaderExp;\n  and(x: PBShaderExp | number | boolean, ...rest: (PBShaderExp | number | boolean)[]);\n  compAnd(x: PBShaderExp | number | boolean, y: PBShaderExp | number | boolean): PBShaderExp;\n  or(x: PBShaderExp | number | boolean, y: PBShaderExp | number | boolean): PBShaderExp;\n  compOr(x: PBShaderExp | number | boolean, y: PBShaderExp | number | boolean): PBShaderExp;\n  any(x: PBShaderExp): PBShaderExp;\n  all(x: PBShaderExp): PBShaderExp;\n  not(x: boolean | PBShaderExp): PBShaderExp;\n  neg(x: number | PBShaderExp): PBShaderExp;\n  arrayLength(x: PBShaderExp): PBShaderExp;\n  select(x: number | PBShaderExp, y: number | PBShaderExp, cond: boolean | PBShaderExp): PBShaderExp;\n  floatBitsToInt(x: number | PBShaderExp): PBShaderExp;\n  floatBitsToUint(x: number | PBShaderExp): PBShaderExp;\n  intBitsToFloat(x: number | PBShaderExp): PBShaderExp;\n  uintBitsToFloat(x: number | PBShaderExp): PBShaderExp;\n  pack4x8snorm(x: PBShaderExp): PBShaderExp;\n  unpack4x8snorm(x: number | PBShaderExp): PBShaderExp;\n  pack4x8unorm(x: PBShaderExp): PBShaderExp;\n  unpack4x8unorm(x: number | PBShaderExp): PBShaderExp;\n  pack2x16snorm(x: PBShaderExp): PBShaderExp;\n  unpack2x16snorm(x: number | PBShaderExp): PBShaderExp;\n  pack2x16unorm(x: PBShaderExp): PBShaderExp;\n  unpack2x16unorm(x: number | PBShaderExp): PBShaderExp;\n  pack2x16float(x: PBShaderExp): PBShaderExp;\n  unpack2x16float(x: number | PBShaderExp): PBShaderExp;\n  matrixCompMult(x: PBShaderExp, y: PBShaderExp): PBShaderExp;\n  dpdx(x: PBShaderExp): PBShaderExp;\n  dpdy(x: PBShaderExp): PBShaderExp;\n  fwidth(x: PBShaderExp): PBShaderExp;\n  dpdxCoarse(x: PBShaderExp): PBShaderExp;\n  dpdxFine(x: PBShaderExp): PBShaderExp;\n  dpdyCoarse(x: PBShaderExp): PBShaderExp;\n  dpdyFine(x: PBShaderExp): PBShaderExp;\n  textureDimensions(tex: PBShaderExp, level?: number | PBShaderExp): PBShaderExp;\n  textureGather(tex: PBShaderExp, sampler: PBShaderExp, coords: PBShaderExp): PBShaderExp;\n  textureGather(component: number | PBShaderExp, tex: PBShaderExp, sampler: PBShaderExp, coords: PBShaderExp): PBShaderExp;\n  textureArrayGather(tex: PBShaderExp, sampler: PBShaderExp, coords: PBShaderExp, arrayIndex: number | PBShaderExp): PBShaderExp;\n  textureArrayGather(component: number | PBShaderExp, tex: PBShaderExp, sampler: PBShaderExp, coords: PBShaderExp, arrayIndex: number | PBShaderExp): PBShaderExp;\n  textureGatherCompare(tex: PBShaderExp, samplerCompare: PBShaderExp, coords: PBShaderExp, depthRef: number | PBShaderExp): PBShaderExp;\n  textureArrayGatherCompare(tex: PBShaderExp, samplerCompare: PBShaderExp, coords: PBShaderExp, arrayIndex: number | PBShaderExp, depthRef: number | PBShaderExp): PBShaderExp;\n  textureLoad(tex: PBShaderExp, coords: number | PBShaderExp, levelOrSampleIndex: number | PBShaderExp): PBShaderExp;\n  textureArrayLoad(tex: PBShaderExp, coords: number | PBShaderExp, arrayIndex: number | PBShaderExp, level: number | PBShaderExp): PBShaderExp;\n  textureStore(tex: PBShaderExp, coords: number | PBShaderExp, value: PBShaderExp): void;\n  textureArrayStore(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number | PBShaderExp, value: PBShaderExp): void;\n  textureNumLayers(tex: PBShaderExp): PBShaderExp;\n  textureNumLevels(tex: PBShaderExp): PBShaderExp;\n  textureNumSamples(tex: PBShaderExp): PBShaderExp;\n  textureSample(tex: PBShaderExp, coords: number | PBShaderExp): PBShaderExp;\n  textureArraySample(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number | PBShaderExp): PBShaderExp;\n  textureSampleBias(tex: PBShaderExp, coords: PBShaderExp, bias: number | PBShaderExp): PBShaderExp;\n  textureArraySampleBias(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number | PBShaderExp, bias: number | PBShaderExp): PBShaderExp;\n  textureSampleCompare(tex: PBShaderExp, coords: PBShaderExp, depthRef: number | PBShaderExp): PBShaderExp;\n  textureArraySampleCompare(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number | PBShaderExp, depthRef: number | PBShaderExp): PBShaderExp;\n  textureSampleLevel(tex: PBShaderExp, coords: PBShaderExp): PBShaderExp;\n  textureSampleLevel(tex: PBShaderExp, coords: PBShaderExp, level: number | PBShaderExp): PBShaderExp;\n  textureArraySampleLevel(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number | PBShaderExp, level: number | PBShaderExp): PBShaderExp;\n  textureSampleCompareLevel(tex: PBShaderExp, coords: PBShaderExp, depthRef: number | PBShaderExp): PBShaderExp;\n  textureArraySampleCompareLevel(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number | PBShaderExp, depthRef: number | PBShaderExp): PBShaderExp;\n  textureSampleGrad(tex: PBShaderExp, coords: PBShaderExp, ddx: PBShaderExp, ddy: PBShaderExp): PBShaderExp;\n  textureArraySampleGrad(tex: PBShaderExp, coords: PBShaderExp, arrayIndex: number | PBShaderExp, ddx: PBShaderExp, ddy: PBShaderExp): PBShaderExp;\n  storageBarrier(): void\n  workgroupBarrier(): void;\n}\n\nexport class ProgramBuilder {\n  /** @internal */\n  _device: Device;\n  /** @internal */\n  _workgroupSize: [number, number, number];\n  /** @internal */\n  _scopeStack: PBScope[] = [];\n  /** @internal */\n  _shaderType: ShaderType = ShaderType.Vertex | ShaderType.Fragment | ShaderType.Compute;\n  /** @internal */\n  _deviceType: DeviceType;\n  /** @internal */\n  _structInfo: { [type: number]: StructDef };\n  /** @internal */\n  _uniforms: UniformInfo[];\n  /** @internal */\n  _globalScope: PBGlobalScope;\n  /** @internal */\n  _builtinScope: PBBuiltinScope;\n  /** @internal */\n  _inputScope: PBInputScope;\n  /** @internal */\n  _outputScope: PBOutputScope;\n  /** @internal */\n  _inputs: [string, AST.ASTDeclareVar][];\n  /** @internal */\n  _outputs: [string, AST.ASTDeclareVar][];\n  /** @internal */\n  _vertexAttributes: number[];\n  /** @internal */\n  _depthRangeCorrection: boolean;\n  /** @internal */\n  _emulateDepthClamp: boolean;\n  /** @internal */\n  _lastError: string;\n  /** @internal */\n  _reflection: PBReflection;\n  /** @internal */\n  _autoStructureTypeIndex: number;\n  /** @internal */\n  _nameMap: { [name: string]: string }[];\n  constructor(device: Device | DeviceType) {\n    this._device = typeof device === 'string' ? null : device;\n    this._deviceType = typeof device === 'string' ? device : device.getDeviceType();\n    this._workgroupSize = null;\n    this._structInfo = {};\n    this._uniforms = [];\n    this._scopeStack = [];\n    this._globalScope = null;\n    this._builtinScope = null;\n    this._inputScope = null;\n    this._outputScope = null;\n    this._inputs = [];\n    this._outputs = [];\n    this._vertexAttributes = [];\n    this._depthRangeCorrection = this._deviceType === 'webgpu';\n    this._emulateDepthClamp = false;\n    this._lastError = null;\n    this._reflection = new PBReflection(this);\n    this._autoStructureTypeIndex = 0;\n    this._nameMap = [];\n  }\n  get lastError(): string {\n    return this._lastError;\n  }\n  get shaderType(): ShaderType {\n    return this._shaderType;\n  }\n  get globalScope(): PBGlobalScope {\n    return this._globalScope;\n  }\n  get builtinScope(): PBBuiltinScope {\n    return this._builtinScope;\n  }\n  get inputScope(): PBInputScope {\n    return this._inputScope;\n  }\n  get outputScope(): PBOutputScope {\n    return this._outputScope;\n  }\n  get depthRangeCorrection(): boolean {\n    return this._depthRangeCorrection;\n  }\n  set depthRangeCorrection(val: boolean) {\n    this._depthRangeCorrection = !!val;\n  }\n  get emulateDepthClamp(): boolean {\n    return this._emulateDepthClamp;\n  }\n  set emulateDepthClamp(val: boolean) {\n    if (val && !this.device?.getShaderCaps().supportFragmentDepth) {\n      console.error('can not enable depth clamp emulation');\n    } else {\n      this._emulateDepthClamp = !!val;\n    }\n  }\n  get reflection(): PBReflection {\n    return this._reflection;\n  }\n  get device(): Device {\n    return this._device;\n  }\n  reset(): void {\n    this._workgroupSize = null;\n    this._structInfo = {};\n    this._uniforms = [];\n    this._scopeStack = [];\n    this._globalScope = null;\n    this._builtinScope = null;\n    this._inputScope = null;\n    this._outputScope = null;\n    this._inputs = [];\n    this._outputs = [];\n    this._vertexAttributes = [];\n    this._depthRangeCorrection = this._deviceType === 'webgpu';\n    this._reflection = new PBReflection(this);\n    this._autoStructureTypeIndex = 0;\n    this._nameMap = [];\n  }\n  queryGlobal(name: string): PBShaderExp {\n    return this.reflection.tag(name);\n  }\n  isVertexShader(): boolean {\n    return this._shaderType === ShaderType.Vertex;\n  }\n  isFragmentShader(): boolean {\n    return this._shaderType === ShaderType.Fragment;\n  }\n  isComputeShader(): boolean {\n    return this._shaderType === ShaderType.Compute;\n  }\n  pushScope(scope: PBScope) {\n    this._scopeStack.unshift(scope);\n  }\n  popScope(): PBScope {\n    return this._scopeStack.shift();\n  }\n  currentScope(): PBScope {\n    return this._scopeStack[0];\n  }\n  buildRender(options: ProgramBuilder.RenderOptions): ProgramBuilder.BuildRenderResult {\n    setCurrentProgramBuilder(this);\n    this._lastError = null;\n    this.defineInternalStructs();\n    const ret = this.buildRenderSource(options);\n    setCurrentProgramBuilder(null);\n    this.reset();\n    return ret;\n  }\n  buildCompute(options: ProgramBuilder.ComputeOptions): ProgramBuilder.BuildComputeResult {\n    setCurrentProgramBuilder(this);\n    this._lastError = null;\n    this._workgroupSize = options.workgroupSize;\n    this.defineInternalStructs();\n    const ret = this.buildComputeSource(options);\n    setCurrentProgramBuilder(null);\n    this.reset();\n    return ret;\n  }\n  buildRenderProgram(options: ProgramBuilder.RenderOptions): GPUProgram {\n    const ret = this.buildRender(options);\n    return ret ? this._device.createGPUProgram({\n      type: 'render',\n      label: options.label,\n      params: {\n        vs: ret[0],\n        fs: ret[1],\n        bindGroupLayouts: ret[2],\n        vertexAttributes: ret[3]\n      }\n    }) : null;\n  }\n  buildComputeProgram(options: ProgramBuilder.ComputeOptions): GPUProgram {\n    const ret = this.buildCompute(options);\n    return ret ? this._device.createGPUProgram({\n      type: 'compute',\n      params: {\n        source: ret[0],\n        bindGroupLayouts: ret[1],\n      },\n    }) : null;\n  }\n  getDeviceType() {\n    return this._deviceType;\n  }\n  addressOf(ref: PBShaderExp): PBShaderExp {\n    if (this.getDeviceType() !== 'webgpu') {\n      throw new errors.PBDeviceNotSupport('pointer shader type');\n    }\n    if (!ref.$ast.isReference()) {\n      throw new errors.PBReferenceValueRequired(ref);\n    }\n    const exp = new PBShaderExp('', ref.$ast.getType());\n    exp.$ast = new AST.ASTAddressOf(ref.$ast);\n    return exp;\n  }\n  referenceOf(ptr: PBShaderExp): PBShaderExp {\n    if (this.getDeviceType() !== 'webgpu') {\n      throw new errors.PBDeviceNotSupport('pointer shader type');\n    }\n    if (!ptr.$ast.getType().isPointerType()) {\n      throw new errors.PBPointerValueRequired(ptr);\n    }\n    const ast = new AST.ASTReferenceOf(ptr.$ast);\n    const exp = new PBShaderExp('', ast.getType());\n    exp.$ast = ast;\n    return exp;\n  }\n  struct(structName: string, instanceName: string): PBShaderExp {\n    let ctor: ShaderTypeFunc = null;\n    for (const st of [ShaderType.Vertex, ShaderType.Fragment, ShaderType.Compute]) {\n      if (st & this._shaderType) {\n        const structInfo = this._structInfo[st];\n        ctor = structInfo?.structs[structName];\n        if (ctor) {\n          break;\n        }\n      }\n    }\n    if (!ctor) {\n      throw new errors.PBParamValueError('struct', 'structName', `Struct type ${structName} not exists`);\n    }\n    return ctor.call(this, instanceName);\n  }\n  /** @internal */\n  isIdenticalStruct(a: PBStructTypeInfo, b: PBStructTypeInfo): boolean {\n    if (a.structName && b.structName && a.structName !== b.structName) {\n      return false;\n    }\n    if (a.structMembers.length !== b.structMembers.length) {\n      return false;\n    }\n    for (let index = 0; index < a.structMembers.length; index++) {\n      const val = a.structMembers[index];\n      const other = b.structMembers[index];\n      if (val.name !== other.name) {\n        return false;\n      }\n      if (val.type.isStructType()) {\n        if (!other.type.isStructType()) {\n          return false;\n        }\n        if (!this.isIdenticalStruct(val.type, other.type)) {\n          return false;\n        }\n      } else if (val.type.typeId !== other.type.typeId) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /** @internal */\n  generateStructureName(): string {\n    return `ch_generated_struct_name${this._autoStructureTypeIndex++}`;\n  }\n  /** @internal */\n  getVertexAttributes(): number[] {\n    return this._vertexAttributes;\n  }\n  /** @internal */\n  defineHiddenStruct(type: PBStructTypeInfo) {\n    for (const shaderType of [ShaderType.Vertex, ShaderType.Fragment, ShaderType.Compute]) {\n      let structInfo = this._structInfo[shaderType];\n      if (!structInfo) {\n        structInfo = { structs: {}, types: [] };\n        this._structInfo[shaderType] = structInfo;\n      }\n      if (structInfo.structs[type.structName]) {\n        throw new errors.PBParamValueError('defineStruct', 'structName', `cannot re-define struct '${type.structName}'`);\n      }\n      structInfo.types.push(new AST.ASTStructDefine(type, true));\n    }\n  }\n  defineStruct(structName: string, layout: PBStructLayout, ...args: PBShaderExp[]): ShaderTypeFunc {\n    layout = layout || 'default';\n    const structType = new PBStructTypeInfo(structName || '', layout, args.map(arg => {\n      if (!arg.$typeinfo.isPrimitiveType() && !arg.$typeinfo.isArrayType() && !arg.$typeinfo.isStructType()) {\n        throw new Error(`invalid struct member type: '${arg.$str}'`);\n      }\n      return {\n        name: arg.$str,\n        type: arg.$typeinfo\n      };\n    }));\n    for (const shaderType of [ShaderType.Vertex, ShaderType.Fragment, ShaderType.Compute]) {\n      let structDef: AST.ASTStructDefine = null;\n      let ctor: ShaderTypeFunc = null;\n      const structInfo = this._structInfo[shaderType];\n      if (structInfo) {\n        if (getCurrentProgramBuilder().shaderType === shaderType && structInfo.structs[structType.structName]) {\n          throw new errors.PBParamValueError('defineStruct', 'structName', `cannot re-define struct '${structType.structName}'`);\n        }\n        for (const type of structInfo.types) {\n          if (!type.builtin && this.isIdenticalStruct(type.getType(), structType)) {\n            structDef = type;\n            ctor = structInfo.structs[type.getType().structName];\n            break;\n          }\n        }\n      }\n      if (structDef) {\n        if (structDef.type.layout !== layout) {\n          throw new Error(`Can not redefine struct ${structDef.type.structName} with different layout`);\n        }\n        if (shaderType !== getCurrentProgramBuilder().shaderType) {\n          if (!this._structInfo[getCurrentProgramBuilder().shaderType]) {\n            this._structInfo[getCurrentProgramBuilder().shaderType] = { structs: {}, types: [] };\n          }\n          this._structInfo[getCurrentProgramBuilder().shaderType].types.push(structDef);\n          this._structInfo[getCurrentProgramBuilder().shaderType].structs[structDef.getType().structName] = ctor;\n        }\n        return ctor;\n      }\n    }\n    return this.internalDefineStruct(structName || this.generateStructureName(), layout, this._shaderType, false, ...args);\n  }\n  defineStructByType(structType: PBStructTypeInfo): ShaderTypeFunc {\n    const typeCopy = structType.extends(structType.structName || this.generateStructureName(), []);\n    for (const shaderType of [ShaderType.Vertex, ShaderType.Fragment, ShaderType.Compute]) {\n      let structDef: AST.ASTStructDefine = null;\n      let ctor: ShaderTypeFunc = null;\n      const structInfo = this._structInfo[shaderType];\n      if (structInfo) {\n        if (getCurrentProgramBuilder().shaderType === shaderType && structInfo.structs[typeCopy.structName]) {\n          throw new errors.PBParamValueError('defineStruct', 'structName', `cannot re-define struct '${typeCopy.structName}'`);\n        }\n        for (const type of structInfo.types) {\n          if (!type.builtin && this.isIdenticalStruct(type.getType(), typeCopy)) {\n            structDef = type;\n            ctor = structInfo.structs[type.getType().structName];\n            break;\n          }\n        }\n      }\n      if (structDef) {\n        if (structDef.type.layout !== typeCopy.layout) {\n          throw new Error(`Can not redefine struct ${structDef.type.structName} with different layout`);\n        }\n        if (shaderType !== getCurrentProgramBuilder().shaderType) {\n          if (!this._structInfo[getCurrentProgramBuilder().shaderType]) {\n            this._structInfo[getCurrentProgramBuilder().shaderType] = { structs: {}, types: [] };\n          }\n          this._structInfo[getCurrentProgramBuilder().shaderType].types.push(structDef);\n          this._structInfo[getCurrentProgramBuilder().shaderType].structs[structDef.getType().structName] = ctor;\n        }\n        return ctor;\n      }\n    }\n    return this.internalDefineStructByType(this._shaderType, false, typeCopy);\n  }\n  /** @internal */\n  internalDefineStruct(structName: string, layout: PBStructLayout, shaderTypeMask: number, builtin: boolean, ...args: PBShaderExp[]): ShaderTypeFunc {\n    const structType = new PBStructTypeInfo(structName, layout, args.map(arg => {\n      if (!arg.$typeinfo.isPrimitiveType() && !arg.$typeinfo.isArrayType() && !arg.$typeinfo.isStructType()) {\n        throw new Error(`invalid struct member type: '${arg.$str}'`);\n      }\n      return {\n        name: arg.$str,\n        type: arg.$typeinfo\n      };\n    }));\n    return this.internalDefineStructByType(shaderTypeMask, builtin, structType);\n  }\n  /** @internal */\n  internalDefineStructByType(shaderTypeMask: number, builtin: boolean, structType: PBStructTypeInfo): ShaderTypeFunc {\n    const struct = makeConstructor(function structConstructor(...blockArgs: any[]) {\n      let e: PBShaderExp;\n      if (blockArgs.length === 1 && typeof blockArgs[0] === 'string') {\n        e = new PBShaderExp(blockArgs[0], structType);\n      } else {\n        e = new PBShaderExp('', structType);\n        e.$ast = new AST.ASTShaderExpConstructor(e.$typeinfo, blockArgs.map(arg => arg instanceof PBShaderExp ? arg.$ast : arg));\n      }\n      return e;\n    } as ShaderTypeFunc, structType);\n    for (const shaderType of [ShaderType.Vertex, ShaderType.Fragment, ShaderType.Compute]) {\n      if (shaderTypeMask & shaderType) {\n        let structInfo = this._structInfo[shaderType];\n        if (!structInfo) {\n          structInfo = { structs: {}, types: [] };\n          this._structInfo[shaderType] = structInfo;\n        }\n        if (structInfo.structs[structType.structName]) {\n          throw new errors.PBParamValueError('defineStruct', 'structName', `cannot re-define struct '${structType.structName}'`);\n        }\n        structInfo.types.push(new AST.ASTStructDefine(structType, builtin));\n        structInfo.structs[structType.structName] = struct;\n      }\n    }\n    // this.changeStructLayout(structType, layout);\n    return struct;\n  }\n  /** @internal */\n  getFunction(name: string): AST.ASTFunction {\n    return this._globalScope ? this._globalScope.$getFunction(name) : null;\n  }\n  /** @internal */\n  get structInfo(): StructDef {\n    return this._structInfo[this._shaderType];\n  }\n  /** @internal */\n  getBlockName(instanceName: string): string {\n    return `ch_block_name_${instanceName}`;\n  }\n  /** @internal */\n  defineBuiltinStruct(shaderType: ShaderType, inOrOut: 'in' | 'out'): [ShaderTypeFunc, PBShaderExp, string, PBShaderExp] {\n    const structName = inOrOut === 'in' ? AST.getBuiltinInputStructName(shaderType) : AST.getBuiltinOutputStructName(shaderType);\n    const instanceName = inOrOut === 'in' ? AST.getBuiltinInputStructInstanceName(shaderType) : AST.getBuiltinOutputStructInstanceName(shaderType);\n    const stage = shaderType === ShaderType.Vertex\n      ? 'vertex'\n      : shaderType === ShaderType.Fragment\n        ? 'fragment'\n        : 'compute';\n    const builtinVars = AST.builtinVariables['webgpu'];\n    const args: { name: string, type: PBPrimitiveTypeInfo | PBArrayTypeInfo | PBStructTypeInfo }[] = [];\n    const prefix: string[] = [];\n    for (const k in builtinVars) {\n      if (builtinVars[k].stage === stage && builtinVars[k].inOrOut === inOrOut) {\n        args.push({ name: builtinVars[k].name, type: builtinVars[k].type });\n        prefix.push(`@builtin(${builtinVars[k].semantic}) `);\n      }\n    }\n    const inoutList = inOrOut === 'in' ? this._inputs : this._outputs;\n    for (const k of inoutList) {\n      // for debug only\n      if (!(k[1] instanceof AST.ASTDeclareVar)) {\n        throw new errors.PBInternalError('defineBuiltinStruct() failed: input/output is not declare var ast node');\n      }\n      const type = k[1].value.getType();\n      if (!type.isPrimitiveType() && !type.isArrayType() && !type.isStructType()) {\n        throw new Error(`invalid in/out variable type: '${k[1].value.name}'`);\n      }\n      args.push({ name: k[1].value.name, type: type });\n      prefix.push(`@location(${k[1].value.value.$location}) `);\n    }\n    if (args.length > 0) {\n      const st = this.findStructType(structName, shaderType);\n      if (st) {\n        st.getType().reset(structName, 'default', args);\n        st.prefix = prefix;\n        return null;\n      } else {\n        const structType = this.internalDefineStructByType(this._shaderType, false, new PBStructTypeInfo(structName, 'default', args));\n        this.findStructType(structName, shaderType).prefix = prefix;\n        const structInstance = this.struct(structName, instanceName);\n        const structInstanceIN = inOrOut === 'in' ? this.struct(structName, 'ch_app_input') : structInstance;\n        return [structType, structInstance, structName, structInstanceIN];\n      }\n    } else {\n      return null;\n    }\n  }\n  /** @internal */\n  private defineInternalStructs() {\n    this.defineHiddenStruct(typeFrexpResult);\n    this.defineHiddenStruct(typeFrexpResultVec2);\n    this.defineHiddenStruct(typeFrexpResultVec3);\n    this.defineHiddenStruct(typeFrexpResultVec4);\n  }\n  /** @internal */\n  private array(...args: ExpValueNonArrayType[]) {\n    if (args.length === 0) {\n      throw new errors.PBParamLengthError('array');\n    }\n    args = args.map(arg => this.normalizeExpValue(arg));\n    let typeok = true;\n    let type: PBTypeInfo = null;\n    let isBool = true;\n    let isFloat = true;\n    let isInt = true;\n    let isUint = true;\n    let isComposite = false;\n    for (const arg of args) {\n      if (arg instanceof PBShaderExp) {\n        const argType = arg.$ast.getType();\n        if (!argType.isConstructible()) {\n          typeok = false;\n          break;\n        }\n        if (!type) {\n          type = argType;\n        } else if (argType.typeId !== type.typeId) {\n          typeok = false;\n        }\n      }\n    }\n    if (typeok) {\n      if (type && type.isPrimitiveType() && type.isScalarType()) {\n        isBool = type.primitiveType === PBPrimitiveType.BOOL;\n        isFloat = type.primitiveType === PBPrimitiveType.F32;\n        isUint = type.primitiveType === PBPrimitiveType.U32;\n        isInt = type.primitiveType === PBPrimitiveType.I32;\n      } else if (type) {\n        isBool = false;\n        isFloat = false;\n        isUint = false;\n        isInt = false;\n        isComposite = true;\n      }\n      for (const arg of args) {\n        if (!(arg instanceof PBShaderExp) && isComposite) {\n          typeok = false;\n          break;\n        }\n        if (typeof arg === 'number') {\n          isBool = false;\n          if ((arg | 0) === arg) {\n            if (arg < 0) {\n              isUint = false;\n              isInt = isInt && (arg >= (0x80000000 >> 0));\n            } else {\n              isUint = isUint && (arg <= 0xFFFFFFFF);\n              isInt = isInt && (arg <= 0x7FFFFFFF);\n            }\n          }\n        } else if (typeof arg === 'boolean') {\n          isFloat = false;\n          isInt = false;\n          isUint = false;\n        }\n      }\n    }\n    if (typeok && !isComposite) {\n      if (isBool) {\n        type = typeBool;\n      } else if (isInt) {\n        type = typeI32;\n      } else if (isUint) {\n        type = typeU32;\n      } else if (isFloat) {\n        type = typeF32;\n      }\n      typeok = !!type;\n    }\n    if (!typeok) {\n      throw new errors.PBParamTypeError('array');\n    }\n    if (!type.isPrimitiveType() && !type.isArrayType() && !type.isStructType()) {\n      throw new errors.PBParamTypeError('array');\n    }\n    const arrayType = new PBArrayTypeInfo(type, args.length);\n    const exp = new PBShaderExp('', arrayType);\n    exp.$ast = new AST.ASTShaderExpConstructor(arrayType, args.map(arg => {\n      if (arg instanceof PBShaderExp) {\n        return arg.$ast;\n      }\n      if (!type.isPrimitiveType() || !type.isScalarType()) {\n        throw new errors.PBTypeCastError(arg, typeof arg, type);\n      }\n      return new AST.ASTScalar(arg, type);\n    }));\n    return exp;\n  }\n  discard() {\n    this.currentScope().$ast.statements.push(new AST.ASTDiscard());\n  }\n  /** @internal */\n  tagShaderExp(getter: PBReflectionTagGetter, tagValue: ShaderExpTagValue) {\n    if (typeof tagValue === 'string') {\n      this._reflection.tag(tagValue, getter);\n    } else if (Array.isArray(tagValue)) {\n      tagValue.forEach(tag => this.tagShaderExp(getter, tag));\n    } else {\n      for (const k of Object.keys(tagValue)) {\n        this.tagShaderExp((scope: PBGlobalScope) => {\n          const value = getter(scope);\n          return value[k]\n        }, tagValue[k]);\n      }\n    }\n  }\n  /** @internal */\n  in(location: number, name: string, variable: PBShaderExp): void {\n    if (this._inputs[location]) {\n      throw new Error(`input location ${location} already declared`);\n    }\n    variable.$location = location;\n    variable.$declareType = AST.DeclareType.DECLARE_TYPE_IN;\n    variable.$inout = 'in';\n    this._inputs[location] = [name, new AST.ASTDeclareVar(new AST.ASTPrimitive(variable))];\n    Object.defineProperty(this._inputScope, name, {\n      get: function (this: PBInputScope) {\n        return variable;\n      },\n      set: function () {\n        throw new Error(`cannot assign to readonly variable: ${name}`);\n      }\n    });\n    variable.$tags.forEach(val => this.tagShaderExp(() => variable, val));\n  }\n  /** @internal */\n  out(location: number, name: string, variable: PBShaderExp): void {\n    if (this._outputs[location]) {\n      throw new Error(`output location ${location} has already been used`);\n    }\n    variable.$location = location;\n    variable.$declareType = AST.DeclareType.DECLARE_TYPE_OUT;\n    variable.$inout = 'out';\n    this._outputs[location] = [name, new AST.ASTDeclareVar(new AST.ASTPrimitive(variable))];\n    Object.defineProperty(this._outputScope, name, {\n      get: function (this: PBOutputScope) {\n        return variable;\n      },\n      set: function (this: PBOutputScope, v) {\n        getCurrentProgramBuilder().currentScope().$ast.statements.push(new AST.ASTAssignment(new AST.ASTLValueScalar(variable.$ast), v instanceof PBShaderExp ? v.$ast : v));\n      }\n    });\n  }\n  /** @internal */\n  getDefaultSampler(t: PBShaderExp, comparison: boolean): PBShaderExp {\n    const u = this._uniforms.findIndex(val => val.texture?.exp === t);\n    if (u < 0) {\n      throw new Error('invalid texture uniform object');\n    }\n    const samplerType = comparison ? 'comparison' : 'sample';\n    if (this._uniforms[u].texture.autoBindSampler && this._uniforms[u].texture.autoBindSampler !== samplerType) {\n      throw new Error('multiple sampler not supported');\n    }\n    this._uniforms[u].texture.autoBindSampler = samplerType;\n    if (this._deviceType === 'webgpu') {\n      const samplerName = AST.genSamplerName(t.$str, comparison);\n      if (!this.globalScope[samplerName]) {\n        throw new Error(`failed to find sampler name ${samplerName}`);\n      }\n      return this.globalScope[samplerName];\n    } else {\n      return null;\n    }\n  }\n  /** @internal */\n  normalizeExpValue(value: ExpValueType): ExpValueNonArrayType {\n    if (Array.isArray(value)) {\n      const converted = value.map(val => Array.isArray(val) ? this.normalizeExpValue(val) : val);\n      return this.array(...converted);\n    } else {\n      return value;\n    }\n  }\n  /** @internal */\n  guessExpValueType(value: ExpValueType): PBTypeInfo {\n    const val = this.normalizeExpValue(value);\n    if (typeof val === 'boolean') {\n      return typeBool;\n    } else if (typeof val === 'number') {\n      if (!Number.isInteger(val)) {\n        return typeF32;\n      } else if (val >= (0x80000000 >> 1) && val <= 0x7FFFFFFF) {\n        return typeI32;\n      } else if (val >= 0 && val <= 0xFFFFFFFF) {\n        return typeU32;\n      } else {\n        throw new errors.PBValueOutOfRange(val);\n      }\n    } else if (val instanceof PBShaderExp) {\n      return val.$ast?.getType() || val.$typeinfo;\n    }\n  }\n  /** @internal */\n  findStructType(name: string, shaderType: number): AST.ASTStructDefine {\n    for (const st of [ShaderType.Vertex, ShaderType.Fragment, ShaderType.Compute]) {\n      if (st & shaderType) {\n        const structInfo = this._structInfo[st];\n        if (structInfo) {\n          for (const t of structInfo.types) {\n            if (t.type.structName === name) {\n              return t;\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }\n  /** @internal */\n  findStructConstructor(name: string, shaderType: number): ShaderTypeFunc {\n    for (const st of [ShaderType.Vertex, ShaderType.Fragment, ShaderType.Compute]) {\n      if (st & shaderType) {\n        const structInfo = this._structInfo[st];\n        if (structInfo && structInfo.structs?.[name]) {\n          return structInfo.structs[name];\n        }\n      }\n    }\n    return null;\n  }\n  /** @internal */\n  private buildComputeSource(options: ProgramBuilder.ComputeOptions): ProgramBuilder.BuildComputeResult {\n    try {\n      this._lastError = null;\n      this._shaderType = ShaderType.Compute\n      this._scopeStack = [];\n      this._globalScope = new PBGlobalScope();\n      this._builtinScope = new PBBuiltinScope();\n      this._inputs = [];\n      this._outputs = [];\n      this._inputScope = new PBInputScope();\n      this._outputScope = new PBOutputScope();\n      this._reflection.clear();\n      this.generate(options.compute);\n      // this.removeUnusedSamplerBindings(this._globalScope);\n      this.mergeUniformsCompute(this._globalScope);\n      this.updateUniformBindings([this._globalScope], [ShaderType.Compute]);\n      return [\n        this.generateComputeSource(this._globalScope, this._builtinScope),\n        this.createBindGroupLayouts(options.label),\n      ];\n    } catch (err) {\n      if (err instanceof errors.PBError) {\n        this._lastError = err.getMessage(this.getDeviceType());\n        console.error(this._lastError);\n        return null;\n      } else if (err instanceof Error) {\n        this._lastError = err.toString();\n        console.error(this._lastError);\n        return null;\n      } else {\n        this._lastError = Object.prototype.toString.call(err);\n        console.log(`Error: ${this._lastError}`);\n        return null;\n      }\n    }\n  }\n  /** @internal */\n  private buildRenderSource(options: ProgramBuilder.RenderOptions): ProgramBuilder.BuildRenderResult {\n    try {\n      this._lastError = null;\n\n      this._shaderType = ShaderType.Vertex;\n      this._scopeStack = [];\n      this._globalScope = new PBGlobalScope();\n      this._builtinScope = new PBBuiltinScope();\n      this._inputs = [];\n      this._outputs = [];\n      this._inputScope = new PBInputScope();\n      this._outputScope = new PBOutputScope();\n      this._reflection.clear();\n      this.generate(options.vertex);\n      const vertexScope = this._globalScope;\n      const vertexBuiltinScope = this._builtinScope;\n      const vertexInputs = this._inputs;\n      const vertexOutputs = this._outputs;\n      if (this._deviceType === 'webgpu') {\n        // this.removeUnusedSamplerBindings(vertexScope);\n      }\n\n      this._shaderType = ShaderType.Fragment;\n      this._scopeStack = [];\n      this._globalScope = new PBGlobalScope();\n      this._builtinScope = new PBBuiltinScope();\n      this._inputs = [];\n      this._outputs = [];\n      this._inputScope = new PBInputScope();\n      this._outputScope = new PBOutputScope();\n      this._reflection.clear();\n      vertexOutputs.forEach((val, index) => {\n        this.in(index, val[0], new PBShaderExp(val[1].value.name, val[1].value.getType()).tag(...val[1].value.value.$tags));\n      });\n      this.generate(options.fragment);\n      const fragScope = this._globalScope;\n      const fragBuiltinScope = this._builtinScope;\n      const fragInputs = this._inputs;\n      const fragOutputs = this._outputs;\n      if (this._deviceType === 'webgpu') {\n        // this.removeUnusedSamplerBindings(fragScope);\n      }\n\n      this.mergeUniforms(vertexScope, fragScope);\n      this.updateUniformBindings([vertexScope, fragScope], [ShaderType.Vertex, ShaderType.Fragment]);\n\n      return [\n        this.generateRenderSource(ShaderType.Vertex, vertexScope, vertexBuiltinScope, vertexInputs.map(val => val[1]), vertexOutputs.map(val => val[1])),\n        this.generateRenderSource(ShaderType.Fragment, fragScope, fragBuiltinScope, fragInputs.map(val => val[1]), fragOutputs.map(val => val[1])),\n        this.createBindGroupLayouts(options.label),\n        this._vertexAttributes,\n      ];\n    } catch (err) {\n      if (err instanceof errors.PBError) {\n        this._lastError = err.getMessage(this.getDeviceType());\n        console.error(this._lastError);\n        return null;\n      } else if (err instanceof Error) {\n        this._lastError = err.toString();\n        console.error(this._lastError);\n        return null;\n      } else {\n        this._lastError = Object.prototype.toString.call(err);\n        console.log(`Error: ${this._lastError}`);\n        return null;\n      }\n    }\n  }\n  /** @internal */\n  private generate(\n    body?: (this: PBGlobalScope) => void,\n  ): void {\n    this.pushScope(this._globalScope);\n    if (this._emulateDepthClamp && this._shaderType === ShaderType.Vertex) {\n      this._globalScope.$outputs.clamppedDepth = this.float().tag('CLAMPPED_DEPTH');\n    }\n    body && body.call(this._globalScope);\n    this.popScope();\n  }\n  /** @internal */\n  private generateRenderSource(shaderType: ShaderType, scope: PBGlobalScope, builtinScope: PBBuiltinScope, inputs: AST.ShaderAST[], outputs: AST.ShaderAST[]) {\n    const context = {\n      type: shaderType,\n      mrt: shaderType === ShaderType.Fragment && outputs.length > 1,\n      defines: [],\n      extensions: new Set<string>(),\n      builtins: [...builtinScope.$_usedBuiltins],\n      types: this._structInfo[shaderType]?.types || [],\n      typeReplacement: new Map(),\n      inputs: inputs,\n      outputs: outputs,\n      global: scope,\n      vertexAttributes: this._vertexAttributes,\n      workgroupSize: null,\n    };\n    switch (this._deviceType) {\n      case 'webgl':\n        for (const u of this._uniforms) {\n          if (u.texture) {\n            const type = u.texture.exp.$ast.getType();\n            if (type.isTextureType() && type.isDepthTexture()) {\n              if (u.texture.autoBindSampler === 'comparison') {\n                throw new errors.PBDeviceNotSupport('depth texture comparison');\n              }\n              if (u.texture.autoBindSampler === 'sample') {\n                if (type.is2DTexture()) {\n                  context.typeReplacement.set(u.texture.exp, typeTex2D);\n                } else if (type.isCubeTexture()) {\n                  context.typeReplacement.set(u.texture.exp, typeTexCube);\n                }\n              }\n            }\n          }\n        }\n        return scope.$ast.toWebGL('', context);\n      case 'webgl2':\n        for (const u of this._uniforms) {\n          if (u.texture) {\n            const type = u.texture.exp.$ast.getType();\n            if (type.isTextureType() && type.isDepthTexture() && u.texture.autoBindSampler === 'sample') {\n              if (type.is2DTexture()) {\n                context.typeReplacement.set(u.texture.exp, typeTex2D);\n              } else if (type.isCubeTexture()) {\n                context.typeReplacement.set(u.texture.exp, typeTexCube);\n              }\n            }\n          }\n        }\n        return scope.$ast.toWebGL2('', context);\n      case 'webgpu':\n        return scope.$ast.toWGSL('', context);\n      default:\n        return null;\n    }\n  }\n  /** @internal */\n  private generateComputeSource(scope: PBGlobalScope, builtinScope: PBBuiltinScope) {\n    const context = {\n      type: ShaderType.Compute,\n      mrt: false,\n      defines: [],\n      extensions: new Set<string>(),\n      builtins: [...builtinScope.$_usedBuiltins],\n      types: this._structInfo[ShaderType.Compute]?.types || [],\n      typeReplacement: null,\n      inputs: [],\n      outputs: [],\n      global: scope,\n      vertexAttributes: [],\n      workgroupSize: this._workgroupSize,\n    };\n    return scope.$ast.toWGSL('', context);\n  }\n  /** @internal */\n  private mergeUniformsCompute(globalScope: PBGlobalScope) {\n    const uniformList: { members: PBShaderExp[], uniforms: number[] }[] = [];\n    for (let i = 0; i < this._uniforms.length; i++) {\n      const u = this._uniforms[i];\n      if (u.block && u.block.exp.$declareType === AST.DeclareType.DECLARE_TYPE_UNIFORM) {\n        const type = u.block.exp.$ast.getType();\n        if (type.isStructType() && type.detail.layout === 'std140') {\n          continue;\n        }\n        if (!uniformList[u.group]) {\n          uniformList[u.group] = { members: [], uniforms: [] };\n        }\n        uniformList[u.group].members.push(new PBShaderExp(u.block.exp.$str, u.block.exp.$ast.getType()));\n        uniformList[u.group].uniforms.push(i);\n      }\n    }\n    const uniformLists = [uniformList];\n    const nameList = [COMPUTE_UNIFORM_NAME];\n    const maskList = [ShaderType.Compute];\n    for (let i = 0; i < 1; i++) {\n      for (const k in uniformLists[i]) {\n        if (uniformLists[i][k]?.members.length > 0) {\n          const uname = `${nameList[i]}_${k}`;\n          const t = getCurrentProgramBuilder().internalDefineStruct(this.generateStructureName(), 'std140', maskList[i], false, ...uniformLists[i][k].members);\n          globalScope[uname] = t().uniform(Number(k));\n          const index = this._uniforms.findIndex(val => val.block?.name === uname);\n          this._uniforms[index].mask = maskList[i];\n          let nameMap = this._nameMap[Number(k)];\n          if (!nameMap) {\n            nameMap = {};\n            this._nameMap[Number(k)] = nameMap;\n          }\n          for (let j = uniformLists[i][k].uniforms.length - 1; j >= 0; j--) {\n            const u = uniformLists[i][k].uniforms[j];\n            const exp = this._uniforms[u].block.exp;\n            nameMap[exp.$str] = uname;\n            exp.$str = `${uname}.${exp.$str}`;\n          }\n        }\n      }\n    }\n    this._uniforms = this._uniforms.filter(val => {\n      if (!val.block || val.block.exp.$declareType !== AST.DeclareType.DECLARE_TYPE_UNIFORM) {\n        return true;\n      }\n      const type = val.block.exp.$ast.getType();\n      return type.isTextureType() || type.isSamplerType() || (type.isStructType() && type.detail.layout === 'std140');\n    });\n  }\n  /** @internal */\n  private mergeUniforms(globalScopeVertex: PBGlobalScope, globalScopeFragmet: PBGlobalScope) {\n    const vertexUniformList: { members: PBShaderExp[], uniforms: number[] }[] = [];\n    const fragUniformList: { members: PBShaderExp[], uniforms: number[] }[] = [];\n    const sharedUniformList: { members: PBShaderExp[], uniforms: number[] }[] = [];\n    for (let i = 0; i < this._uniforms.length; i++) {\n      const u = this._uniforms[i];\n      if (u.block && u.block.exp.$declareType === AST.DeclareType.DECLARE_TYPE_UNIFORM) {\n        const type = u.block.exp.$ast.getType();\n        if (type.isStructType() && type.detail.layout === 'std140') {\n          continue;\n        }\n        const v = !!(u.mask & ShaderType.Vertex);\n        const f = !!(u.mask & ShaderType.Fragment);\n        if (v && f) {\n          if (!sharedUniformList[u.group]) {\n            sharedUniformList[u.group] = { members: [], uniforms: [] };\n          }\n          sharedUniformList[u.group].members.push(new PBShaderExp(u.block.exp.$str, u.block.exp.$ast.getType()));\n          sharedUniformList[u.group].uniforms.push(i);\n        } else if (v) {\n          if (!vertexUniformList[u.group]) {\n            vertexUniformList[u.group] = { members: [], uniforms: [] };\n          }\n          vertexUniformList[u.group].members.push(new PBShaderExp(u.block.exp.$str, u.block.exp.$ast.getType()));\n          vertexUniformList[u.group].uniforms.push(i);\n        } else if (f) {\n          if (!fragUniformList[u.group]) {\n            fragUniformList[u.group] = { members: [], uniforms: [] };\n          }\n          fragUniformList[u.group].members.push(new PBShaderExp(u.block.exp.$str, u.block.exp.$ast.getType()));\n          fragUniformList[u.group].uniforms.push(i);\n        }\n      }\n    }\n    const uniformLists = [vertexUniformList, fragUniformList, sharedUniformList];\n    const nameList = [VERTEX_UNIFORM_NAME, FRAGMENT_UNIFORM_NAME, SHARED_UNIFORM_NAME];\n    const maskList = [ShaderType.Vertex, ShaderType.Fragment, ShaderType.Vertex | ShaderType.Fragment];\n    for (let i = 0; i < 3; i++) {\n      for (const k in uniformLists[i]) {\n        if (uniformLists[i][k]?.members.length > 0) {\n          const uname = `${nameList[i]}_${k}`;\n          const structName = this.generateStructureName();\n          const t = getCurrentProgramBuilder().internalDefineStruct(structName, 'std140', maskList[i], false, ...uniformLists[i][k].members);\n          if (maskList[i] & ShaderType.Vertex) {\n            globalScopeVertex[uname] = t().uniform(Number(k));\n          }\n          if (maskList[i] & ShaderType.Fragment) {\n            globalScopeFragmet[uname] = t().uniform(Number(k));\n          }\n          const index = this._uniforms.findIndex(val => val.block?.name === uname);\n          this._uniforms[index].mask = maskList[i];\n          let nameMap = this._nameMap[Number(k)];\n          if (!nameMap) {\n            nameMap = {};\n            this._nameMap[Number(k)] = nameMap;\n          }\n          for (let j = uniformLists[i][k].uniforms.length - 1; j >= 0; j--) {\n            const u = uniformLists[i][k].uniforms[j];\n            const exp = this._uniforms[u].block.exp;\n            nameMap[exp.$str] = uname;\n            exp.$str = `${uname}.${exp.$str}`;\n          }\n        }\n      }\n    }\n    this._uniforms = this._uniforms.filter(val => {\n      if (!val.block || val.block.exp.$declareType !== AST.DeclareType.DECLARE_TYPE_UNIFORM) {\n        return true;\n      }\n      const type = val.block.exp.$ast.getType();\n      return type.isTextureType() || type.isSamplerType() || (type.isStructType() && type.detail.layout === 'std140');\n    });\n  }\n  /** @internal */\n  private updateUniformBindings(scopes: PBGlobalScope[], shaderTypes: ShaderType[]) {\n    this._uniforms = this._uniforms.filter(val => !!val.mask);\n    const bindings: number[] = Array.from<number>({ length: MAX_BINDING_GROUPS }).fill(0);\n    for (const u of this._uniforms) {\n      u.binding = bindings[u.group]++;\n    }\n    for (let i = 0; i < scopes.length; i++) {\n      const scope = scopes[i];\n      const type = shaderTypes[i];\n      for (const u of this._uniforms) {\n        if (u.mask & type) {\n          const uniforms = (scope.$ast as AST.ASTGlobalScope).uniforms;\n          const name = u.block ? u.block.name : u.texture ? u.texture.exp.$str : u.sampler.$str;\n          const index = uniforms.findIndex(val => val.value.name === name);\n          if (index < 0) {\n            throw new Error(`updateUniformBindings() failed: unable to find uniform ${name}`);\n          }\n          (uniforms[index] as AST.ASTDeclareVar).binding = u.binding;\n        }\n      }\n    }\n  }\n  /** @internal */\n  private createBindGroupLayouts(label: string): BindGroupLayout[] {\n    const layouts: BindGroupLayout[] = [];\n    for (const uniformInfo of this._uniforms) {\n      let layout = layouts[uniformInfo.group];\n      if (!layout) {\n        layout = {\n          label: `${label || 'unknown'}[${uniformInfo.group}]`,\n          entries: []\n        };\n        if (this._nameMap[uniformInfo.group]) {\n          layout.nameMap = this._nameMap[uniformInfo.group];\n        }\n        layouts[uniformInfo.group] = layout;\n      }\n      const entry: BindGroupLayoutEntry = {\n        binding: uniformInfo.binding,\n        visibility: uniformInfo.mask,\n        type: null,\n        name: '',\n      };\n      if (uniformInfo.block) {\n        entry.type = (uniformInfo.block.exp.$typeinfo as PBStructTypeInfo).clone(this.getBlockName(uniformInfo.block.name));\n        entry.buffer = {\n          type: uniformInfo.block.exp.$declareType === AST.DeclareType.DECLARE_TYPE_UNIFORM\n            ? 'uniform'\n            : (uniformInfo.block.exp.$ast as AST.ASTPrimitive).writable ? 'storage' : 'read-only-storage',\n          hasDynamicOffset: uniformInfo.block.dynamicOffset,\n          uniformLayout: entry.type.toBufferLayout(0, (entry.type as PBStructTypeInfo).layout),\n        };\n        entry.name = uniformInfo.block.name;\n      } else if (uniformInfo.texture) {\n        entry.type = uniformInfo.texture.exp.$typeinfo;\n        if (!entry.type.isTextureType()) {\n          throw new Error('internal error');\n        }\n        if (entry.type.isStorageTexture()) {\n          entry.storageTexture = {\n            access: 'write-only',\n            viewDimension: entry.type.is1DTexture() ? '1d' : '2d',\n            format: entry.type.storageTexelFormat,\n          };\n        } else if (entry.type.isExternalTexture()) {\n          entry.externalTexture = {\n            autoBindSampler: uniformInfo.texture.autoBindSampler ? AST.genSamplerName(uniformInfo.texture.exp.$str, false) : null,\n          };\n        } else {\n          const sampleType = this._deviceType === 'webgpu' ? uniformInfo.texture.exp.$sampleType : (uniformInfo.texture.autoBindSampler && entry.type.isDepthTexture()) ? 'float' : uniformInfo.texture.exp.$sampleType;\n          let viewDimension: typeof entry.texture.viewDimension;\n          if (entry.type.isArrayTexture()) {\n            viewDimension = entry.type.isCubeTexture() ? 'cube-array' : '2d-array';\n          } else if (entry.type.is3DTexture()) {\n            viewDimension = '3d';\n          } else if (entry.type.isCubeTexture()) {\n            viewDimension = 'cube';\n          } else if (entry.type.is1DTexture()) {\n            viewDimension = '1d';\n          } else {\n            viewDimension = '2d';\n          }\n          entry.texture = {\n            sampleType: sampleType,\n            viewDimension: viewDimension,\n            multisampled: false,\n            autoBindSampler: null,\n            autoBindSamplerComparison: null,\n          };\n          if (this.getDeviceType() === 'webgpu' || uniformInfo.texture.autoBindSampler === 'sample') {\n            entry.texture.autoBindSampler = AST.genSamplerName(uniformInfo.texture.exp.$str, false);\n          }\n          if ((this.getDeviceType() === 'webgpu' && entry.type.isDepthTexture()) || uniformInfo.texture.autoBindSampler === 'comparison') {\n            entry.texture.autoBindSamplerComparison = AST.genSamplerName(uniformInfo.texture.exp.$str, true);\n          }\n        }\n        entry.name = uniformInfo.texture.exp.$str;\n      } else if (uniformInfo.sampler) {\n        entry.type = uniformInfo.sampler.$typeinfo;\n        if (!entry.type.isSamplerType()) {\n          throw new Error('internal error');\n        }\n        entry.sampler = {\n          type: (entry.type.accessMode === PBSamplerAccessMode.SAMPLE)\n            ? uniformInfo.sampler.$sampleType === 'float' ? 'filtering' : 'non-filtering'\n            : 'comparison'\n        };\n        entry.name = uniformInfo.sampler.$str;\n      } else {\n        throw new errors.PBInternalError('invalid uniform entry type');\n      }\n      layout.entries.push(entry);\n    }\n    for (let i = 0; i < layouts.length; i++) {\n      if (!layouts[i]) {\n        layouts[i] = {\n          label: `${label || 'unknown'}[${i}]`,\n          entries: []\n        };\n      }\n    }\n    return layouts;\n  }\n  /** @internal */\n  _getFunctionOverload(funcName: string, args: ExpValueNonArrayType[]): [PBFunctionTypeInfo, AST.ASTExpression[]] {\n    const thisArgs = args.filter(val => {\n      if (val instanceof PBShaderExp) {\n        const type = val.$ast.getType();\n        if (type.isStructType()\n          && (this._structInfo[this._shaderType]?.types.findIndex(t => t.type.structName === type.structName) < 0)) {\n          return false;\n        }\n      }\n      return true;\n    });\n    const fn = this.globalScope.$getFunction(funcName);\n    return fn ? this._matchFunctionOverloading(fn.overloads, thisArgs) : null;\n  }\n  /** @internal */\n  _matchFunctionOverloading(overloadings: PBFunctionTypeInfo[], args: ExpValueNonArrayType[]): [PBFunctionTypeInfo, AST.ASTExpression[]] {\n    for (const overload of overloadings) {\n      if (args.length !== overload.argTypes.length) {\n        continue;\n      }\n      const result: AST.ASTExpression[] = [];\n      let matches = true;\n      for (let i = 0; i < args.length; i++) {\n        const argType = overload.argTypes[i].type;\n        const arg = args[i];\n        if (typeof arg === 'boolean') {\n          if (!argType.isPrimitiveType() || argType.primitiveType !== PBPrimitiveType.BOOL) {\n            matches = false;\n            break;\n          }\n          result.push(new AST.ASTScalar(arg, typeBool));\n        } else if (typeof arg === 'number') {\n          if (!argType.isPrimitiveType() || !argType.isScalarType() || argType.scalarType === PBPrimitiveType.BOOL) {\n            matches = false;\n            break;\n          }\n          if (argType.scalarType === PBPrimitiveType.I32) {\n            if (!Number.isInteger(arg) || arg < (0x80000000 >> 0) || arg > 0x7FFFFFFF) {\n              matches = false;\n              break;\n            }\n            result.push(new AST.ASTScalar(arg, typeI32));\n          } else if (argType.scalarType === PBPrimitiveType.U32) {\n            if (!Number.isInteger(arg) || arg < 0 || arg > 0xFFFFFFFF) {\n              matches = false;\n              break;\n            }\n            result.push(new AST.ASTScalar(arg, typeU32));\n          } else {\n            result.push(new AST.ASTScalar(arg, argType));\n          }\n        } else {\n          if (argType.typeId !== arg.$ast.getType().typeId) {\n            matches = false;\n            break;\n          }\n          result.push(arg.$ast);\n        }\n      }\n      if (matches) {\n        return [overload, result];\n      }\n    }\n    return null;\n  }\n  /** @internal */\n  $callFunction(funcName: string, args: AST.ASTExpression[], returnType: PBTypeInfo): PBShaderExp {\n    if (this.currentScope() === this.globalScope) {\n      throw new errors.PBNonScopedFunctionCall(funcName);\n    }\n    const func = this.getFunction(funcName) || null;\n    const exp = new PBShaderExp('', returnType);\n    exp.$ast = new AST.ASTCallFunction(funcName, args, returnType, func, getCurrentProgramBuilder().getDeviceType());\n    this.currentScope().$ast.statements.push(exp.$ast);\n    return exp;\n  }\n}\n\nabstract class Proxiable<T> {\n  /** @internal */\n  private proxy: Proxiable<T>;\n  constructor() {\n    this.proxy = new Proxy(this, {\n      get: function (target, prop) {\n        return typeof prop === 'string' ? target.$get(prop) : undefined;\n      },\n      set: function (target, prop, value) {\n        return typeof prop === 'string' ? target.$set(prop, value) : false;\n      }\n    }) as Proxiable<T>;\n    return this.proxy;\n  }\n  get $thisProxy(): T {\n    return this.proxy as unknown as T;\n  }\n  /** @internal */\n  protected abstract $get(prop: string): any;\n  /** @internal */\n  protected abstract $set(prop: string, value: any): boolean;\n}\n\nexport class PBScope extends Proxiable<PBScope> {\n  /** @internal */\n  protected $_variables: { [name: string]: PBShaderExp };\n  /** @internal */\n  protected $_parentScope: PBScope;\n  /** @internal */\n  protected $_AST: AST.ASTScope;\n  /** @internal */\n  protected $_localScope: PBLocalScope;\n  [props: string]: any;\n  /** @internal */\n  constructor(astScope: AST.ASTScope, parent?: PBScope) {\n    super();\n    this.$_parentScope = parent || null;\n    this.$_variables = {};\n    this.$_AST = astScope;\n    this.$_localScope = null;\n  }\n  get $builder(): ProgramBuilder {\n    return getCurrentProgramBuilder();\n  }\n  get $builtins(): PBBuiltinScope {\n    return getCurrentProgramBuilder().builtinScope;\n  }\n  get $inputs(): PBInputScope {\n    return getCurrentProgramBuilder().inputScope;\n  }\n  get $outputs(): PBOutputScope {\n    return getCurrentProgramBuilder().outputScope;\n  }\n  /** @internal */\n  get $parent(): PBScope {\n    return this.$_parentScope;\n  }\n  /** @internal */\n  get $ast(): AST.ASTScope {\n    return this.$_AST;\n  }\n  /** @internal */\n  set $ast(ast: AST.ASTScope) {\n    this.$_AST = ast;\n  }\n  $getVertexAttrib(loc: number): PBShaderExp {\n    return getCurrentProgramBuilder().reflection.attribute(loc);\n  }\n  get $l(): PBLocalScope {\n    return this.$_getLocalScope();\n  }\n  get $g(): PBGlobalScope {\n    return this.$_getGlobalScope();\n  }\n  $local(variable: PBShaderExp, init?: ExpValueType): void {\n    const initNonArray = getCurrentProgramBuilder().normalizeExpValue(init);\n    variable.$global = this instanceof PBGlobalScope;\n    this.$_declare(variable, initNonArray);\n  }\n  $touch(exp: PBShaderExp): void {\n    this.$ast.statements.push(new AST.ASTTouch(exp.$ast));\n  }\n  $query(name: string): PBShaderExp {\n    return getCurrentProgramBuilder().queryGlobal(name);\n  }\n  /** @internal */\n  $_declareInternal(variable: PBShaderExp, init?: ExpValueNonArrayType): AST.ShaderAST {\n    const key = variable.$str;\n    if (this.$_variables[key]) {\n      throw new Error(`cannot re-declare variable '${key}'`);\n    }\n    if (!(variable.$ast instanceof AST.ASTPrimitive)) {\n      throw new Error(`invalid variable declaration: '${variable.$ast.toString(getCurrentProgramBuilder().getDeviceType())}'`);\n    }\n    const varType = variable.$typeinfo;\n    if (varType.isPointerType()) {\n      if (!init) {\n        throw new Error(`cannot declare pointer type variable without initialization: '${variable.$str}'`);\n      }\n      if (!(init instanceof PBShaderExp)) {\n        throw new Error(`invalid initialization for pointer type declaration: '${variable.$str}`);\n      }\n      const initType = init.$ast.getType();\n      if (!initType.isPointerType() || varType.pointerType.typeId !== initType.pointerType.typeId) {\n        throw new Error(`incompatible pointer type assignment: '${variable.$str}'`);\n      }\n      variable.$typeinfo = initType;\n    }\n    this.$_registerVar(variable, key);\n    if (init === undefined || init === null) {\n      return new AST.ASTDeclareVar(variable.$ast as AST.ASTPrimitive);\n    } else {\n      if (init instanceof PBShaderExp && init.$ast instanceof AST.ASTShaderExpConstructor && init.$ast.args.length === 0) {\n        if (init.$ast.getType().typeId !== variable.$ast.getType().typeId) {\n          throw new errors.PBTypeCastError(init, init.$ast.getType(), variable.$ast.getType());\n        }\n        return new AST.ASTDeclareVar(variable.$ast as AST.ASTPrimitive);\n      } else {\n        return new AST.ASTAssignment(new AST.ASTLValueDeclare(variable.$ast as AST.ASTPrimitive), init instanceof PBShaderExp ? init.$ast : init);\n      }\n    }\n  }\n  /** @internal */\n  $_findOrSetUniform(variable: PBShaderExp): PBShaderExp {\n    const name = variable.$str;\n    const uniformInfo: UniformInfo = {\n      group: variable.$group,\n      binding: 0,\n      mask: 0,\n    };\n    if (variable.$typeinfo.isTextureType()) {\n      uniformInfo.texture = {\n        autoBindSampler: null,\n        exp: variable,\n      };\n    } else if (variable.$typeinfo.isSamplerType()) {\n      uniformInfo.sampler = variable;\n    } else {\n      uniformInfo.block = {\n        name: name,\n        dynamicOffset: false,\n        exp: variable,\n      };\n      // throw new Error(`unsupported uniform type: ${name}`);\n    }\n    let found = false;\n    for (const u of getCurrentProgramBuilder()._uniforms) {\n      if (u.group !== uniformInfo.group) {\n        continue;\n      }\n      if (uniformInfo.block && u.block && u.block.name === uniformInfo.block.name && u.block.exp.$typeinfo.typeId === uniformInfo.block.exp.$typeinfo.typeId) {\n        u.mask |= getCurrentProgramBuilder().shaderType;\n        variable = u.block.exp;\n        // u.block.exp = variable;\n        found = true;\n        break;\n      }\n      if (uniformInfo.texture && u.texture && uniformInfo.texture.exp.$str === u.texture.exp.$str && uniformInfo.texture.exp.$typeinfo.typeId === u.texture.exp.$typeinfo.typeId) {\n        u.mask |= getCurrentProgramBuilder().shaderType;\n        variable = u.texture.exp;\n        // u.texture.exp = variable;\n        found = true;\n        break;\n      }\n      if (uniformInfo.sampler && u.sampler && uniformInfo.sampler.$str === u.sampler.$str && uniformInfo.sampler.$typeinfo.typeId === u.sampler.$typeinfo.typeId) {\n        u.mask |= getCurrentProgramBuilder().shaderType;\n        variable = u.sampler;\n        // u.sampler = variable;\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      uniformInfo.mask = getCurrentProgramBuilder().shaderType;\n      getCurrentProgramBuilder()._uniforms.push(uniformInfo);\n    }\n    if (uniformInfo.texture\n      && !(uniformInfo.texture.exp.$typeinfo as PBTextureTypeInfo).isStorageTexture()\n      && !(uniformInfo.texture.exp.$typeinfo as PBTextureTypeInfo).isExternalTexture()\n      && getCurrentProgramBuilder().getDeviceType() === 'webgpu') {\n      // webgpu requires explicit sampler bindings\n      const isDepth = variable.$typeinfo.isTextureType() && variable.$typeinfo.isDepthTexture();\n      const samplerName = AST.genSamplerName(variable.$str, false);\n      const samplerExp = getCurrentProgramBuilder().sampler(samplerName).uniform(uniformInfo.group).sampleType(variable.$sampleType);\n      samplerExp.$sampleType = variable.$sampleType;\n      this.$local(samplerExp);\n      if (isDepth) {\n        const samplerNameComp = AST.genSamplerName(variable.$str, true);\n        const samplerExpComp = getCurrentProgramBuilder().samplerComparison(samplerNameComp).uniform(uniformInfo.group).sampleType(variable.$sampleType);\n        this.$local(samplerExpComp);\n      }\n    }\n    return variable;\n  }\n  /** @internal */\n  $_declare(variable: PBShaderExp, init?: ExpValueNonArrayType): void {\n    if (this.$_variables[variable.$str]) {\n      throw new errors.PBASTError(variable.$ast, 'cannot re-declare variable');\n    }\n    if (variable.$declareType === AST.DeclareType.DECLARE_TYPE_UNIFORM || variable.$declareType === AST.DeclareType.DECLARE_TYPE_STORAGE) {\n      const name = (variable.$ast as AST.ASTPrimitive).name;\n      if (!(this instanceof PBGlobalScope)) {\n        throw new Error(`uniform or storage variables can only be declared within global scope: ${name}`);\n      }\n      if (variable.$declareType === AST.DeclareType.DECLARE_TYPE_UNIFORM\n        && !variable.$typeinfo.isTextureType()\n        && !variable.$typeinfo.isSamplerType()\n        && (!variable.$typeinfo.isConstructible() || !variable.$typeinfo.isHostSharable())) {\n        throw new errors.PBASTError(variable.$ast, `type '${variable.$typeinfo.toTypeName(getCurrentProgramBuilder().getDeviceType())}' cannot be declared in uniform address space`);\n      }\n      if (variable.$declareType === AST.DeclareType.DECLARE_TYPE_STORAGE) {\n        if (getCurrentProgramBuilder().getDeviceType() !== 'webgpu') {\n          throw new errors.PBDeviceNotSupport('storage buffer binding');\n        } else if (!variable.$typeinfo.isHostSharable()) {\n          throw new errors.PBASTError(variable.$ast, `type '${variable.$typeinfo.toTypeName(getCurrentProgramBuilder().getDeviceType())}' cannot be declared in storage address space`);\n        }\n      }\n      let originalType: PBPrimitiveTypeInfo | PBArrayTypeInfo = null;\n      if (variable.$declareType === AST.DeclareType.DECLARE_TYPE_STORAGE && (variable.$typeinfo.isPrimitiveType() || variable.$typeinfo.isArrayType())) {\n        originalType = variable.$typeinfo as PBPrimitiveTypeInfo | PBArrayTypeInfo;\n        const wrappedStruct = getCurrentProgramBuilder().defineStruct(null, 'default', new PBShaderExp('value', originalType));\n        variable.$typeinfo = wrappedStruct().$typeinfo;\n      }\n      variable = this.$_findOrSetUniform(variable);\n      const ast = this.$_declareInternal(variable) as AST.ASTDeclareVar;\n      if (originalType) {\n        variable.$ast = new AST.ASTHash(variable.$ast, 'value', originalType);\n      }\n      ast.group = variable.$group;\n      ast.binding = 0;\n      ast.blockName = getCurrentProgramBuilder().getBlockName(name);\n      const type = variable.$typeinfo;\n      if (type.isTextureType() || type.isSamplerType() || variable.$declareType === AST.DeclareType.DECLARE_TYPE_STORAGE || (type.isStructType() && type.detail.layout === 'std140')) {\n        (this.$ast as AST.ASTGlobalScope).uniforms.push(ast);\n      }\n      variable.$tags.forEach(val => {\n        getCurrentProgramBuilder().tagShaderExp(() => variable, val);\n      });\n    } else {\n      const ast = this.$_declareInternal(variable, init);\n      this.$ast.statements.push(ast);\n    }\n  }\n  /** @internal */\n  $_registerVar(variable: PBShaderExp, name?: string) {\n    const key = name || variable.$str;\n    const options: any = {\n      configurable: true,\n      get: function (this: PBScope) {\n        return variable;\n      },\n      set: function (this: PBScope, val: number | PBShaderExp) {\n        getCurrentProgramBuilder().currentScope().$ast.statements.push(new AST.ASTAssignment(new AST.ASTLValueScalar(variable.$ast), val instanceof PBShaderExp ? val.$ast : val));\n      },\n    };\n    Object.defineProperty(this, key, options);\n    this.$_variables[key] = variable;\n  }\n  /** @internal */\n  $localGet(prop: string): any {\n    if (typeof prop === 'string' && (prop[0] === '$' || prop in this)) {\n      return this[prop];\n    }\n    return undefined;\n  }\n  /** @internal */\n  $localSet(prop: string, value: any): boolean {\n    if (prop[0] === '$' || prop in this) {\n      this[prop] = value;\n      return true;\n    }\n    return false;\n  }\n  /** @internal */\n  protected $get(prop: string): any {\n    const ret = this.$localGet(prop);\n    return ret === undefined && this.$_parentScope ? this.$_parentScope.$thisProxy.$get(prop) : ret;\n  }\n  /** @internal */\n  protected $set(prop: string, value: any): boolean {\n    if (prop[0] === '$') {\n      this[prop] = value;\n      return true;\n    } else {\n      let scope: PBScope = this;\n      while (scope && !(prop in scope)) {\n        scope = scope.$_parentScope;\n      }\n      if (scope) {\n        scope[prop] = value;\n        return true;\n      } else {\n        if (this.$l) {\n          this.$l[prop] = value;\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /** @internal */\n  protected $_getLocalScope(): PBLocalScope {\n    if (!this.$_localScope) {\n      this.$_localScope = new PBLocalScope(this);\n    }\n    return this.$_localScope;\n  }\n  /** @internal */\n  protected $_getGlobalScope(): PBGlobalScope {\n    return this.$builder.globalScope;\n  }\n}\n\nexport class PBLocalScope extends PBScope {\n  /** @internal */\n  $_scope: PBScope;\n  [props: string]: any;\n  constructor(scope: PBScope) {\n    super(null, null);\n    this.$_scope = scope;\n  }\n  /** @internal */\n  protected $get(prop: string): any {\n    return prop[0] === '$' ? this[prop] : this.$_scope.$localGet(prop);\n  }\n  /** @internal */\n  protected $set(prop: string, value: any): boolean {\n    if (prop[0] === '$') {\n      this[prop] = value;\n      return true;\n    }\n    const val = this.$_scope.$localGet(prop);\n    if (val === undefined) {\n      const type = getCurrentProgramBuilder().guessExpValueType(value);\n      const exp = new PBShaderExp(prop, type);\n      if (value instanceof PBShaderExp && !this.$_scope.$parent) {\n        exp.$declareType = value.$declareType;\n        exp.$group = value.$group;\n        exp.$attrib = value.$attrib;\n        exp.$sampleType = value.$sampleType;\n        exp.$precision = value.$precision;\n        exp.tag(...value.$tags);\n      }\n      this.$_scope.$local(exp, value);\n      return true;\n    } else {\n      return this.$_scope.$localSet(prop, value);\n    }\n  }\n  /** @internal */\n  $_getLocalScope(): PBLocalScope {\n    return this;\n  }\n}\n\nexport interface PBBuiltinScope {\n  position: PBShaderExp;\n  pointSize: PBShaderExp;\n  fragDepth: PBShaderExp;\n  readonly fragCoord: PBShaderExp;\n  readonly frontFacing: PBShaderExp;\n  readonly vertexIndex: PBShaderExp;\n  readonly instanceIndex: PBShaderExp;\n  readonly localInvocationId: PBShaderExp;\n  readonly globalInvocationId: PBShaderExp;\n  readonly workGroupId: PBShaderExp;\n  readonly numWorkGroups: PBShaderExp;\n  readonly sampleMaskIn: PBShaderExp;\n  sampleMaskOut: PBShaderExp;\n  readonly sampleIndex: PBShaderExp;\n}\n\nexport class PBBuiltinScope extends PBScope {\n  /** @internal */\n  $_usedBuiltins: Set<string>;\n  /** @internal */\n  $_builtinVars: { [k: string]: PBShaderExp };\n  constructor() {\n    super(null);\n    this.$_usedBuiltins = new Set();\n    const isWebGPU = getCurrentProgramBuilder().getDeviceType() === 'webgpu';\n    if (!isWebGPU) {\n      this.$_builtinVars = {};\n      const v = AST.builtinVariables[getCurrentProgramBuilder().getDeviceType()];\n      for (const k in v) {\n        const info = v[k];\n        this.$_builtinVars[k] = new PBShaderExp(info.name, info.type);\n      }\n    }\n    const v = AST.builtinVariables[getCurrentProgramBuilder().getDeviceType()];\n    const that = this;\n    for (const k of Object.keys(v)) {\n      Object.defineProperty(this, k, {\n        get: function () {\n          return that.$getBuiltinVar(k);\n        },\n        set: function (v) {\n          if ((typeof v !== 'number') && !(v instanceof PBShaderExp)) {\n            throw new Error(`Invalid output value assignment`);\n          }\n          const exp = that.$getBuiltinVar(k);\n          getCurrentProgramBuilder().currentScope().$ast.statements.push(new AST.ASTAssignment(new AST.ASTLValueScalar(exp.$ast), v instanceof PBShaderExp ? v.$ast : v));\n        },\n      });\n    }\n  }\n  /** @internal */\n  protected $_getLocalScope(): PBLocalScope {\n    return null;\n  }\n  /** @internal */\n  private $getBuiltinVar(name: string) {\n    this.$_usedBuiltins.add(name);\n    const isWebGPU = getCurrentProgramBuilder().getDeviceType() === 'webgpu';\n    if (isWebGPU) {\n      const v = AST.builtinVariables[getCurrentProgramBuilder().getDeviceType()];\n      const info = v[name];\n      const inout = info.inOrOut;\n      const structName = inout === 'in' ? AST.getBuiltinInputStructInstanceName(getCurrentProgramBuilder().shaderType) : AST.getBuiltinOutputStructInstanceName(getCurrentProgramBuilder().shaderType);\n      const scope = getCurrentProgramBuilder().currentScope();\n      if (!scope[structName] || !scope[structName][info.name]) {\n        throw new Error(`invalid use of builtin variable ${name}`);\n      }\n      return scope[structName][info.name];\n    } else {\n      return this.$_builtinVars[name];\n    }\n  }\n}\n\nexport class PBInputScope extends PBScope {\n  constructor() {\n    super(null);\n  }\n  /** @internal */\n  protected $_getLocalScope(): PBLocalScope {\n    return null;\n  }\n  /** @internal */\n  protected $set(prop: string, value: any): boolean {\n    if (prop[0] === '$') {\n      this[prop] = value;\n    } else if (prop in this) {\n      throw new Error(`Can not assign to shader input variable: \"${prop}\"`);\n    } else {\n      const st = getCurrentProgramBuilder().shaderType;\n      if (st !== ShaderType.Vertex) {\n        throw new Error(`shader input variables can only be declared in vertex shader: \"${prop}\"`);\n      }\n      const attrib = getVertexAttribByName(value.$attrib);\n      if (attrib === undefined) {\n        throw new Error(`can not declare shader input variable: invalid vertex attribute: \"${prop}\"`);\n      }\n      if (getCurrentProgramBuilder()._vertexAttributes.indexOf(attrib) >= 0) {\n        throw new Error(`can not declare shader input variable: attribute already declared: \"${prop}\"`);\n      }\n      if (!(value instanceof PBShaderExp) || !(value.$ast instanceof AST.ASTShaderExpConstructor)) {\n        throw new Error(`invalid shader input variable declaration: \"${prop}\"`);\n      }\n      const type = value.$ast.getType();\n      if (!type.isPrimitiveType() || type.isMatrixType() || type.primitiveType === PBPrimitiveType.BOOL) {\n        throw new Error(`type cannot be used as pipeline input/output: ${prop}`);\n      }\n      const location = getCurrentProgramBuilder()._inputs.length;\n      const exp = new PBShaderExp(`${input_prefix}${prop}`, type).tag(...value.$tags);\n      getCurrentProgramBuilder().in(location, prop, exp);\n      getCurrentProgramBuilder()._vertexAttributes.push(attrib);\n      getCurrentProgramBuilder().reflection.setAttrib(attrib, exp);\n      // modify input struct for webgpu\n      if (getCurrentProgramBuilder().getDeviceType() === 'webgpu') {\n        if (getCurrentProgramBuilder().findStructType(AST.getBuiltinInputStructName(st), st)) {\n          getCurrentProgramBuilder().defineBuiltinStruct(st, 'in');\n        }\n      }\n    }\n    return true;\n  }\n}\n\nexport class PBOutputScope extends PBScope {\n  constructor() {\n    super(null);\n  }\n  /** @internal */\n  protected $_getLocalScope(): PBLocalScope {\n    return null;\n  }\n  /** @internal */\n  protected $set(prop: string, value: any): boolean {\n    if (prop[0] === '$'/* || prop in this*/) {\n      this[prop] = value;\n    } else {\n      if (!(prop in this)) {\n        if (getCurrentProgramBuilder().currentScope() === getCurrentProgramBuilder().globalScope\n          && (!(value instanceof PBShaderExp) || !(value.$ast instanceof AST.ASTShaderExpConstructor))) {\n          throw new Error(`invalid shader output variable declaration: ${prop}`);\n        }\n        const type = value.$ast.getType();\n        if (!type.isPrimitiveType() || type.isMatrixType() || type.primitiveType === PBPrimitiveType.BOOL) {\n          throw new Error(`type cannot be used as pipeline input/output: ${prop}`);\n        }\n        const location = getCurrentProgramBuilder()._outputs.length;\n        getCurrentProgramBuilder().out(location, prop, new PBShaderExp(`${output_prefix}${prop}`, type).tag(...value.$tags));\n        // modify output struct for webgpu\n        if (getCurrentProgramBuilder().getDeviceType() === 'webgpu') {\n          const st = getCurrentProgramBuilder().shaderType;\n          if (getCurrentProgramBuilder().findStructType(AST.getBuiltinInputStructName(st), st)) {\n            getCurrentProgramBuilder().defineBuiltinStruct(st, 'out');\n          }\n        }\n      }\n      if (getCurrentProgramBuilder().currentScope() !== getCurrentProgramBuilder().globalScope) {\n        this[prop] = value;\n      }\n    }\n    return true;\n  }\n}\n\nexport class PBGlobalScope extends PBScope {\n  constructor() {\n    super(new AST.ASTGlobalScope());\n  }\n  $mainFunc(\n    this: PBGlobalScope,\n    body?: (this: PBFunctionScope) => void\n  ) {\n    const builder = getCurrentProgramBuilder();\n    if (builder.getDeviceType() === 'webgpu') {\n      const inputStruct = builder.defineBuiltinStruct(builder.shaderType, 'in');\n      this.$local(inputStruct[1]);\n      const isCompute = builder.shaderType === ShaderType.Compute;\n      const outputStruct = isCompute ? null : builder.defineBuiltinStruct(builder.shaderType, 'out');\n      if (!isCompute) {\n        this.$local(outputStruct[1]);\n      }\n      this.$internalFunction('chMainStub', [], false, body);\n      this.$internalFunction('main', inputStruct ? [inputStruct[3]] : [], true, function (this: PBFunctionScope) {\n        if (inputStruct) {\n          this[inputStruct[1].$str] = this[inputStruct[3].$str];\n        }\n        if (builder.shaderType === ShaderType.Fragment && builder.emulateDepthClamp) {\n          this.$builtins.fragDepth = builder.clamp(this.$inputs.clamppedDepth, 0, 1);\n        }\n        this.chMainStub();\n        if (builder.shaderType === ShaderType.Vertex) {\n          if (builder.depthRangeCorrection) {\n            this.$builtins.position.z = builder.mul(builder.add(this.$builtins.position.z, this.$builtins.position.w), 0.5);\n          }\n          if (builder.emulateDepthClamp) {\n            //z = gl_Position.z / gl_Position.w;\n            //z = (gl_DepthRange.diff * z + gl_DepthRange.near + gl_DepthRange.far) * 0.5;\n            this.$outputs.clamppedDepth = builder.div(this.$builtins.position.z, this.$builtins.position.w);\n            this.$builtins.position.z = 0;\n          }\n        }\n\n        if (!isCompute) {\n          this.$return(outputStruct[1]);\n        }\n      });\n    } else {\n      this.$internalFunction('main', [], true, function () {\n        if (builder.shaderType === ShaderType.Fragment && builder.emulateDepthClamp) {\n          this.$builtins.fragDepth = builder.clamp(this.$inputs.clamppedDepth, 0, 1);\n        }\n        body?.call(this);\n        if (builder.shaderType === ShaderType.Vertex && builder.emulateDepthClamp) {\n          this.$outputs.clamppedDepth = builder.div(builder.add(builder.div(this.$builtins.position.z, this.$builtins.position.w), 1), 2);\n          this.$builtins.position.z = 0;\n        }\n      });\n    }\n  }\n  $function(\n    this: PBGlobalScope,\n    name: string,\n    params: PBShaderExp[],\n    body?: (this: PBFunctionScope) => void,\n  ) {\n    this.$internalFunction(name, params, false, body);\n  }\n  /** @internal */\n  $getFunction(name: string): AST.ASTFunction {\n    return (this.$ast as AST.ASTGlobalScope).findFunction(name);\n  }\n  /** @internal */\n  $getCurrentFunctionScope(): PBScope {\n    let scope = getCurrentProgramBuilder().currentScope();\n    while (scope && !(scope instanceof PBFunctionScope)) {\n      scope = scope.$parent;\n    }\n    return scope;\n  }\n  /** @internal */\n  private $internalFunction(\n    this: PBGlobalScope,\n    name: string,\n    params: PBShaderExp[],\n    isMain: boolean,\n    body?: (this: PBFunctionScope) => void,\n  ) {\n    const numArgs = params.length;\n    const pb = getCurrentProgramBuilder();\n    params.forEach(param => {\n      if (!(param.$ast instanceof AST.ASTPrimitive)) {\n        throw new Error(`${name}(): invalid function definition`);\n      }\n      param.$ast = new AST.ASTFunctionParameter(param.$ast, getCurrentProgramBuilder().getDeviceType());\n    });\n    Object.defineProperty(this, name, {\n      get: function () {\n        const func = this.$getFunction(name);\n        if (!func) {\n          throw new Error(`function ${name} not found`);\n        }\n        return (...args: (ExpValueType)[]) => {\n          if (args.length !== numArgs) {\n            throw new Error(`ERROR: incorrect argument count for ${name}`);\n          }\n          const argsNonArray = args.map(val => pb.normalizeExpValue(val));\n          const funcType = pb._getFunctionOverload(name, argsNonArray);\n          if (!funcType) {\n            throw new Error(`ERROR: no matching overloads for function ${name}`);\n          }\n          return getCurrentProgramBuilder().$callFunction(name, funcType[1], funcType[0].returnType);\n        };\n      },\n    });\n    const currentFunctionScope = this.$getCurrentFunctionScope();\n    const astFunc = new AST.ASTFunction(name, params.map(param => param.$ast as AST.ASTFunctionParameter), isMain);\n    if (currentFunctionScope) {\n      const curIndex = this.$ast.statements.indexOf(currentFunctionScope.$ast);\n      if (curIndex < 0) {\n        throw new Error('Internal error');\n      }\n      this.$ast.statements.splice(curIndex, 0, astFunc);\n    } else {\n      this.$ast.statements.push(astFunc);\n    }\n    new PBFunctionScope(this, params, astFunc, body);\n  }\n}\n\nexport class PBInsideFunctionScope extends PBScope {\n  /** @internal */\n  constructor(parent: PBGlobalScope | PBInsideFunctionScope) {\n    super(new AST.ASTScope(), parent);\n  }\n  $return(retval?: ExpValueType) {\n    const functionScope = this.findOwnerFunction();\n    const astFunc = functionScope.$ast as AST.ASTFunction;\n    let returnType: PBTypeInfo = null;\n    const retValNonArray = getCurrentProgramBuilder().normalizeExpValue(retval);\n    if (retValNonArray !== undefined && retValNonArray !== null) {\n      if (typeof retValNonArray === 'number') {\n        if (Number.isInteger(retValNonArray)) {\n          if (retValNonArray < 0) {\n            if (retValNonArray < (0x80000000 >> 0)) {\n              throw new Error(`function ${astFunc.name}: invalid return value: ${retValNonArray}`);\n            }\n            returnType = typeI32;\n          } else {\n            if (retValNonArray > 0xFFFFFFFF) {\n              throw new Error(`function ${astFunc.name}: invalid return value: ${retValNonArray}`);\n            }\n            returnType = retValNonArray <= 0x7FFFFFFF ? typeI32 : typeU32;\n          }\n        } else {\n          returnType = typeF32;\n        }\n      } else if (typeof retValNonArray === 'boolean') {\n        returnType = typeBool;\n      } else {\n        returnType = retValNonArray.$ast.getType();\n      }\n    } else {\n      returnType = typeVoid;\n    }\n    if (returnType.isPointerType()) {\n      throw new Error('function can not return pointer type');\n    }\n    if (!astFunc.returnType) {\n      astFunc.returnType = returnType;\n    } else if (astFunc.returnType.typeId !== returnType.typeId) {\n      throw new Error(`function ${astFunc.name}: return type must be ${astFunc.returnType?.toTypeName(getCurrentProgramBuilder().getDeviceType()) || 'void'}`);\n    }\n    let returnValue: AST.ASTExpression = null;\n    if (retValNonArray !== undefined && retValNonArray !== null) {\n      if (retValNonArray instanceof PBShaderExp) {\n        returnValue = retValNonArray.$ast;\n      } else {\n        if (!returnType.isPrimitiveType() || !returnType.isScalarType()) {\n          throw new errors.PBTypeCastError(retValNonArray, typeof retValNonArray, returnType);\n        }\n        returnValue = new AST.ASTScalar(retValNonArray, returnType);\n      }\n    }\n    this.$ast.statements.push(new AST.ASTReturn(returnValue));\n  }\n  $scope(body: (this: PBInsideFunctionScope) => void): PBInsideFunctionScope {\n    const astScope = new AST.ASTNakedScope();\n    this.$ast.statements.push(astScope);\n    return new PBNakedScope(this, astScope, body);\n  }\n  $if(condition: ExpValueNonArrayType, body: (this: PBIfScope) => void): PBIfScope {\n    const astIf = new AST.ASTIf('if', condition instanceof PBShaderExp ? condition.$ast : new AST.ASTScalar(condition, typeof condition === 'number' ? typeF32 : typeBool));\n    this.$ast.statements.push(astIf);\n    return new PBIfScope(this, astIf, body);\n  }\n  $break() {\n    this.$ast.statements.push(new AST.ASTBreak());\n  }\n  $continue() {\n    this.$ast.statements.push(new AST.ASTContinue());\n  }\n  $for(counter: PBShaderExp, init: number | PBShaderExp, count: number | PBShaderExp, body: (this: PBForScope) => void) {\n    const initializerType = counter.$ast.getType();\n    if (!initializerType.isPrimitiveType() || !initializerType.isScalarType()) {\n      throw new errors.PBASTError(counter.$ast, 'invalid for range initializer type');\n    }\n    const initval = init instanceof PBShaderExp ? init.$ast : new AST.ASTScalar(init, initializerType);\n    const astFor = new AST.ASTRange(counter.$ast as AST.ASTPrimitive, initval, count instanceof PBShaderExp ? count.$ast : new AST.ASTScalar(count, initializerType), true);\n    this.$ast.statements.push(astFor);\n    new PBForScope(this, counter, count, astFor, body);\n  }\n  $do(body: (this: PBDoWhileScope) => void): PBDoWhileScope {\n    const astDoWhile = new AST.ASTDoWhile(null);\n    this.$ast.statements.push(astDoWhile);\n    return new PBDoWhileScope(this, astDoWhile, body);\n  }\n  $while(condition: ExpValueNonArrayType, body: (this: PBWhileScope) => void) {\n    const astWhile = new AST.ASTWhile(condition instanceof PBShaderExp ? condition.$ast : new AST.ASTScalar(condition, typeof condition === 'number' ? typeF32 : typeBool));\n    this.$ast.statements.push(astWhile);\n    new PBWhileScope(this, astWhile, body);\n  }\n  /** @internal */\n  private findOwnerFunction(): PBFunctionScope {\n    for (let scope: PBScope = this; scope; scope = scope.$parent) {\n      if (scope instanceof PBFunctionScope) {\n        return scope;\n      }\n    }\n    return null;\n  }\n}\n\nexport class PBFunctionScope extends PBInsideFunctionScope {\n  /** @internal */\n  constructor(\n    parent: PBGlobalScope,\n    params: PBShaderExp[],\n    ast: AST.ASTScope,\n    body?: (this: PBFunctionScope) => void,\n  ) {\n    super(parent);\n    this.$ast = ast;\n    for (const param of params) {\n      if (this.$_variables[param.$str]) {\n        throw new Error('Duplicate function parameter name is not allowed');\n      }\n      this.$_registerVar(param);\n    }\n    getCurrentProgramBuilder().pushScope(this);\n    body && body.call(this);\n    getCurrentProgramBuilder().popScope();\n\n    const astFunc = this.$ast as AST.ASTFunction;\n    if (!astFunc.returnType) {\n      astFunc.returnType = typeVoid;\n    }\n  }\n}\n\nexport class PBWhileScope extends PBInsideFunctionScope {\n  /** @internal */\n  constructor(\n    parent: PBInsideFunctionScope,\n    ast: AST.ASTScope,\n    body: (this: PBWhileScope) => void,\n  ) {\n    super(parent);\n    this.$ast = ast;\n    getCurrentProgramBuilder().pushScope(this);\n    body && body.call(this);\n    getCurrentProgramBuilder().popScope();\n  }\n}\n\nexport class PBDoWhileScope extends PBInsideFunctionScope {\n  /** @internal */\n  constructor(parent: PBInsideFunctionScope, ast: AST.ASTScope, body: (this: PBDoWhileScope) => void) {\n    super(parent);\n    this.$ast = ast;\n    getCurrentProgramBuilder().pushScope(this);\n    body && body.call(this);\n    getCurrentProgramBuilder().popScope();\n  }\n  $while(condition: ExpValueNonArrayType) {\n    (this.$ast as AST.ASTDoWhile).condition = condition instanceof PBShaderExp ? condition.$ast : new AST.ASTScalar(condition, typeof condition === 'number' ? typeF32 : typeBool);\n  }\n}\n\nexport class PBForScope extends PBInsideFunctionScope {\n  /** @internal */\n  constructor(\n    parent: PBGlobalScope | PBInsideFunctionScope,\n    counter: PBShaderExp,\n    count: number | PBShaderExp,\n    ast: AST.ASTScope,\n    body: (this: PBForScope) => void,\n  ) {\n    super(parent);\n    this.$ast = ast;\n    this.$_registerVar(counter);\n    getCurrentProgramBuilder().pushScope(this);\n    body && body.call(this);\n    getCurrentProgramBuilder().popScope();\n  }\n}\nexport class PBNakedScope extends PBInsideFunctionScope {\n  /** @internal */\n  constructor(\n    parent: PBInsideFunctionScope,\n    ast: AST.ASTScope,\n    body: (this: PBNakedScope) => void\n  ) {\n    super(parent);\n    this.$ast = ast;\n    getCurrentProgramBuilder().pushScope(this);\n    body && body.call(this);\n    getCurrentProgramBuilder().popScope();\n  }\n}\nexport class PBIfScope extends PBInsideFunctionScope {\n  /** @internal */\n  constructor(\n    parent: PBInsideFunctionScope,\n    ast: AST.ASTScope,\n    body: (this: PBIfScope) => void\n  ) {\n    super(parent);\n    this.$ast = ast;\n    getCurrentProgramBuilder().pushScope(this);\n    body && body.call(this);\n    getCurrentProgramBuilder().popScope();\n  }\n  $elseif(condition: ExpValueNonArrayType, body: (this: PBIfScope) => void): PBIfScope {\n    const astElseIf = new AST.ASTIf('else if', condition instanceof PBShaderExp ? condition.$ast : new AST.ASTScalar(condition, typeof condition === 'number' ? typeF32 : typeBool));\n    (this.$ast as AST.ASTIf).nextElse = astElseIf;\n    return new PBIfScope(this.$_parentScope as PBInsideFunctionScope, astElseIf, body);\n  }\n  $else(body: (this: PBIfScope) => void): void {\n    const astElse = new AST.ASTIf('else', null);\n    (this.$ast as AST.ASTIf).nextElse = astElse;\n    new PBIfScope(this.$_parentScope as PBInsideFunctionScope, astElse, body);\n  }\n}\n\nsetBuiltinFuncs(ProgramBuilder);\nsetConstructors(ProgramBuilder);\n"],"names":["errors.PBDeviceNotSupport","errors.PBReferenceValueRequired","AST.ASTAddressOf","errors.PBPointerValueRequired","AST.ASTReferenceOf","errors.PBParamValueError","AST.ASTStructDefine","AST.ASTShaderExpConstructor","AST.getBuiltinInputStructName","AST.getBuiltinOutputStructName","AST.getBuiltinInputStructInstanceName","AST.getBuiltinOutputStructInstanceName","AST.builtinVariables","AST.ASTDeclareVar","errors.PBInternalError","errors.PBParamLengthError","errors.PBParamTypeError","errors.PBTypeCastError","AST.ASTScalar","AST.ASTDiscard","AST.DeclareType","AST.ASTPrimitive","AST.ASTAssignment","AST.ASTLValueScalar","AST.genSamplerName","errors.PBValueOutOfRange","errors.PBError","errors.PBNonScopedFunctionCall","AST.ASTCallFunction","AST.ASTTouch","AST.ASTLValueDeclare","errors.PBASTError","AST.ASTHash","AST.ASTGlobalScope","AST.ASTFunctionParameter","AST.ASTFunction","AST.ASTScope","AST.ASTReturn","AST.ASTNakedScope","AST.ASTIf","AST.ASTBreak","AST.ASTContinue","AST.ASTRange","AST.ASTDoWhile","AST.ASTWhile"],"mappings":"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"}