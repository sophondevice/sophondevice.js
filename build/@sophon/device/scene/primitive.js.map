{"version":3,"file":"primitive.js","sources":["../../../../libs/device/src/scene/primitive.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Geometry } from '../device/geometry';\nimport type {BoundingVolume} from './bounding_volume';\nimport type { Device } from '../device/device';\n\nexport class Primitive extends Geometry {\n  /** @internal */\n  private static _nextId = 0;\n  /** @internal */\n  protected _id: number;\n  /** @internal */\n  protected _bbox: BoundingVolume;\n  /** @internal */\n  protected _bboxChangeCallback: (() => void)[];\n\n  constructor(device: Device) {\n    super(device);\n    this._id = ++Primitive._nextId;\n    this._bbox = null;\n    this._bboxChangeCallback = [];\n  }\n  get id(): number {\n    return this._id;\n  }\n  addBoundingboxChangeCallback(cb: () => void) {\n    cb && this._bboxChangeCallback.push(cb);\n  }\n  removeBoundingboxChangeCallback(cb: () => void) {\n    const index = this._bboxChangeCallback.indexOf(cb);\n    if (index >= 0) {\n      this._bboxChangeCallback.splice(index, 1);\n    }\n  }\n  /*\n  createAABBTree(): AABBTree {\n    const indices = this.getIndexBuffer() ? this.getIndexBuffer().getData() : null;\n    const vertices = (this.getVertexBuffer(VERTEX_ATTRIB_POSITION)?.getData() as Float32Array) || null;\n    const aabbtree = new AABBTree();\n    aabbtree.buildFromPrimitives(vertices, indices, this._primitiveType);\n    return aabbtree;\n  }\n  */\n  getBoundingVolume(): BoundingVolume {\n    return this._bbox;\n  }\n  setBoundingVolume(bv: BoundingVolume) {\n    if (bv !== this._bbox) {\n      this._bbox = bv;\n      for (const cb of this._bboxChangeCallback) {\n        cb();\n      }\n    }\n  }\n  /*\n  createWireframeIndexBuffer(epsl: number): {\n    buffer: AbstractIndexBuffer;\n    primitiveType: PrimitiveType;\n  } {\n    if (\n      this._primitiveType === PrimitiveType.LineList ||\n      this._primitiveType === PrimitiveType.LineStrip\n    ) {\n      return {\n        buffer: this.getIndexBuffer(),\n        primitiveType: this._primitiveType,\n      };\n    }\n    const that = this;\n    const vertices = (this.getVertexBuffer(VERTEX_ATTRIB_POSITION)?.getData() as Float32Array) || null;\n    const indexMap = (function () {\n      const im: number[] = [];\n      const numVerts = Math.floor(vertices.length / 3);\n      const sortedVertexIndices: number[] = [];\n      const sameVertex = function (v0: number, v1: number) {\n        return (\n          vertices[v0 * 3] === vertices[v1 * 3] &&\n          vertices[v0 * 3 + 1] === vertices[v1 * 3 + 1] &&\n          vertices[v0 * 3 + 2] === vertices[v1 * 3 + 2]\n        );\n      };\n      for (let i = 0; i < numVerts; i++) {\n        sortedVertexIndices.push(i);\n      }\n      sortedVertexIndices.sort(\n        (a, b) =>\n          vertices[a * 3] - vertices[b * 3] ||\n          vertices[a * 3 + 1] - vertices[b * 3 + 1] ||\n          vertices[a * 3 + 2] - vertices[b * 3 + 2],\n      );\n      let p0 = 0;\n      for (let p1 = 0; p1 < numVerts; p1++) {\n        const v0 = sortedVertexIndices[p0];\n        const v1 = sortedVertexIndices[p1];\n        if (sameVertex(v0, v1)) {\n          im[v1] = v0;\n        } else {\n          im[v1] = v1;\n          p0 = p1;\n        }\n      }\n      return im;\n    })();\n    const lineIndices = (function () {\n      const indexBuffer = that.getIndexBuffer();\n      const indices = indexBuffer ? indexBuffer.getData() : null;\n      const edges: {\n        [hash: string]: {tri: number[]; dot: number; removed: boolean};\n      } = {};\n      const triFlags: {normal: Vector3; merged: boolean}[] = [];\n      const t: [number, number, number] = [0, 0, 0];\n      const e01 = Vector3.zero();\n      const e02 = Vector3.zero();\n      const li: number[] = [];\n      let numTriangles: number;\n      let getTriangle: (tri: number, i: [number, number, number]) => void;\n      const addEdge = function (v0: number, v1: number, tri: number) {\n        if (v0 > v1) {\n          const tmp = v0;\n          v0 = v1;\n          v1 = tmp;\n        }\n        const hash = `${v0}-${v1}`;\n        let edgeInfo = edges[hash];\n        if (!edgeInfo) {\n          edges[hash] = edgeInfo = {tri: [], dot: 100, removed: false};\n        }\n        edgeInfo.tri.push(tri);\n      };\n      const calcFaceNormal = function (\n        v0: number,\n        v1: number,\n        v2: number,\n        outNormal: Vector3,\n      ): Vector3 {\n        e01\n          .set(\n            vertices[v1 * 3] - vertices[v0 * 3],\n            vertices[v1 * 3 + 1] - vertices[v0 * 3 + 1],\n            vertices[v1 * 3 + 2] - vertices[v0 * 3 + 2],\n          )\n          .inplaceNormalize();\n        e02\n          .set(\n            vertices[v2 * 3] - vertices[v0 * 3],\n            vertices[v2 * 3 + 1] - vertices[v0 * 3 + 1],\n            vertices[v2 * 3 + 2] - vertices[v0 * 3 + 2],\n          )\n          .inplaceNormalize();\n        return Vector3.cross(e01, e02, outNormal).inplaceNormalize();\n      };\n      switch (that._primitiveType) {\n      case PrimitiveType.TriangleList:\n        numTriangles = Math.floor(indices.length / 3);\n        getTriangle = (tri, i) => {\n          i[0] = indexMap[indices[tri * 3]];\n          i[1] = indexMap[indices[tri * 3 + 1]];\n          i[2] = indexMap[indices[tri * 3 + 2]];\n        };\n        break;\n      case PrimitiveType.TriangleStrip:\n        numTriangles = indices.length - 2;\n        getTriangle = (tri, i) => {\n          const r = tri % 2;\n          i[0] = indexMap[indices[tri + r]];\n          i[1] = indexMap[indices[tri - r + 1]];\n          i[2] = indexMap[indices[tri + 2]];\n        };\n        break;\n      case PrimitiveType.TriangleFan:\n        numTriangles = indices.length - 2;\n        getTriangle = (tri, i) => {\n          i[0] = indexMap[indices[0]];\n          i[1] = indexMap[indices[tri + 1]];\n          i[2] = indexMap[indices[tri + 2]];\n        };\n        break;\n      default:\n        return null;\n      }\n      for (let i = 0; i < numTriangles; i++) {\n        getTriangle(i, t);\n        addEdge(t[0], t[1], i);\n        addEdge(t[1], t[2], i);\n        addEdge(t[2], t[0], i);\n        const tf = (triFlags[i] = {normal: null, merged: false});\n        tf.normal = calcFaceNormal(t[0], t[1], t[2], tf.normal);\n      }\n      const threshold = Math.cos(epsl);\n      for (const hash in edges) {\n        const edgeInfo = edges[hash];\n        if (threshold < 1 && edgeInfo.tri.length === 2) {\n          const tri1 = triFlags[edgeInfo.tri[0]];\n          const tri2 = triFlags[edgeInfo.tri[1]];\n          const dot = Math.abs(Vector3.dot(tri1.normal, tri2.normal));\n          if (dot >= threshold) {\n            tri1.merged = true;\n            tri2.merged = true;\n            edgeInfo.removed = true;\n          }\n        }\n        if (!edgeInfo.removed) {\n          const s = hash.split('-');\n          li.push(Number(s[0]), Number(s[1]));\n        }\n      }\n      return li;\n    })();\n    const buffer =\n      lineIndices && lineIndices.length > 0\n        ? this._vao.device.createIndexBuffer(new Uint32Array(lineIndices))\n        : null;\n    return {buffer: buffer, primitiveType: PrimitiveType.LineList};\n  }\n  */\n}\n"],"names":[],"mappings":";;;AAKM,MAAO,SAAU,SAAQ,QAAQ,CAAA;AAE7B,IAAA,OAAO,OAAO,GAAG,CAAC,CAAC;AAEjB,IAAA,GAAG,CAAS;AAEZ,IAAA,KAAK,CAAiB;AAEtB,IAAA,mBAAmB,CAAiB;AAE9C,IAAA,WAAA,CAAY,MAAc,EAAA;QACxB,KAAK,CAAC,MAAM,CAAC,CAAC;AACd,QAAA,IAAI,CAAC,GAAG,GAAG,EAAE,SAAS,CAAC,OAAO,CAAC;AAC/B,QAAA,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;AAClB,QAAA,IAAI,CAAC,mBAAmB,GAAG,EAAE,CAAC;KAC/B;AACD,IAAA,IAAI,EAAE,GAAA;QACJ,OAAO,IAAI,CAAC,GAAG,CAAC;KACjB;AACD,IAAA,4BAA4B,CAAC,EAAc,EAAA;QACzC,EAAE,IAAI,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;KACzC;AACD,IAAA,+BAA+B,CAAC,EAAc,EAAA;QAC5C,MAAM,KAAK,GAAG,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;QACnD,IAAI,KAAK,IAAI,CAAC,EAAE;YACd,IAAI,CAAC,mBAAmB,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;AAC3C,SAAA;KACF;IAUD,iBAAiB,GAAA;QACf,OAAO,IAAI,CAAC,KAAK,CAAC;KACnB;AACD,IAAA,iBAAiB,CAAC,EAAkB,EAAA;AAClC,QAAA,IAAI,EAAE,KAAK,IAAI,CAAC,KAAK,EAAE;AACrB,YAAA,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;AAChB,YAAA,KAAK,MAAM,EAAE,IAAI,IAAI,CAAC,mBAAmB,EAAE;AACzC,gBAAA,EAAE,EAAE,CAAC;AACN,aAAA;AACF,SAAA;KACF;;;;;"}