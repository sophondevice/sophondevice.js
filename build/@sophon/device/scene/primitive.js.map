{"version":3,"file":"primitive.js","sources":["../../../../libs/device/src/scene/primitive.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\r\nimport { Geometry } from '../device/geometry';\r\nimport type {BoundingVolume} from './bounding_volume';\r\nimport type { Device } from '../device/device';\r\n\r\nexport class Primitive extends Geometry {\r\n  /** @internal */\r\n  private static _nextId = 0;\r\n  /** @internal */\r\n  protected _id: number;\r\n  /** @internal */\r\n  protected _bbox: BoundingVolume;\r\n  /** @internal */\r\n  protected _bboxChangeCallback: (() => void)[];\r\n\r\n  constructor(device: Device) {\r\n    super(device);\r\n    this._id = ++Primitive._nextId;\r\n    this._bbox = null;\r\n    this._bboxChangeCallback = [];\r\n  }\r\n  get id(): number {\r\n    return this._id;\r\n  }\r\n  addBoundingboxChangeCallback(cb: () => void) {\r\n    cb && this._bboxChangeCallback.push(cb);\r\n  }\r\n  removeBoundingboxChangeCallback(cb: () => void) {\r\n    const index = this._bboxChangeCallback.indexOf(cb);\r\n    if (index >= 0) {\r\n      this._bboxChangeCallback.splice(index, 1);\r\n    }\r\n  }\r\n  /*\r\n  createAABBTree(): AABBTree {\r\n    const indices = this.getIndexBuffer() ? this.getIndexBuffer().getData() : null;\r\n    const vertices = (this.getVertexBuffer(VERTEX_ATTRIB_POSITION)?.getData() as Float32Array) || null;\r\n    const aabbtree = new AABBTree();\r\n    aabbtree.buildFromPrimitives(vertices, indices, this._primitiveType);\r\n    return aabbtree;\r\n  }\r\n  */\r\n  getBoundingVolume(): BoundingVolume {\r\n    return this._bbox;\r\n  }\r\n  setBoundingVolume(bv: BoundingVolume) {\r\n    if (bv !== this._bbox) {\r\n      this._bbox = bv;\r\n      for (const cb of this._bboxChangeCallback) {\r\n        cb();\r\n      }\r\n    }\r\n  }\r\n  /*\r\n  createWireframeIndexBuffer(epsl: number): {\r\n    buffer: AbstractIndexBuffer;\r\n    primitiveType: PrimitiveType;\r\n  } {\r\n    if (\r\n      this._primitiveType === PrimitiveType.LineList ||\r\n      this._primitiveType === PrimitiveType.LineStrip\r\n    ) {\r\n      return {\r\n        buffer: this.getIndexBuffer(),\r\n        primitiveType: this._primitiveType,\r\n      };\r\n    }\r\n    const that = this;\r\n    const vertices = (this.getVertexBuffer(VERTEX_ATTRIB_POSITION)?.getData() as Float32Array) || null;\r\n    const indexMap = (function () {\r\n      const im: number[] = [];\r\n      const numVerts = Math.floor(vertices.length / 3);\r\n      const sortedVertexIndices: number[] = [];\r\n      const sameVertex = function (v0: number, v1: number) {\r\n        return (\r\n          vertices[v0 * 3] === vertices[v1 * 3] &&\r\n          vertices[v0 * 3 + 1] === vertices[v1 * 3 + 1] &&\r\n          vertices[v0 * 3 + 2] === vertices[v1 * 3 + 2]\r\n        );\r\n      };\r\n      for (let i = 0; i < numVerts; i++) {\r\n        sortedVertexIndices.push(i);\r\n      }\r\n      sortedVertexIndices.sort(\r\n        (a, b) =>\r\n          vertices[a * 3] - vertices[b * 3] ||\r\n          vertices[a * 3 + 1] - vertices[b * 3 + 1] ||\r\n          vertices[a * 3 + 2] - vertices[b * 3 + 2],\r\n      );\r\n      let p0 = 0;\r\n      for (let p1 = 0; p1 < numVerts; p1++) {\r\n        const v0 = sortedVertexIndices[p0];\r\n        const v1 = sortedVertexIndices[p1];\r\n        if (sameVertex(v0, v1)) {\r\n          im[v1] = v0;\r\n        } else {\r\n          im[v1] = v1;\r\n          p0 = p1;\r\n        }\r\n      }\r\n      return im;\r\n    })();\r\n    const lineIndices = (function () {\r\n      const indexBuffer = that.getIndexBuffer();\r\n      const indices = indexBuffer ? indexBuffer.getData() : null;\r\n      const edges: {\r\n        [hash: string]: {tri: number[]; dot: number; removed: boolean};\r\n      } = {};\r\n      const triFlags: {normal: Vector3; merged: boolean}[] = [];\r\n      const t: [number, number, number] = [0, 0, 0];\r\n      const e01 = Vector3.zero();\r\n      const e02 = Vector3.zero();\r\n      const li: number[] = [];\r\n      let numTriangles: number;\r\n      let getTriangle: (tri: number, i: [number, number, number]) => void;\r\n      const addEdge = function (v0: number, v1: number, tri: number) {\r\n        if (v0 > v1) {\r\n          const tmp = v0;\r\n          v0 = v1;\r\n          v1 = tmp;\r\n        }\r\n        const hash = `${v0}-${v1}`;\r\n        let edgeInfo = edges[hash];\r\n        if (!edgeInfo) {\r\n          edges[hash] = edgeInfo = {tri: [], dot: 100, removed: false};\r\n        }\r\n        edgeInfo.tri.push(tri);\r\n      };\r\n      const calcFaceNormal = function (\r\n        v0: number,\r\n        v1: number,\r\n        v2: number,\r\n        outNormal: Vector3,\r\n      ): Vector3 {\r\n        e01\r\n          .set(\r\n            vertices[v1 * 3] - vertices[v0 * 3],\r\n            vertices[v1 * 3 + 1] - vertices[v0 * 3 + 1],\r\n            vertices[v1 * 3 + 2] - vertices[v0 * 3 + 2],\r\n          )\r\n          .inplaceNormalize();\r\n        e02\r\n          .set(\r\n            vertices[v2 * 3] - vertices[v0 * 3],\r\n            vertices[v2 * 3 + 1] - vertices[v0 * 3 + 1],\r\n            vertices[v2 * 3 + 2] - vertices[v0 * 3 + 2],\r\n          )\r\n          .inplaceNormalize();\r\n        return Vector3.cross(e01, e02, outNormal).inplaceNormalize();\r\n      };\r\n      switch (that._primitiveType) {\r\n      case PrimitiveType.TriangleList:\r\n        numTriangles = Math.floor(indices.length / 3);\r\n        getTriangle = (tri, i) => {\r\n          i[0] = indexMap[indices[tri * 3]];\r\n          i[1] = indexMap[indices[tri * 3 + 1]];\r\n          i[2] = indexMap[indices[tri * 3 + 2]];\r\n        };\r\n        break;\r\n      case PrimitiveType.TriangleStrip:\r\n        numTriangles = indices.length - 2;\r\n        getTriangle = (tri, i) => {\r\n          const r = tri % 2;\r\n          i[0] = indexMap[indices[tri + r]];\r\n          i[1] = indexMap[indices[tri - r + 1]];\r\n          i[2] = indexMap[indices[tri + 2]];\r\n        };\r\n        break;\r\n      case PrimitiveType.TriangleFan:\r\n        numTriangles = indices.length - 2;\r\n        getTriangle = (tri, i) => {\r\n          i[0] = indexMap[indices[0]];\r\n          i[1] = indexMap[indices[tri + 1]];\r\n          i[2] = indexMap[indices[tri + 2]];\r\n        };\r\n        break;\r\n      default:\r\n        return null;\r\n      }\r\n      for (let i = 0; i < numTriangles; i++) {\r\n        getTriangle(i, t);\r\n        addEdge(t[0], t[1], i);\r\n        addEdge(t[1], t[2], i);\r\n        addEdge(t[2], t[0], i);\r\n        const tf = (triFlags[i] = {normal: null, merged: false});\r\n        tf.normal = calcFaceNormal(t[0], t[1], t[2], tf.normal);\r\n      }\r\n      const threshold = Math.cos(epsl);\r\n      for (const hash in edges) {\r\n        const edgeInfo = edges[hash];\r\n        if (threshold < 1 && edgeInfo.tri.length === 2) {\r\n          const tri1 = triFlags[edgeInfo.tri[0]];\r\n          const tri2 = triFlags[edgeInfo.tri[1]];\r\n          const dot = Math.abs(Vector3.dot(tri1.normal, tri2.normal));\r\n          if (dot >= threshold) {\r\n            tri1.merged = true;\r\n            tri2.merged = true;\r\n            edgeInfo.removed = true;\r\n          }\r\n        }\r\n        if (!edgeInfo.removed) {\r\n          const s = hash.split('-');\r\n          li.push(Number(s[0]), Number(s[1]));\r\n        }\r\n      }\r\n      return li;\r\n    })();\r\n    const buffer =\r\n      lineIndices && lineIndices.length > 0\r\n        ? this._vao.device.createIndexBuffer(new Uint32Array(lineIndices))\r\n        : null;\r\n    return {buffer: buffer, primitiveType: PrimitiveType.LineList};\r\n  }\r\n  */\r\n}\r\n"],"names":[],"mappings":";;;AAKM,MAAO,SAAU,SAAQ,QAAQ,CAAA;AAE7B,IAAA,OAAO,OAAO,GAAG,CAAC,CAAC;AAEjB,IAAA,GAAG,CAAS;AAEZ,IAAA,KAAK,CAAiB;AAEtB,IAAA,mBAAmB,CAAiB;AAE9C,IAAA,WAAA,CAAY,MAAc,EAAA;QACxB,KAAK,CAAC,MAAM,CAAC,CAAC;AACd,QAAA,IAAI,CAAC,GAAG,GAAG,EAAE,SAAS,CAAC,OAAO,CAAC;AAC/B,QAAA,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;AAClB,QAAA,IAAI,CAAC,mBAAmB,GAAG,EAAE,CAAC;KAC/B;AACD,IAAA,IAAI,EAAE,GAAA;QACJ,OAAO,IAAI,CAAC,GAAG,CAAC;KACjB;AACD,IAAA,4BAA4B,CAAC,EAAc,EAAA;QACzC,EAAE,IAAI,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;KACzC;AACD,IAAA,+BAA+B,CAAC,EAAc,EAAA;QAC5C,MAAM,KAAK,GAAG,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;QACnD,IAAI,KAAK,IAAI,CAAC,EAAE;YACd,IAAI,CAAC,mBAAmB,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;AAC3C,SAAA;KACF;IAUD,iBAAiB,GAAA;QACf,OAAO,IAAI,CAAC,KAAK,CAAC;KACnB;AACD,IAAA,iBAAiB,CAAC,EAAkB,EAAA;AAClC,QAAA,IAAI,EAAE,KAAK,IAAI,CAAC,KAAK,EAAE;AACrB,YAAA,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;AAChB,YAAA,KAAK,MAAM,EAAE,IAAI,IAAI,CAAC,mBAAmB,EAAE;AACzC,gBAAA,EAAE,EAAE,CAAC;AACN,aAAA;AACF,SAAA;KACF;;;;;"}