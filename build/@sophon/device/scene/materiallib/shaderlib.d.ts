import { ProgramBuilder } from '../../device/builder';
import { PBShaderExp } from '../../device/builder/base';
export declare const MAX_BONE_MATRIX_UNIFORM = 36;
export declare class ShaderLib {
    static readonly USAGE_VIEW_PROJ_MATRIX = "ch_usage_viewProjMatrix";
    static readonly USAGE_VIEW_MATRIX = "ch_usage_viewMatrix";
    static readonly USAGE_PROJECTION_MATRIX = "ch_usage_projMatrix";
    static readonly USAGE_WORLD_MATRIX = "ch_usage_worldMatrix";
    static readonly USAGE_BONE_MATRICIES = "ch_usage_boneMatrices";
    static readonly USAGE_BONE_TEXTURE_SIZE = "ch_usage_boneTextureSize";
    static readonly USAGE_INV_BIND_MATRIX = "ch_usage_invBindMatrix";
    static readonly USAGE_WORLD_VIEW_PROJ_MATRIX = "ch_usage_worldViewProjMatrix";
    static readonly USAGE_NORMAL_MAP = "ch_usage_normalMap";
    static readonly USAGE_NORMAL_SCALE = "ch_usage_normalScale";
    static readonly USAGE_VERTEX_COLOR = "ch_usage_vertexColor";
    static readonly USAGE_WORLD_POSITION = "ch_usage_worldPosition";
    static readonly USAGE_WORLD_NORMAL = "ch_usage_worldNormal";
    static readonly USAGE_WORLD_TANGENT = "ch_usage_worldTangent";
    static readonly USAGE_WORLD_BINORMAL = "ch_usage_worldBinormal";
    static readonly USAGE_ENV_LIGHT_STRENGTH = "ch_usage_envLightStrength";
    static readonly USAGE_CAMERA_POSITION = "ch_usage_cameraPosition";
    static readonly USAGE_CAMERA_PARAMS = "ch_usage_cameraParams";
    constructor(builder: ProgramBuilder);
    ftransform(inputPos?: PBShaderExp): PBShaderExp;
    ftransformWorld(worldPos?: PBShaderExp): PBShaderExp;
    getSkinMatrix(): PBShaderExp;
    transformSkinnedVertex(skinningMatrix: PBShaderExp, pos?: PBShaderExp): PBShaderExp;
    transformSkinnedNormal(skinningMatrix: PBShaderExp, normal?: PBShaderExp): PBShaderExp;
    transformSkinnedTangent(skinningMatrix: PBShaderExp, tangent?: PBShaderExp): PBShaderExp;
    worldSpacePositionToClip(pos: PBShaderExp): PBShaderExp;
    objectSpacePositionToWorld(pos: PBShaderExp): PBShaderExp;
    objectSpaceVectorToWorld(vec: PBShaderExp): PBShaderExp;
    nonLinearDepthToLinear(depth: PBShaderExp, nearFar?: PBShaderExp): PBShaderExp;
    nonLinearDepthToLinearNormalized(depth: PBShaderExp, nearFar?: PBShaderExp): PBShaderExp;
    linearToNonLinear(depth: PBShaderExp, nearFar?: PBShaderExp): PBShaderExp;
    encode2HalfToRGBA(a: PBShaderExp | number, b: PBShaderExp | number): PBShaderExp;
    decode2HalfFromRGBA(value: PBShaderExp): PBShaderExp;
    encodeNormalizedFloatToRGBA(value: PBShaderExp | number): PBShaderExp;
    decodeNormalizedFloatFromRGBA(value: PBShaderExp): PBShaderExp;
    calcFaceNormal(pos: PBShaderExp): any;
    evalNormal(worldNormal: PBShaderExp, normalMapTexCoord?: PBShaderExp, worldTangent?: PBShaderExp, worldBinormal?: PBShaderExp, worldPosition?: PBShaderExp): PBShaderExp;
    encodeColorOutput(outputColor: PBShaderExp): PBShaderExp;
    encodeNormal_SP(normal: PBShaderExp): PBShaderExp;
    decodeNormal_SP(enc: PBShaderExp): PBShaderExp;
    pseudoRandom(fragCoord: PBShaderExp): PBShaderExp;
}
