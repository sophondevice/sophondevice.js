import { Matrix4x4, Vector3, Vector4 } from "@sophon/base";
import { PBInsideFunctionScope, PBShaderExp, PBGlobalScope, PBStructTypeInfo } from "../../device/builder";
import { EnvironmentLighting } from "./envlight";
import type { DrawContext } from "../drawable";
import type { BindGroup, Texture2D, BaseTexture, TextureSampler } from '../../device/gpuobject';
export declare abstract class LightModel {
    constructor();
    getSurfaceDataType(env: EnvironmentLighting): PBStructTypeInfo;
    get albedo(): Vector4;
    set albedo(val: Vector4);
    get albedoMap(): Texture2D;
    get albedoSampler(): TextureSampler;
    get albedoMapTexCoord(): number;
    setAlbedoMap(tex: Texture2D, sampler: TextureSampler, texCoordIndex: number, texTransform?: Matrix4x4): void;
    get normalMap(): Texture2D;
    get normalSampler(): TextureSampler;
    get normalMapTexCoord(): number;
    setNormalMap(tex: Texture2D, sampler: TextureSampler, texCoordIndex: number, texTransform?: Matrix4x4): void;
    get normalScale(): number;
    set normalScale(val: number);
    get emissiveMap(): Texture2D;
    get emissiveSampler(): TextureSampler;
    get emissiveMapTexCoord(): number;
    setEmissiveMap(tex: Texture2D, sampler: TextureSampler, texCoordIndex: number, texTransform?: Matrix4x4): void;
    get emissiveColor(): Vector3;
    set emissiveColor(val: Vector3);
    get emissiveStrength(): number;
    set emissiveStrength(val: number);
    setTextureOptions(name: string, tex: BaseTexture, sampler: TextureSampler, texCoord: number, texTransform: Matrix4x4): void;
    calculateHash(): string;
    setupUniforms(scope: PBGlobalScope, ctx: DrawContext): void;
    applyUniforms(bindGroup: BindGroup, ctx: DrawContext): void;
    getSurfaceData(scope: PBInsideFunctionScope, envLight: EnvironmentLighting, worldPos: PBShaderExp, worldNormal?: PBShaderExp, worldTangent?: PBShaderExp, worldBinormal?: PBShaderExp): PBShaderExp;
    getTextureUniformName(key: string): string;
    calculateTexCoord(scope: PBInsideFunctionScope, index: number): PBShaderExp;
    calculateEmissive(scope: PBInsideFunctionScope): PBShaderExp;
    calculateAlbedo(scope: PBInsideFunctionScope): PBShaderExp;
    calculateNormal(scope: PBInsideFunctionScope, worldPosition: PBShaderExp, worldNormal?: PBShaderExp, worldTangent?: PBShaderExp, worldBinormal?: PBShaderExp): PBShaderExp;
    abstract supportLighting(): boolean;
    abstract envBRDF(envLight: EnvironmentLighting, scope: PBInsideFunctionScope, surfaceData: PBShaderExp): void;
    abstract directBRDF(scope: PBInsideFunctionScope, surfaceData: PBShaderExp, lightDir: PBShaderExp, attenuation: PBShaderExp): void;
    finalComposite(scope: PBInsideFunctionScope, surfaceData: PBShaderExp): PBShaderExp;
    isNormalUsed(): boolean;
}
export declare class UnlitLightModel extends LightModel {
    supportLighting(): boolean;
    envBRDF(envLight: EnvironmentLighting, scope: PBInsideFunctionScope, surfaceData: PBShaderExp): void;
    directBRDF(scope: PBInsideFunctionScope, surfaceData: PBShaderExp, lightDir: PBShaderExp, attenuation: PBShaderExp): void;
    isNormalUsed(): boolean;
    protected compositeSurfaceData(scope: PBInsideFunctionScope, surfaceData: PBShaderExp): void;
}
export declare class LambertLightModel extends LightModel {
    protected static readonly funcNameBRDFEnvConstantAmbient = "lib_lambertLM_envConstantAmbient";
    protected static readonly funcNameBRDFEnvIBL = "lib_lambertLM_envIBL";
    protected static readonly funcNameBRDFDirect = "lib_lambertLM_direct";
    supportLighting(): boolean;
    envBRDF(envLight: EnvironmentLighting, scope: PBInsideFunctionScope, surfaceData: PBShaderExp): void;
    directBRDF(scope: PBInsideFunctionScope, surfaceData: PBShaderExp, lightDir: PBShaderExp, attenuation: PBShaderExp): void;
}
export declare abstract class PBRLightModelBase extends LightModel {
    constructor();
    get ior(): number;
    set ior(val: number);
    get occlusionStrength(): number;
    set occlusionStrength(val: number);
    get occlusionMap(): Texture2D;
    get occlusionSampler(): TextureSampler;
    get occlusionMapTexCoord(): number;
    setOcclusionMap(tex: Texture2D, sampler: TextureSampler, texCoordIndex: number, texTransform?: Matrix4x4): void;
    get useSheen(): boolean;
    set useSheen(val: boolean);
    get sheenColorFactor(): Vector3;
    set sheenColorFactor(val: Vector3);
    get sheenRoughnessFactor(): number;
    set sheenRoughnessFactor(val: number);
    get sheenLut(): Texture2D;
    setSheenLut(tex: Texture2D): void;
    get sheenColorMap(): Texture2D;
    get sheenColorSampler(): TextureSampler;
    get sheenColorMapTexCoord(): number;
    setSheenColorMap(tex: Texture2D, sampler: TextureSampler, texCoordIndex: number, texTransform?: Matrix4x4): void;
    get sheenRoughnessMap(): Texture2D;
    get sheenRoughnessSampler(): TextureSampler;
    get sheenRoughnessMapTexCoord(): number;
    setSheenRoughnessMap(tex: Texture2D, sampler: TextureSampler, texCoordIndex: number, texTransform?: Matrix4x4): void;
    get useClearcoat(): boolean;
    set useClearcoat(val: boolean);
    get clearcoatIntensity(): number;
    set clearcoatIntensity(val: number);
    get clearcoatRoughnessFactor(): number;
    set clearcoatRoughnessFactor(val: number);
    get clearcoatNormalScale(): number;
    set clearcoatNormalScale(val: number);
    get clearcoatIntensityMap(): Texture2D;
    get clearcoatIntensitySampler(): TextureSampler;
    get clearcoatIntensityMapTexCoord(): number;
    setClearcoatIntensityMap(tex: Texture2D, sampler: TextureSampler, texCoordIndex: number, texTransform?: Matrix4x4): void;
    get clearcoatRoughnessMap(): Texture2D;
    get clearcoatRoughnessSampler(): TextureSampler;
    get clearcoatRoughnessMapTexCoord(): number;
    setClearcoatRoughnessMap(tex: Texture2D, sampler: TextureSampler, texCoordIndex: number, texTransform?: Matrix4x4): void;
    get clearcoatNormalMap(): Texture2D;
    get clearcoatNormalSampler(): TextureSampler;
    get clearcoatNormalMapTexCoord(): number;
    setClearcoatNormalMap(tex: Texture2D, sampler: TextureSampler, texCoordIndex: number, texTransform?: Matrix4x4): void;
    applyUniforms(bindGroup: BindGroup, ctx: DrawContext): void;
    calculateHash(): string;
    setupUniforms(scope: PBGlobalScope, ctx: DrawContext): void;
    supportLighting(): boolean;
    envBRDF(envLight: EnvironmentLighting, scope: PBInsideFunctionScope, surfaceData: PBShaderExp): void;
    directBRDF(scope: PBInsideFunctionScope, surfaceData: PBShaderExp, lightDir: PBShaderExp, attenuation: PBShaderExp): void;
}
export declare class PBRLightModelSG extends PBRLightModelBase {
    protected static readonly uniformSpecularFactor = "lib_PBRSG_specularFactor";
    protected static readonly uniformGlossinessFactor = "lib_PBRSG_glossinessFactor";
    constructor();
    get specularFactor(): Vector4;
    set specularFactor(val: Vector4);
    get glossinessFactor(): number;
    set glossinessFactor(val: number);
    get specularMap(): Texture2D;
    get specularMapTexCoord(): number;
    get specularSampler(): TextureSampler;
    setSpecularMap(tex: Texture2D, sampler: TextureSampler, texCoordIndex: number, texTransform?: Matrix4x4): void;
    applyUniforms(bindGroup: BindGroup, ctx: DrawContext): void;
    calculateHash(): string;
    setupUniforms(scope: PBGlobalScope, ctx: DrawContext): void;
}
export declare class PBRLightModelMR extends PBRLightModelBase {
    protected static readonly uniformMetallic = "lib_PBRLM_metallic";
    protected static readonly uniformRoughness = "lib_PBRLM_roughness";
    protected static readonly uniformSpecularFactor = "lib_PBRLM_specularFactor";
    constructor();
    get metallic(): number;
    set metallic(val: number);
    get roughness(): number;
    set roughness(val: number);
    get metallicIndex(): number;
    set metallicIndex(val: number);
    get roughnessIndex(): number;
    set roughnessIndex(val: number);
    get metallicMap(): Texture2D;
    get metallicSampler(): TextureSampler;
    get metallicMapTexCoord(): number;
    setMetallicMap(tex: Texture2D, sampler: TextureSampler, texCoordIndex: number, texTransform?: Matrix4x4): void;
    get specularFactor(): Vector4;
    set specularFactor(val: Vector4);
    get specularMap(): Texture2D;
    get specularSampler(): TextureSampler;
    get specularMapTexCoord(): number;
    setSpecularMap(tex: Texture2D, sampler: TextureSampler, texCoordIndex: number, texTransform?: Matrix4x4): void;
    get specularColorMap(): Texture2D;
    get specularColorSampler(): TextureSampler;
    get specularColorMapTexCoord(): number;
    setSpecularColorMap(tex: Texture2D, sampler: TextureSampler, texCoordIndex: number, texTransform?: Matrix4x4): void;
    applyUniforms(bindGroup: BindGroup, ctx: DrawContext): void;
    calculateHash(): string;
    setupUniforms(scope: PBGlobalScope, ctx: DrawContext): void;
}
