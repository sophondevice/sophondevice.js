{"version":3,"file":"terrainmaterial.js","sources":["../../../../../libs/device/src/scene/terrain/terrainmaterial.ts"],"sourcesContent":["import { Material } from '../material';\nimport { ShaderLib } from '../materiallib/shaderlib';\nimport { TerrainLightModel } from './terrainlightmodel';\nimport { Device, Texture2D, BindGroup, GPUProgram, PBGlobalScope, ProgramBuilder } from '../../device';\nimport { forwardComputeLighting } from '../renderers/forward.shaderlib';\nimport * as values from '../values';\nimport type { Vector2 } from '@sophon/base';\nimport type { DrawContext } from '../drawable';\nimport type { ShadowMapPass } from '../renderers';\n\nexport enum TerrainRenderMode {\n  UNKNOWN = 0,\n  NORMAL = 1,\n  DETAIL = 2,\n}\n\nexport const MAX_DETAIL_TEXTURE_LEVELS = 8;\n\nexport class TerrainMaterial extends Material {\n  private _lightModel: TerrainLightModel;\n  constructor(device: Device) {\n    super(device);\n    this._lightModel = new TerrainLightModel();\n  }\n  get baseMap(): Texture2D {\n    return this._lightModel.terrainBaseMap;\n  }\n  set baseMap(tex: Texture2D) {\n    this._lightModel.terrainBaseMap = tex;\n  }\n  get normalMap(): Texture2D {\n    return this._lightModel.terrainNormalMap;\n  }\n  set normalMap(tex: Texture2D) {\n    this._lightModel.terrainNormalMap = tex;\n  }\n  get detailMaskMap(): Texture2D {\n    return this._lightModel.detailMaskMap;\n  }\n  set detailMaskMap(tex: Texture2D) {\n    this._lightModel.detailMaskMap = tex;\n  }\n  get numDetailMaps(): number {\n    return this._lightModel.numDetailMaps;\n  }\n  getDetailColorMap(index: number): Texture2D {\n    return this._lightModel.getDetailColorMap(index);\n  }\n  getDetailScale(index: number): Vector2 {\n    return this._lightModel.getDetailScale(index);\n  }\n  addDetailMap(color: Texture2D, scale: Vector2) {\n    this._lightModel.addDetailMap(color, scale);\n  }\n  isTransparent(): boolean {\n    return false;\n  }\n  supportLighting(): boolean {\n    return this._lightModel.supportLighting();\n  }\n  applyUniforms(bindGroup: BindGroup, ctx: DrawContext, needUpdate: boolean): void {\n    super.applyUniforms(bindGroup, ctx, needUpdate);\n    this._lightModel.applyUniformsIfOutdated(bindGroup, ctx);\n  }\n  protected _createHash(): string {\n    return this._lightModel.getHash();\n  }\n  protected _createProgram(pb: ProgramBuilder, ctx: DrawContext, func: number): GPUProgram {\n    const that = this;\n    const lib = new ShaderLib(pb);\n    if (ctx.materialFunc === values.MATERIAL_FUNC_DEPTH_SHADOW && (ctx.renderPass as ShadowMapPass).light.shadow.depthClampEnabled) {\n      pb.emulateDepthClamp = true;\n    } else {\n      pb.emulateDepthClamp = false;\n    }\n    return pb.buildRenderProgram({\n      vertex(this: PBGlobalScope) {\n        const terrainInfoStruct = pb.defineStruct(null, 'std140', pb.ivec4('value'));\n        Material.initShader(pb, ctx);\n        that._lightModel.setupUniforms(this);\n        this.$inputs.pos = pb.vec3().attrib('position');\n        this.$inputs.normal = pb.vec3().attrib('normal');\n        this.$inputs.height = pb.float().attrib('custom0');\n        this.$outputs.uv = pb.vec2().tag(that._lightModel.uniformUV);\n        this.$outputs.worldPosition = pb.vec4().tag(ShaderLib.USAGE_WORLD_POSITION);\n        this.$outputs.worldNormal = pb.vec3().tag(ShaderLib.USAGE_WORLD_NORMAL);\n        this.scaleOffset = pb.defineStruct(null, 'std140', pb.vec4('value'))().uniform(2);\n        this.terrainInfo = terrainInfoStruct().uniform(2); // terrainSizeX, terrainSizeZ, numDetailTextureLevels, detailTextureSize\n        this.$mainFunc(function () {\n          this.$l.p = pb.add(pb.mul(this.$inputs.pos.xz, this.scaleOffset.value.xz), this.scaleOffset.value.yw);\n          this.$l.pos = pb.vec3(this.p.x, this.$inputs.height, this.p.y);\n          // this.$builtins.position = lib.ftransform(this.$l.pos);\n          this.$outputs.uv = pb.div(this.p.xy, pb.vec2(this.terrainInfo.value.xy));\n          this.$outputs.worldPosition = lib.objectSpacePositionToWorld(this.$l.pos);\n          this.$outputs.worldNormal = pb.normalize(lib.objectSpaceVectorToWorld(this.$inputs.normal));\n          this.$builtins.position = lib.ftransform(this.$l.pos);\n        });\n      },\n      fragment(this: PBGlobalScope) {\n        Material.initShader(pb, ctx);\n        if (func === values.MATERIAL_FUNC_NORMAL) {\n          that._lightModel.setupUniforms(this);\n          this.$outputs.outColor = pb.vec4();\n          this.$mainFunc(function () {\n            this.$l.litColor = forwardComputeLighting(this, that._lightModel, ctx);\n            this.$outputs.outColor = lib.encodeColorOutput(this.litColor);\n          });\n        } else if (func === values.MATERIAL_FUNC_DEPTH_ONLY) {\n          this.$outputs.outColor = pb.vec4();\n          this.$mainFunc(function () {\n            this.$outputs.outColor = pb.vec4(1);\n          })\n        } else if (func === values.MATERIAL_FUNC_DEPTH_SHADOW) {\n          this.$outputs.outColor = pb.vec4();\n          this.$mainFunc(function () {\n            this.$outputs.outColor = (ctx.renderPass as ShadowMapPass).light.shadow.computeShadowMapDepth(this);\n          });\n        } else {\n          throw new Error(`unknown material function: ${func}`);\n        }\n      }\n    });\n  }\n}\n\n/*\nexport class TerrainMaterial extends Material {\n  protected _renderMode: TerrainRenderMode;\n  protected _detailTexture: Texture2D;\n  protected _normalTexture: Texture2D;\n  protected _detailNormalTexture: Texture2D;\n  protected _lightModel: LambertLightModel;\n  constructor(device: Device) {\n    super(device);\n    this._renderMode = TerrainRenderMode.DETAIL;\n    this._detailTexture = null;\n    this._normalTexture = null;\n    this._detailNormalTexture = null;\n    this._lightModel = new LambertLightModel();\n  }\n  get renderMode(): TerrainRenderMode {\n    return this._renderMode;\n  }\n  set renderMode(val: TerrainRenderMode) {\n    if (val !== this._renderMode) {\n      this._renderMode = val;\n      this.optionChanged(true);\n    }\n  }\n  get detailTexture(): Texture2D {\n    return this._detailTexture;\n  }\n  set detailTexture(tex: Texture2D) {\n    tex = tex || null;\n    if (tex !== this._detailTexture) {\n      this.optionChanged(!this._detailTexture || !tex);\n      this._detailTexture = tex;\n    }\n  }\n  get normalTexture(): Texture2D {\n    return this._normalTexture;\n  }\n  set normalTexture(tex: Texture2D) {\n    tex = tex || null;\n    if (tex !== this._normalTexture) {\n      this.optionChanged(!this._normalTexture || !tex);\n      this._normalTexture = tex;\n    }\n  }\n  get detailNormalTexture(): Texture2D {\n    return this._detailNormalTexture;\n  }\n  set detailNormalTexture(tex: Texture2D) {\n    tex = tex || null;\n    if (tex !== this._detailNormalTexture) {\n      this.optionChanged(!this._detailNormalTexture || !tex);\n      this._detailNormalTexture = tex;\n    }\n  }\n  supportLighting(): boolean {\n    return this._lightModel ? this._lightModel.supportLighting() : false;\n  }\n  applyUniforms(bindGroup: BindGroup, ctx: DrawContext, needUpdate: boolean): void {\n    super.applyUniforms(bindGroup, ctx, needUpdate);\n    this._lightModel?.applyUniformsIfOutdated(bindGroup);\n  }\n  protected _createHash(): string {\n    return `${this._renderMode}|${Number(!!this._detailTexture)}|${Number(!!this._detailNormalTexture)}|${this._lightModel?.getHash() || ''}`;\n  }\n  protected _applyUniforms(bindGroup: BindGroup, ctx: DrawContext) {\n    if (this._detailTexture) {\n      bindGroup.setTexture('detailTexture', this._detailTexture);\n    }\n    if (this._normalTexture) {\n      bindGroup.setTexture('normalTexture', this._normalTexture);\n    }\n    if (this._detailNormalTexture) {\n      bindGroup.setTexture('detailNormalTexture', this._detailNormalTexture);\n    }\n  }\n  protected _createProgram(pb: ProgramBuilder, ctx: DrawContext, func: number): GPUProgram {\n    const that = this;\n    const lib = new ShaderLib(pb);\n    return pb.buildRenderProgram({\n      vertex(this: PBGlobalScope) {\n        const terrainInfoStruct = pb.defineStruct(null, 'std140', pb.ivec4('value'));\n        Material.initShader(pb, ctx);\n        this.$inputs.pos = pb.vec3().attrib('position');\n        this.$inputs.height = pb.float().attrib('custom0');\n        const texCoordUsed = [];\n        for (let i = 0; i < MAX_TEXCOORD_INDEX_COUNT; i++) {\n          texCoordUsed[i] = !!that._lightModel?.isTexCoordIndexUsed(i);\n        }\n        for (let i = 0; i < MAX_TEXCOORD_INDEX_COUNT; i++) {\n          if (texCoordUsed[i]) {\n            this.$inputs[`texcoord${i}`] = pb.vec2().attrib(`texCoord${i}` as any);\n          }\n        }\n        this.$outputs.uv = pb.vec2();\n        this.$outputs.worldPosition = pb.vec4().tag(ShaderLib.USAGE_WORLD_POSITION);\n        this.$outputs.normalScale = pb.float().tag(ShaderLib.USAGE_NORMAL_SCALE);\n        this.scaleOffset = pb.defineStruct(null, 'std140', pb.vec4('value'))().uniform(2);\n        this.terrainInfo = terrainInfoStruct().uniform(2); // terrainSizeX, terrainSizeZ, numDetailTextureLevels, detailTextureSize\n        this.$mainFunc(function () {\n          this.$l.p = pb.add(pb.mul(this.$inputs.pos.xz, this.scaleOffset.value.xz), this.scaleOffset.value.yw);\n          this.$l.pos = pb.vec3(this.p.x, this.$inputs.height, this.p.y);\n          this.$builtins.position = lib.ftransform(this.$l.pos);\n          this.$outputs.uv = pb.div(this.p.xy, pb.vec2(this.terrainInfo.value.xy));\n          this.$outputs.normalScale = 1;\n          this.$outputs.worldPosition = lib.objectSpacePositionToWorld(this.$l.pos);\n          for (let i = 0; i < MAX_TEXCOORD_INDEX_COUNT; i++) {\n            if (texCoordUsed[i]) {\n              this.$outputs[`texcoord${i}`] = this.$inputs[`texcoord${i}`];\n            }\n          }\n        });\n      },\n      fragment(this: PBGlobalScope) {\n        Material.initShader(pb, ctx);\n        if (func === values.MATERIAL_FUNC_NORMAL) {\n          const terrainInfoStruct = pb.defineStruct(null, 'std140', pb.ivec4('value'));\n          this.normalTexture = pb.tex2D().uniform(2);\n          this.terrainInfo = terrainInfoStruct().uniform(2); // terrainSizeX, terrainSizeZ, numDetailTextureLevels, detailTextureSize\n          this.detailTextureRects = pb.vec4[MAX_DETAIL_TEXTURE_LEVELS]().uniform(2);\n          this.detailTexture = pb.tex2D().uniform(2);\n          if (that._detailNormalTexture) {\n            this.detailNormalTexture = pb.tex2D().uniform(2).tag(ShaderLib.USAGE_NORMAL_MAP);\n          }\n          that._lightModel?.setupUniforms(this);\n          this.$outputs.outColor = pb.vec4();\n          this.$mainFunc(function () {\n            this.normal = pb.sub(pb.mul(pb.textureSample(this.normalTexture, this.$inputs.uv).xyz, 2), pb.vec3(1));\n            this.worldNormal = pb.normalize(lib.objectSpaceVectorToWorld(this.normal));\n            if (that._detailNormalTexture) {\n              this.axis = pb.sign(this.worldNormal);\n              this.tangent = pb.vec3(1, 0, 0);\n              this.binormal = pb.cross(this.tangent, this.worldNormal);\n              this.tangent = pb.cross(this.worldNormal, this.binormal);\n            }\n            if (that._renderMode === TerrainRenderMode.DETAIL || that._detailNormalTexture) {\n              this.$l.uv = this.$inputs.uv;\n              this.$l.padding = pb.vec2(pb.div(pb.float(1), pb.float(this.terrainInfo.value.w)));\n              this.$l.numLevels = this.terrainInfo.value.z;\n              if (that._renderMode === TerrainRenderMode.DETAIL) {\n                this.$l.albedo = pb.vec3();\n              }\n              this.$for(pb.int('i'), 0, MAX_DETAIL_TEXTURE_LEVELS, function () {\n                this.rect = this.detailTextureRects.at(this.i);\n                this.rectLeftTopPadded = pb.add(this.rect.xy, this.padding);\n                this.rectRightBottomPadded = pb.sub(this.rect.zw, this.padding);\n                this.$if(pb.or(pb.equal(this.i, pb.sub(this.numLevels, 1)), pb.all(pb.bvec4(pb.greaterThanEqual(this.uv, this.rectLeftTopPadded), pb.lessThanEqual(this.uv, this.rectRightBottomPadded)))), function () {\n                  this.$l.detailUV = pb.div(pb.sub(this.uv, this.rect.xy), pb.sub(this.rect.zw, this.rect.xy));\n                  this.$l.detailUV.x = pb.div(pb.add(pb.float(this.i), this.$l.detailUV.x), pb.float(this.numLevels));\n                  this.$l.detailUV.y = pb.sub(1, this.$l.detailUV.y);\n                  if (that._renderMode === TerrainRenderMode.DETAIL) {\n                    this.albedo = pb.textureSample(this.detailTexture, this.detailUV).xyz;\n                  }\n                  if (that._detailNormalTexture) {\n                    this.worldNormal = lib.evalNormal(this.worldNormal, this.detailUV, this.tangent, this.binormal);\n                  }\n                  this.$break();\n                });\n              });\n            }\n            if (that._renderMode === TerrainRenderMode.DETAIL) {\n              this.$l.litcolor = forwardComputeLighting(pb, this.worldNormal, this.albedo, (ctx.renderPass as ForwardRenderPass).shadowMaps, ctx.renderPass.renderScheme.useFloatShadowMap(), that._lightModel, ctx.environment);\n            } else {\n              this.$l.litcolor = pb.add(pb.mul(this.worldNormal, 0.5), pb.vec3(0.5));\n            }\n            this.$outputs.outColor = lib.encodeColorOutput(pb.vec4(this.litcolor, 1));\n          });\n        } else if (func === values.MATERIAL_FUNC_DEPTH_ONLY) {\n          this.$outputs.outColor = pb.vec4();\n          this.$mainFunc(function () {\n            this.$outputs.outColor = pb.vec4(1);\n          })\n        } else if (func === values.MATERIAL_FUNC_DEPTH_SHADOW) {\n          const floatFB = ctx.renderPass.renderScheme.useFloatShadowMap();\n          const lib = new ShaderLib(pb);\n          this.$outputs.outColor = pb.vec4();\n          this.$mainFunc(function () {\n            this.$l.depth = shadowMapComputeDepth(this);\n            this.$outputs.outColor = floatFB ? pb.vec4(this.depth, 0, 0, 1) : lib.encodeNormalizedFloatToRGBA(this.depth);\n          });\n        } else {\n          throw new Error(`unknown material function: ${func}`);\n        }\n      }\n    });\n  }\n}\n*/\n"],"names":["values.MATERIAL_FUNC_DEPTH_SHADOW","values.MATERIAL_FUNC_NORMAL","values.MATERIAL_FUNC_DEPTH_ONLY"],"mappings":"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"}