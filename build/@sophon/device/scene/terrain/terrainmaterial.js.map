{"version":3,"file":"terrainmaterial.js","sources":["../../../../../libs/device/src/scene/terrain/terrainmaterial.ts"],"sourcesContent":["import { Material } from '../material';\r\nimport { ShaderLib } from '../materiallib/shaderlib';\r\nimport { TerrainLightModel } from './terrainlightmodel';\r\nimport { Device, Texture2D, BindGroup, GPUProgram, PBGlobalScope, ProgramBuilder } from '../../device';\r\nimport { forwardComputeLighting } from '../renderers/forward.shaderlib';\r\nimport * as values from '../values';\r\nimport type { Vector2 } from '@sophon/base';\r\nimport type { DrawContext } from '../drawable';\r\nimport type { ShadowMapPass } from '../renderers';\r\n\r\nexport enum TerrainRenderMode {\r\n  UNKNOWN = 0,\r\n  NORMAL = 1,\r\n  DETAIL = 2,\r\n}\r\n\r\nexport const MAX_DETAIL_TEXTURE_LEVELS = 8;\r\n\r\nexport class TerrainMaterial extends Material {\r\n  private _lightModel: TerrainLightModel;\r\n  constructor(device: Device) {\r\n    super(device);\r\n    this._lightModel = new TerrainLightModel();\r\n  }\r\n  get baseMap(): Texture2D {\r\n    return this._lightModel.terrainBaseMap;\r\n  }\r\n  set baseMap(tex: Texture2D) {\r\n    this._lightModel.terrainBaseMap = tex;\r\n  }\r\n  get normalMap(): Texture2D {\r\n    return this._lightModel.terrainNormalMap;\r\n  }\r\n  set normalMap(tex: Texture2D) {\r\n    this._lightModel.terrainNormalMap = tex;\r\n  }\r\n  get detailMaskMap(): Texture2D {\r\n    return this._lightModel.detailMaskMap;\r\n  }\r\n  set detailMaskMap(tex: Texture2D) {\r\n    this._lightModel.detailMaskMap = tex;\r\n  }\r\n  get numDetailMaps(): number {\r\n    return this._lightModel.numDetailMaps;\r\n  }\r\n  getDetailColorMap(index: number): Texture2D {\r\n    return this._lightModel.getDetailColorMap(index);\r\n  }\r\n  getDetailScale(index: number): Vector2 {\r\n    return this._lightModel.getDetailScale(index);\r\n  }\r\n  addDetailMap(color: Texture2D, scale: Vector2) {\r\n    this._lightModel.addDetailMap(color, scale);\r\n  }\r\n  isTransparent(): boolean {\r\n    return false;\r\n  }\r\n  supportLighting(): boolean {\r\n    return this._lightModel.supportLighting();\r\n  }\r\n  applyUniforms(bindGroup: BindGroup, ctx: DrawContext, needUpdate: boolean): void {\r\n    super.applyUniforms(bindGroup, ctx, needUpdate);\r\n    this._lightModel.applyUniformsIfOutdated(bindGroup, ctx);\r\n  }\r\n  protected _createHash(): string {\r\n    return this._lightModel.getHash();\r\n  }\r\n  protected _createProgram(pb: ProgramBuilder, ctx: DrawContext, func: number): GPUProgram {\r\n    const that = this;\r\n    const lib = new ShaderLib(pb);\r\n    if (ctx.materialFunc === values.MATERIAL_FUNC_DEPTH_SHADOW && (ctx.renderPass as ShadowMapPass).light.shadow.depthClampEnabled) {\r\n      pb.emulateDepthClamp = true;\r\n    } else {\r\n      pb.emulateDepthClamp = false;\r\n    }\r\n    return pb.buildRenderProgram({\r\n      vertex(this: PBGlobalScope) {\r\n        const terrainInfoStruct = pb.defineStruct(null, 'std140', pb.ivec4('value'));\r\n        Material.initShader(pb, ctx);\r\n        that._lightModel.setupUniforms(this);\r\n        this.$inputs.pos = pb.vec3().attrib('position');\r\n        this.$inputs.normal = pb.vec3().attrib('normal');\r\n        this.$inputs.height = pb.float().attrib('custom0');\r\n        this.$outputs.uv = pb.vec2().tag(that._lightModel.uniformUV);\r\n        this.$outputs.worldPosition = pb.vec4().tag(ShaderLib.USAGE_WORLD_POSITION);\r\n        this.$outputs.worldNormal = pb.vec3().tag(ShaderLib.USAGE_WORLD_NORMAL);\r\n        this.scaleOffset = pb.defineStruct(null, 'std140', pb.vec4('value'))().uniform(2);\r\n        this.terrainInfo = terrainInfoStruct().uniform(2); // terrainSizeX, terrainSizeZ, numDetailTextureLevels, detailTextureSize\r\n        this.$mainFunc(function () {\r\n          this.$l.p = pb.add(pb.mul(this.$inputs.pos.xz, this.scaleOffset.value.xz), this.scaleOffset.value.yw);\r\n          this.$l.pos = pb.vec3(this.p.x, this.$inputs.height, this.p.y);\r\n          // this.$builtins.position = lib.ftransform(this.$l.pos);\r\n          this.$outputs.uv = pb.div(this.p.xy, pb.vec2(this.terrainInfo.value.xy));\r\n          this.$outputs.worldPosition = lib.objectSpacePositionToWorld(this.$l.pos);\r\n          this.$outputs.worldNormal = pb.normalize(lib.objectSpaceVectorToWorld(this.$inputs.normal));\r\n          this.$builtins.position = lib.ftransform(this.$l.pos);\r\n        });\r\n      },\r\n      fragment(this: PBGlobalScope) {\r\n        Material.initShader(pb, ctx);\r\n        if (func === values.MATERIAL_FUNC_NORMAL) {\r\n          that._lightModel.setupUniforms(this);\r\n          this.$outputs.outColor = pb.vec4();\r\n          this.$mainFunc(function () {\r\n            this.$l.litColor = forwardComputeLighting(this, that._lightModel, ctx);\r\n            this.$outputs.outColor = lib.encodeColorOutput(this.litColor);\r\n          });\r\n        } else if (func === values.MATERIAL_FUNC_DEPTH_ONLY) {\r\n          this.$outputs.outColor = pb.vec4();\r\n          this.$mainFunc(function () {\r\n            this.$outputs.outColor = pb.vec4(1);\r\n          })\r\n        } else if (func === values.MATERIAL_FUNC_DEPTH_SHADOW) {\r\n          this.$outputs.outColor = pb.vec4();\r\n          this.$mainFunc(function () {\r\n            this.$outputs.outColor = (ctx.renderPass as ShadowMapPass).light.shadow.computeShadowMapDepth(this);\r\n          });\r\n        } else {\r\n          throw new Error(`unknown material function: ${func}`);\r\n        }\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n/*\r\nexport class TerrainMaterial extends Material {\r\n  protected _renderMode: TerrainRenderMode;\r\n  protected _detailTexture: Texture2D;\r\n  protected _normalTexture: Texture2D;\r\n  protected _detailNormalTexture: Texture2D;\r\n  protected _lightModel: LambertLightModel;\r\n  constructor(device: Device) {\r\n    super(device);\r\n    this._renderMode = TerrainRenderMode.DETAIL;\r\n    this._detailTexture = null;\r\n    this._normalTexture = null;\r\n    this._detailNormalTexture = null;\r\n    this._lightModel = new LambertLightModel();\r\n  }\r\n  get renderMode(): TerrainRenderMode {\r\n    return this._renderMode;\r\n  }\r\n  set renderMode(val: TerrainRenderMode) {\r\n    if (val !== this._renderMode) {\r\n      this._renderMode = val;\r\n      this.optionChanged(true);\r\n    }\r\n  }\r\n  get detailTexture(): Texture2D {\r\n    return this._detailTexture;\r\n  }\r\n  set detailTexture(tex: Texture2D) {\r\n    tex = tex || null;\r\n    if (tex !== this._detailTexture) {\r\n      this.optionChanged(!this._detailTexture || !tex);\r\n      this._detailTexture = tex;\r\n    }\r\n  }\r\n  get normalTexture(): Texture2D {\r\n    return this._normalTexture;\r\n  }\r\n  set normalTexture(tex: Texture2D) {\r\n    tex = tex || null;\r\n    if (tex !== this._normalTexture) {\r\n      this.optionChanged(!this._normalTexture || !tex);\r\n      this._normalTexture = tex;\r\n    }\r\n  }\r\n  get detailNormalTexture(): Texture2D {\r\n    return this._detailNormalTexture;\r\n  }\r\n  set detailNormalTexture(tex: Texture2D) {\r\n    tex = tex || null;\r\n    if (tex !== this._detailNormalTexture) {\r\n      this.optionChanged(!this._detailNormalTexture || !tex);\r\n      this._detailNormalTexture = tex;\r\n    }\r\n  }\r\n  supportLighting(): boolean {\r\n    return this._lightModel ? this._lightModel.supportLighting() : false;\r\n  }\r\n  applyUniforms(bindGroup: BindGroup, ctx: DrawContext, needUpdate: boolean): void {\r\n    super.applyUniforms(bindGroup, ctx, needUpdate);\r\n    this._lightModel?.applyUniformsIfOutdated(bindGroup);\r\n  }\r\n  protected _createHash(): string {\r\n    return `${this._renderMode}|${Number(!!this._detailTexture)}|${Number(!!this._detailNormalTexture)}|${this._lightModel?.getHash() || ''}`;\r\n  }\r\n  protected _applyUniforms(bindGroup: BindGroup, ctx: DrawContext) {\r\n    if (this._detailTexture) {\r\n      bindGroup.setTexture('detailTexture', this._detailTexture);\r\n    }\r\n    if (this._normalTexture) {\r\n      bindGroup.setTexture('normalTexture', this._normalTexture);\r\n    }\r\n    if (this._detailNormalTexture) {\r\n      bindGroup.setTexture('detailNormalTexture', this._detailNormalTexture);\r\n    }\r\n  }\r\n  protected _createProgram(pb: ProgramBuilder, ctx: DrawContext, func: number): GPUProgram {\r\n    const that = this;\r\n    const lib = new ShaderLib(pb);\r\n    return pb.buildRenderProgram({\r\n      vertex(this: PBGlobalScope) {\r\n        const terrainInfoStruct = pb.defineStruct(null, 'std140', pb.ivec4('value'));\r\n        Material.initShader(pb, ctx);\r\n        this.$inputs.pos = pb.vec3().attrib('position');\r\n        this.$inputs.height = pb.float().attrib('custom0');\r\n        const texCoordUsed = [];\r\n        for (let i = 0; i < MAX_TEXCOORD_INDEX_COUNT; i++) {\r\n          texCoordUsed[i] = !!that._lightModel?.isTexCoordIndexUsed(i);\r\n        }\r\n        for (let i = 0; i < MAX_TEXCOORD_INDEX_COUNT; i++) {\r\n          if (texCoordUsed[i]) {\r\n            this.$inputs[`texcoord${i}`] = pb.vec2().attrib(`texCoord${i}` as any);\r\n          }\r\n        }\r\n        this.$outputs.uv = pb.vec2();\r\n        this.$outputs.worldPosition = pb.vec4().tag(ShaderLib.USAGE_WORLD_POSITION);\r\n        this.$outputs.normalScale = pb.float().tag(ShaderLib.USAGE_NORMAL_SCALE);\r\n        this.scaleOffset = pb.defineStruct(null, 'std140', pb.vec4('value'))().uniform(2);\r\n        this.terrainInfo = terrainInfoStruct().uniform(2); // terrainSizeX, terrainSizeZ, numDetailTextureLevels, detailTextureSize\r\n        this.$mainFunc(function () {\r\n          this.$l.p = pb.add(pb.mul(this.$inputs.pos.xz, this.scaleOffset.value.xz), this.scaleOffset.value.yw);\r\n          this.$l.pos = pb.vec3(this.p.x, this.$inputs.height, this.p.y);\r\n          this.$builtins.position = lib.ftransform(this.$l.pos);\r\n          this.$outputs.uv = pb.div(this.p.xy, pb.vec2(this.terrainInfo.value.xy));\r\n          this.$outputs.normalScale = 1;\r\n          this.$outputs.worldPosition = lib.objectSpacePositionToWorld(this.$l.pos);\r\n          for (let i = 0; i < MAX_TEXCOORD_INDEX_COUNT; i++) {\r\n            if (texCoordUsed[i]) {\r\n              this.$outputs[`texcoord${i}`] = this.$inputs[`texcoord${i}`];\r\n            }\r\n          }\r\n        });\r\n      },\r\n      fragment(this: PBGlobalScope) {\r\n        Material.initShader(pb, ctx);\r\n        if (func === values.MATERIAL_FUNC_NORMAL) {\r\n          const terrainInfoStruct = pb.defineStruct(null, 'std140', pb.ivec4('value'));\r\n          this.normalTexture = pb.tex2D().uniform(2);\r\n          this.terrainInfo = terrainInfoStruct().uniform(2); // terrainSizeX, terrainSizeZ, numDetailTextureLevels, detailTextureSize\r\n          this.detailTextureRects = pb.vec4[MAX_DETAIL_TEXTURE_LEVELS]().uniform(2);\r\n          this.detailTexture = pb.tex2D().uniform(2);\r\n          if (that._detailNormalTexture) {\r\n            this.detailNormalTexture = pb.tex2D().uniform(2).tag(ShaderLib.USAGE_NORMAL_MAP);\r\n          }\r\n          that._lightModel?.setupUniforms(this);\r\n          this.$outputs.outColor = pb.vec4();\r\n          this.$mainFunc(function () {\r\n            this.normal = pb.sub(pb.mul(pb.textureSample(this.normalTexture, this.$inputs.uv).xyz, 2), pb.vec3(1));\r\n            this.worldNormal = pb.normalize(lib.objectSpaceVectorToWorld(this.normal));\r\n            if (that._detailNormalTexture) {\r\n              this.axis = pb.sign(this.worldNormal);\r\n              this.tangent = pb.vec3(1, 0, 0);\r\n              this.binormal = pb.cross(this.tangent, this.worldNormal);\r\n              this.tangent = pb.cross(this.worldNormal, this.binormal);\r\n            }\r\n            if (that._renderMode === TerrainRenderMode.DETAIL || that._detailNormalTexture) {\r\n              this.$l.uv = this.$inputs.uv;\r\n              this.$l.padding = pb.vec2(pb.div(pb.float(1), pb.float(this.terrainInfo.value.w)));\r\n              this.$l.numLevels = this.terrainInfo.value.z;\r\n              if (that._renderMode === TerrainRenderMode.DETAIL) {\r\n                this.$l.albedo = pb.vec3();\r\n              }\r\n              this.$for(pb.int('i'), 0, MAX_DETAIL_TEXTURE_LEVELS, function () {\r\n                this.rect = this.detailTextureRects.at(this.i);\r\n                this.rectLeftTopPadded = pb.add(this.rect.xy, this.padding);\r\n                this.rectRightBottomPadded = pb.sub(this.rect.zw, this.padding);\r\n                this.$if(pb.or(pb.equal(this.i, pb.sub(this.numLevels, 1)), pb.all(pb.bvec4(pb.greaterThanEqual(this.uv, this.rectLeftTopPadded), pb.lessThanEqual(this.uv, this.rectRightBottomPadded)))), function () {\r\n                  this.$l.detailUV = pb.div(pb.sub(this.uv, this.rect.xy), pb.sub(this.rect.zw, this.rect.xy));\r\n                  this.$l.detailUV.x = pb.div(pb.add(pb.float(this.i), this.$l.detailUV.x), pb.float(this.numLevels));\r\n                  this.$l.detailUV.y = pb.sub(1, this.$l.detailUV.y);\r\n                  if (that._renderMode === TerrainRenderMode.DETAIL) {\r\n                    this.albedo = pb.textureSample(this.detailTexture, this.detailUV).xyz;\r\n                  }\r\n                  if (that._detailNormalTexture) {\r\n                    this.worldNormal = lib.evalNormal(this.worldNormal, this.detailUV, this.tangent, this.binormal);\r\n                  }\r\n                  this.$break();\r\n                });\r\n              });\r\n            }\r\n            if (that._renderMode === TerrainRenderMode.DETAIL) {\r\n              this.$l.litcolor = forwardComputeLighting(pb, this.worldNormal, this.albedo, (ctx.renderPass as ForwardRenderPass).shadowMaps, ctx.renderPass.renderScheme.useFloatShadowMap(), that._lightModel, ctx.environment);\r\n            } else {\r\n              this.$l.litcolor = pb.add(pb.mul(this.worldNormal, 0.5), pb.vec3(0.5));\r\n            }\r\n            this.$outputs.outColor = lib.encodeColorOutput(pb.vec4(this.litcolor, 1));\r\n          });\r\n        } else if (func === values.MATERIAL_FUNC_DEPTH_ONLY) {\r\n          this.$outputs.outColor = pb.vec4();\r\n          this.$mainFunc(function () {\r\n            this.$outputs.outColor = pb.vec4(1);\r\n          })\r\n        } else if (func === values.MATERIAL_FUNC_DEPTH_SHADOW) {\r\n          const floatFB = ctx.renderPass.renderScheme.useFloatShadowMap();\r\n          const lib = new ShaderLib(pb);\r\n          this.$outputs.outColor = pb.vec4();\r\n          this.$mainFunc(function () {\r\n            this.$l.depth = shadowMapComputeDepth(this);\r\n            this.$outputs.outColor = floatFB ? pb.vec4(this.depth, 0, 0, 1) : lib.encodeNormalizedFloatToRGBA(this.depth);\r\n          });\r\n        } else {\r\n          throw new Error(`unknown material function: ${func}`);\r\n        }\r\n      }\r\n    });\r\n  }\r\n}\r\n*/\r\n"],"names":["values.MATERIAL_FUNC_DEPTH_SHADOW","values.MATERIAL_FUNC_NORMAL","values.MATERIAL_FUNC_DEPTH_ONLY"],"mappings":"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"}