export declare class IterableWrapper implements Iterable<number> {
    protected _v: Float32Array;
    [Symbol.iterator](): Iterator<number>;
    constructor(nOrArray: number | Float32Array);
    get size(): number;
    assign(other: ArrayLike<number>): this;
    getArray(): Float32Array;
    setArray(arr: Float32Array): this;
}
export declare enum CubeFace {
    PX = 0,
    NX = 1,
    PY = 2,
    NY = 3,
    PZ = 4,
    NZ = 5
}
export declare class VectorBase extends IterableWrapper {
    constructor(nOrArray: number | Float32Array);
    getChangeCallback(): () => void;
    setChangeCallback(callback: () => void): void;
    get callbackEnabled(): boolean;
    set callbackEnabled(enabled: boolean);
    changeNotify(): void;
    equalsTo(other: IterableWrapper, epsilon?: number): boolean;
    toString(): string;
    assign(other: ArrayLike<number>): this;
    isNaN(): boolean;
}
export interface IVector2Like {
    x: number;
    y: number;
}
export declare class Vector2 extends VectorBase {
    constructor(x: number, y: number);
    constructor(array: number[]);
    constructor(rhs: Vector2);
    constructor(array: Float32Array);
    constructor();
    clone(): Vector2;
    get x(): number;
    set x(v: number);
    setX(v: number): this;
    get y(): number;
    set y(v: number);
    setY(v: number): this;
    get magnitude(): number;
    set magnitude(val: number);
    setMagnitude(val: number): this;
    get magnitudeSq(): number;
    set(x: number, y: number): this;
    setAndNormalize(x: number, y: number): Vector2;
    subBy(other: IVector2Like): Vector2;
    addBy(other: IVector2Like): Vector2;
    mulBy(other: IVector2Like): Vector2;
    divBy(other: IVector2Like): Vector2;
    scaleBy(f: number): Vector2;
    inplaceNormalize(): Vector2;
    inplaceInverse(): Vector2;
    inplaceMin(other: IVector2Like): Vector2;
    inplaceMax(other: IVector2Like): Vector2;
    inplaceAbs(): Vector2;
    static zero(): Vector2;
    static one(): Vector2;
    static axisPX(): Vector2;
    static axisNX(): Vector2;
    static axisPY(): Vector2;
    static axisNY(): Vector2;
    static magnitudeSq(v: IVector2Like): number;
    static magnitude(v: IVector2Like): number;
    static distance(v1: IVector2Like, v2: IVector2Like): number;
    static distanceSq(v1: IVector2Like, v2: IVector2Like): number;
    static normalize(v: IVector2Like, result?: Vector2): Vector2;
    static inverse(v: IVector2Like, result?: Vector2): Vector2;
    static sub(a: IVector2Like, b: IVector2Like, result?: Vector2): Vector2;
    static add(a: IVector2Like, b: IVector2Like, result?: Vector2): Vector2;
    static mul(a: IVector2Like, b: IVector2Like, result?: Vector2): Vector2;
    static div(a: IVector2Like, b: IVector2Like, result?: Vector2): Vector2;
    static scale(a: IVector2Like, b: number, result?: Vector2): Vector2;
    static min(a: IVector2Like, b: IVector2Like, result?: Vector2): Vector2;
    static max(a: IVector2Like, b: IVector2Like, result?: Vector2): Vector2;
    static abs(a: IVector2Like, result?: Vector2): Vector2;
    static dot(a: IVector2Like, b: IVector2Like): number;
    static cross(a: IVector2Like, b: IVector2Like): number;
}
export interface IVector3Like {
    x: number;
    y: number;
    z: number;
}
export declare class Vector3 extends VectorBase {
    constructor(x: number, y: number, z: number);
    constructor(array: number[]);
    constructor(rhs: Vector3);
    constructor(array: Float32Array);
    constructor();
    clone(): Vector3;
    get x(): number;
    set x(v: number);
    setX(v: number): this;
    get y(): number;
    set y(v: number);
    setY(v: number): this;
    get z(): number;
    set z(v: number);
    setZ(v: number): this;
    get magnitude(): number;
    set magnitude(val: number);
    setMagnitude(val: number): Vector3;
    get magnitudeSq(): number;
    xy(): Vector2;
    set(x: number, y: number, z: number): Vector3;
    setAndNormalize(x: number, y: number, z: number): Vector3;
    subBy(other: IVector3Like): Vector3;
    addBy(other: IVector3Like): Vector3;
    mulBy(other: IVector3Like): Vector3;
    divBy(other: IVector3Like): Vector3;
    scaleBy(f: number): Vector3;
    crossBy(other: IVector3Like): Vector3;
    inplaceNormalize(): Vector3;
    inplaceInverse(): Vector3;
    inplaceMin(other: IVector3Like): Vector3;
    inplaceMax(other: IVector3Like): Vector3;
    inplaceAbs(): Vector3;
    static zero(): Vector3;
    static one(): Vector3;
    static axisPX(): Vector3;
    static axisNX(): Vector3;
    static axisPY(): Vector3;
    static axisNY(): Vector3;
    static axisPZ(): Vector3;
    static axisNZ(): Vector3;
    static magnitude(v: IVector3Like): number;
    static magnitudeSq(v: IVector3Like): number;
    static distance(v1: IVector3Like, v2: IVector3Like): number;
    static distanceSq(v1: IVector3Like, v2: IVector3Like): number;
    static normalize(v: IVector3Like, result?: Vector3): Vector3;
    static inverse(v: IVector3Like, result?: Vector3): Vector3;
    static sub(a: IVector3Like, b: IVector3Like, result?: Vector3): Vector3;
    static add(a: IVector3Like, b: IVector3Like, result?: Vector3): Vector3;
    static mul(a: IVector3Like, b: IVector3Like, result?: Vector3): Vector3;
    static div(a: IVector3Like, b: IVector3Like, result?: Vector3): Vector3;
    static scale(a: IVector3Like, b: number, result?: Vector3): Vector3;
    static min(a: IVector3Like, b: IVector3Like, result?: Vector3): Vector3;
    static max(a: IVector3Like, b: IVector3Like, result?: Vector3): Vector3;
    static abs(a: IVector3Like, result?: Vector3): Vector3;
    static dot(a: IVector3Like, b: IVector3Like): number;
    static cross(a: IVector3Like, b: IVector3Like, result?: Vector3): Vector3;
}
export interface IVector4Like {
    x: number;
    y: number;
    z: number;
    w: number;
}
export declare class Vector4 extends VectorBase {
    constructor(x: number, y: number, z: number, w: number);
    constructor(array: number[]);
    constructor(array: Float32Array);
    constructor(rhs: Vector4);
    constructor(v3: Vector3, w: number);
    constructor();
    clone(): Vector4;
    get x(): number;
    set x(v: number);
    setX(v: number): this;
    get y(): number;
    set y(v: number);
    setY(v: number): this;
    get z(): number;
    set z(v: number);
    setZ(v: number): this;
    get w(): number;
    set w(v: number);
    setW(v: number): this;
    get magnitude(): number;
    set magnitude(val: number);
    setMagnitude(val: number): Vector4;
    get magnitudeSq(): number;
    xy(): Vector2;
    xyz(): Vector3;
    set(x: number, y: number, z: number, w: number): Vector4;
    setAndNormalize(x: number, y: number, z: number, w: number): Vector4;
    subBy(other: IVector4Like): Vector4;
    addBy(other: IVector4Like): Vector4;
    mulBy(other: IVector4Like): Vector4;
    divBy(other: IVector4Like): Vector4;
    scaleBy(f: number): Vector4;
    inplaceNormalize(): Vector4;
    inplaceInverse(): Vector4;
    inplaceMin(other: IVector4Like): Vector4;
    inplaceMax(other: IVector4Like): Vector4;
    inplaceAbs(): Vector4;
    static zero(): Vector4;
    static one(): Vector4;
    static axisPX(): Vector4;
    static axisNX(): Vector4;
    static axisPY(): Vector4;
    static axisNY(): Vector4;
    static axisPZ(): Vector4;
    static axisNZ(): Vector4;
    static axisPW(): Vector4;
    static axisNW(): Vector4;
    static magnitude(v: IVector4Like): number;
    static magnitudeSq(v: IVector4Like): number;
    static normalize(v: IVector4Like, result?: Vector4): Vector4;
    static inverse(v: IVector4Like, result?: Vector4): Vector4;
    static sub(a: IVector4Like, b: IVector4Like, result?: Vector4): Vector4;
    static add(a: IVector4Like, b: IVector4Like, result?: Vector4): Vector4;
    static mul(a: IVector4Like, b: IVector4Like, result?: Vector4): Vector4;
    static div(a: IVector4Like, b: IVector4Like, result?: Vector4): Vector4;
    static scale(a: IVector4Like, b: number, result?: Vector4): Vector4;
    static min(a: IVector4Like, b: IVector4Like, result?: Vector4): Vector4;
    static max(a: IVector4Like, b: IVector4Like, result?: Vector4): Vector4;
    static abs(a: IVector4Like, result?: Vector4): Vector4;
    static dot(a: IVector4Like, b: IVector4Like): number;
}
export declare class Quaternion extends VectorBase {
    constructor(x: number, y: number, z: number, w: number);
    constructor(array: number[]);
    constructor(array: Float32Array);
    constructor(rhs: Quaternion);
    constructor(matrix: Matrix3x3);
    constructor(matrix: Matrix4x4);
    constructor();
    clone(): Quaternion;
    get x(): number;
    set x(v: number);
    setX(v: number): this;
    get y(): number;
    set y(v: number);
    setY(v: number): this;
    get z(): number;
    set z(v: number);
    setZ(v: number): this;
    get w(): number;
    set w(v: number);
    setW(v: number): this;
    set(x: number, y: number, z: number, w: number): Quaternion;
    scaleBy(f: number): Quaternion;
    setAndNormalize(x: number, y: number, z: number, w: number): Quaternion;
    get magnitude(): number;
    get magnitudeSq(): number;
    identity(): Quaternion;
    inplaceNormalize(): Quaternion;
    inplaceConjugate(): Quaternion;
    multiplyRight(other: IVector4Like): Quaternion;
    multiplyLeft(other: IVector4Like): Quaternion;
    slerpRight(other: IVector4Like, t: number): Quaternion;
    slerpLeft(other: IVector4Like, t: number): Quaternion;
    unitVectorToUnitVector(from: IVector3Like, to: IVector3Like): Quaternion;
    fromEulerAngle(a: number, b: number, c: number, order: 'XYZ' | 'YXZ' | 'ZXY' | 'ZYX' | 'YZX' | 'XZY'): Quaternion;
    fromAxisAngle(axis: IVector3Like, angle: number): Quaternion;
    fromRotationMatrix(matrix: Matrix3x3 | Matrix4x4): Quaternion;
    toMatrix3x3(matrix?: Matrix3x3): Matrix3x3;
    toMatrix4x4(matrix?: Matrix4x4): Matrix4x4;
    toMatrix(matrix: Matrix3x3 | Matrix4x4): void;
    getAxisAngle(): Vector4;
    transform(v: IVector3Like, result?: Vector3): Vector3;
    addBy(other: Quaternion): Quaternion;
    static magnitude(q: IVector4Like): number;
    static magnitudeSq(q: IVector4Like): number;
    static add(q: Quaternion, other: Quaternion, result?: Quaternion): Quaternion;
    static scale(q: Quaternion, t: number, result?: Quaternion): Quaternion;
    static dot(a: IVector4Like, b: IVector4Like): number;
    static identity(q?: Quaternion): Quaternion;
    static normalize(q: IVector4Like, result?: Quaternion): Quaternion;
    static conjugate(q: IVector4Like, result?: Quaternion): Quaternion;
    static multiply(a: IVector4Like, b: IVector4Like, result?: Quaternion): Quaternion;
    static slerp(a: IVector4Like, b: IVector4Like, t: number, result?: Quaternion): Quaternion;
    static angleBetween(a: IVector4Like, b: IVector4Like): number;
    static unitVectorToUnitVector(from: IVector3Like, to: IVector3Like, result?: Quaternion): Quaternion;
    static fromEulerAngle(a: number, b: number, c: number, order: 'XYZ' | 'YXZ' | 'ZXY' | 'ZYX' | 'YZX' | 'XZY', result?: Quaternion): Quaternion;
    static fromAxisAngle(axis: IVector3Like, angle: number, result?: Quaternion): Quaternion;
    static fromRotationMatrix(matrix: Matrix3x3 | Matrix4x4, result?: Quaternion): Quaternion;
}
export declare class Matrix3x3 extends VectorBase {
    constructor();
    constructor(q: Quaternion);
    constructor(rhs: Matrix3x3);
    constructor(m4: Matrix4x4);
    constructor(array: number[]);
    constructor(array: Float32Array);
    clone(): Matrix3x3;
    get m00(): number;
    set m00(v: number);
    get m10(): number;
    set m10(v: number);
    get m20(): number;
    set m20(v: number);
    get m01(): number;
    set m01(v: number);
    get m11(): number;
    set m11(v: number);
    get m21(): number;
    set m21(v: number);
    get m02(): number;
    set m02(v: number);
    get m12(): number;
    set m12(v: number);
    get m22(): number;
    set m22(v: number);
    getRow(row: number, result?: Vector3): Vector3;
    setRow(row: number, v: IVector3Like): this;
    getCol(col: number, result?: Vector3): Vector3;
    setCol(col: number, v: IVector3Like): this;
    static add(a: Matrix3x3, b: Matrix3x3, result?: Matrix3x3): Matrix3x3;
    static sub(a: Matrix3x3, b: Matrix3x3, result?: Matrix3x3): Matrix3x3;
    static mul(a: Matrix3x3, b: Matrix3x3, result?: Matrix3x3): Matrix3x3;
    static div(a: Matrix3x3, b: Matrix3x3, result?: Matrix3x3): Matrix3x3;
    static scale(a: Matrix3x3, f: number, result?: Matrix3x3): Matrix3x3;
    static identity(result?: Matrix3x3): Matrix3x3;
    static transpose(matrix: Matrix3x3, result?: Matrix3x3): Matrix3x3;
    static inverse(matrix: Matrix3x3, result?: Matrix3x3): Matrix3x3;
    static inverseAffine(matrix: Matrix3x3, result?: Matrix3x3): Matrix3x3;
    static scaling(s: IVector3Like, result?: Matrix3x3): Matrix3x3;
    static rotationX(angle: number, result?: Matrix3x3): Matrix3x3;
    static rotationY(angle: number, result?: Matrix3x3): Matrix3x3;
    static rotationZ(angle: number, result?: Matrix3x3): Matrix3x3;
    static rotation(axis: IVector3Like, angle: number, result?: Matrix3x3): Matrix3x3;
    static multiply(m1: Matrix3x3, m2: Matrix3x3, result?: Matrix3x3): Matrix3x3;
    static multiplyAffine(m1: Matrix3x3, m2: Matrix3x3, result?: Matrix3x3): Matrix3x3;
    subBy(other: Matrix3x3): Matrix3x3;
    addBy(other: Matrix3x3): Matrix3x3;
    mulBy(other: Matrix3x3): Matrix3x3;
    divBy(other: Matrix3x3): Matrix3x3;
    scaleBy(f: number): Matrix3x3;
    identity(): Matrix3x3;
    scaling(s: IVector3Like): Matrix3x3;
    inplaceInverse(): Matrix3x3;
    inplaceInverseAffine(): Matrix3x3;
    transpose(): Matrix3x3;
    multiplyRight(other: Matrix3x3): Matrix3x3;
    multiplyRightAffine(other: Matrix3x3): Matrix3x3;
    multiplyLeft(other: Matrix3x3): Matrix3x3;
    multiplyLeftAffine(other: Matrix3x3): Matrix3x3;
    rotationX(angle: number): Matrix3x3;
    rotationY(angle: number): Matrix3x3;
    rotationZ(angle: number): Matrix3x3;
    rotation(axis: IVector3Like, angle: number): Matrix3x3;
    transform(point: IVector3Like, result?: Vector3): Vector3;
    transformPoint(vec: IVector3Like, result?: Vector3): Vector3;
    transformPointAffine(point: IVector3Like, result?: Vector3): Vector3;
    transformVector(vec: IVector3Like, result?: Vector3): Vector3;
    transformVectorAffine(vec: IVector3Like, result?: Vector3): Vector3;
    transformAffine(vec: IVector4Like, result?: Vector3): Vector3;
    testRotationPart(epsl?: number): boolean;
}
export declare class Matrix4x4 extends VectorBase {
    constructor();
    constructor(array: number[]);
    constructor(array: Float32Array);
    constructor(rhs: Matrix4x4);
    constructor(mat33: Matrix3x3);
    constructor(quat: Quaternion);
    clone(): Matrix4x4;
    get m00(): number;
    set m00(v: number);
    get m10(): number;
    set m10(v: number);
    get m20(): number;
    set m20(v: number);
    get m30(): number;
    set m30(v: number);
    get m01(): number;
    set m01(v: number);
    get m11(): number;
    set m11(v: number);
    get m21(): number;
    set m21(v: number);
    get m31(): number;
    set m31(v: number);
    get m02(): number;
    set m02(v: number);
    get m12(): number;
    set m12(v: number);
    get m22(): number;
    set m22(v: number);
    get m32(): number;
    set m32(v: number);
    get m03(): number;
    set m03(v: number);
    get m13(): number;
    set m13(v: number);
    get m23(): number;
    set m23(v: number);
    get m33(): number;
    set m33(v: number);
    getRow(row: number, result?: Vector4): Vector4;
    getRow3(row: number, result?: Vector3): Vector3;
    setRow(row: number, v: IVector4Like): this;
    getCol(col: number, result?: Vector4): Vector4;
    setCol(col: number, v: IVector4Like): this;
    static add(a: Matrix4x4, b: Matrix4x4, result?: Matrix4x4): Matrix4x4;
    static sub(a: Matrix4x4, b: Matrix4x4, result?: Matrix4x4): Matrix4x4;
    static mul(a: Matrix4x4, b: Matrix4x4, result?: Matrix4x4): Matrix4x4;
    static div(a: Matrix4x4, b: Matrix4x4, result?: Matrix4x4): Matrix4x4;
    static scale(a: Matrix4x4, f: number, result?: Matrix4x4): Matrix4x4;
    static identity(result?: Matrix4x4): Matrix4x4;
    static ortho(left: number, right: number, bottom: number, top: number, znear: number, zfar: number, result?: Matrix4x4): Matrix4x4;
    static reflection(nx: number, ny: number, nz: number, d: number, result?: Matrix4x4): Matrix4x4;
    static perspective(fovY: number, aspect: number, znear: number, zfar: number, result?: Matrix4x4): Matrix4x4;
    static perspectiveZ(fovY: number, aspect: number, znear: number, zfar: number, result?: Matrix4x4): Matrix4x4;
    static obliquePerspective(perspectiveMatrix: Matrix4x4, nearPlane: Vector4): Matrix4x4;
    static frustum(left: number, right: number, bottom: number, top: number, znear: number, zfar: number, result?: Matrix4x4): Matrix4x4;
    static frustumZ(left: number, right: number, bottom: number, top: number, znear: number, zfar: number, result?: Matrix4x4): Matrix4x4;
    static transpose(matrix: Matrix4x4, result?: Matrix4x4): Matrix4x4;
    static inverse(matrix: Matrix4x4, result?: Matrix4x4): Matrix4x4;
    static inverseAffine(matrix: Matrix4x4, result?: Matrix4x4): Matrix4x4;
    static translation(t: IVector3Like, result?: Matrix4x4): Matrix4x4;
    static scaling(s: IVector3Like, result?: Matrix4x4): Matrix4x4;
    static rotationX(angle: number, result?: Matrix4x4): Matrix4x4;
    static rotationY(angle: number, result?: Matrix4x4): Matrix4x4;
    static rotationZ(angle: number, result?: Matrix4x4): Matrix4x4;
    static rotation(axis: IVector3Like, angle: number, result?: Matrix4x4): Matrix4x4;
    static lookAt(eye: IVector3Like, target: IVector3Like, up: IVector3Like, result?: Matrix4x4): Matrix4x4;
    static lookAtCubeFace(face: CubeFace, result?: Matrix4x4): Matrix4x4;
    static multiply(m1: Matrix4x4, m2: Matrix4x4, result?: Matrix4x4): Matrix4x4;
    static multiplyAffine(m1: Matrix4x4, m2: Matrix4x4, result?: Matrix4x4): Matrix4x4;
    static translateRight(m: Matrix4x4, t: IVector3Like, result?: Matrix4x4): Matrix4x4;
    static translateLeft(m: Matrix4x4, t: IVector3Like, result?: Matrix4x4): Matrix4x4;
    static scaleRight(m: Matrix4x4, s: IVector3Like, result?: Matrix4x4): Matrix4x4;
    static scaleLeft(m: Matrix4x4, s: IVector3Like, result?: Matrix4x4): Matrix4x4;
    static rotateRight(m: Matrix4x4, r: Matrix3x3 | Matrix4x4 | Quaternion, result?: Matrix4x4): Matrix4x4;
    static rotateLeft(m: Matrix4x4, r: Matrix3x3 | Matrix4x4 | Quaternion, result?: Matrix4x4): Matrix4x4;
    subBy(other: Matrix4x4): Matrix4x4;
    addBy(other: Matrix4x4): Matrix4x4;
    mulBy(other: Matrix4x4): Matrix4x4;
    divBy(other: Matrix4x4): Matrix4x4;
    scaleBy(f: number): Matrix4x4;
    identity(): Matrix4x4;
    perspective(fovY: number, aspect: number, znear: number, zfar: number): Matrix4x4;
    frustum(left: number, right: number, bottom: number, top: number, znear: number, zfar: number): Matrix4x4;
    ortho(left: number, right: number, bottom: number, top: number, znear: number, zfar: number): Matrix4x4;
    isOrtho(): boolean;
    isPerspective(): boolean;
    getNearPlaneWidth(): number;
    getNearPlaneHeight(): number;
    getNearPlane(): number;
    getFarPlaneWidth(): number;
    getFarPlaneHeight(): number;
    getFarPlane(): number;
    getFov(): number;
    getTanHalfFov(): number;
    getAspect(): number;
    setNearFar(znear: number, zfar: number): this;
    translation(t: IVector3Like): Matrix4x4;
    scaling(s: IVector3Like): Matrix4x4;
    inplaceInverse(): Matrix4x4;
    inplaceInverseAffine(): Matrix4x4;
    transpose(): Matrix4x4;
    multiplyRight(other: Matrix4x4): Matrix4x4;
    multiplyRightAffine(other: Matrix4x4): Matrix4x4;
    multiplyLeft(other: Matrix4x4): Matrix4x4;
    multiplyLeftAffine(other: Matrix4x4): Matrix4x4;
    rotationX(angle: number): Matrix4x4;
    rotationY(angle: number): Matrix4x4;
    rotationZ(angle: number): Matrix4x4;
    rotation(axis: IVector3Like, angle: number): Matrix4x4;
    translateRight(t: IVector3Like): Matrix4x4;
    translateLeft(t: IVector3Like): Matrix4x4;
    scaleRight(s: IVector3Like): Matrix4x4;
    scaleLeft(s: IVector3Like): Matrix4x4;
    rotateRight(r: Matrix3x3 | Matrix4x4 | Quaternion): Matrix4x4;
    rotateLeft(r: Matrix3x3 | Matrix4x4 | Quaternion): Matrix4x4;
    lookAt(eye: IVector3Like, target: IVector3Like, up: IVector3Like): Matrix4x4;
    transformPoint(point: IVector3Like, result?: Vector4): Vector4;
    transformPointAffine(point: IVector3Like, result?: Vector3): Vector3;
    transformVector(vec: IVector3Like, result?: Vector4): Vector4;
    transformVectorAffine(vec: IVector3Like, result?: Vector3): Vector3;
    transform(vec: IVector4Like, result?: Vector4): Vector4;
    transformAffine(vec: IVector4Like, result?: Vector4): Vector4;
    det(): number;
    det2(): number;
    decompose(scale?: Vector3, rotation?: Quaternion | Matrix3x3 | Matrix4x4, translation?: Vector3): this;
    decomposeLookAt(eye?: Vector3, target?: Vector3, up?: Vector3): this;
    toDualQuaternion(): {
        real: Quaternion;
        dual: Quaternion;
        scale: Vector3;
    };
    testRotationPart(epsl?: number): boolean;
}
