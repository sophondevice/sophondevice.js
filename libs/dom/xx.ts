// Generated by dts-bundle-generator v6.13.0

declare class Font {
	constructor(name: string, scale: number);
	static fetchFont(name: string, scale: number): Font;
	get fontName(): string;
	set fontName(name: string);
	get fontNameScaled(): string;
	get size(): number;
	get family(): string;
	get top(): number;
	get bottom(): number;
	get maxHeight(): number;
	get topScaled(): number;
	get bottomScaled(): number;
	get maxHeightScaled(): number;
	equalTo(other: Font): boolean;
}
declare class REvent {
	static readonly NONE = 0;
	static readonly CAPTURING_PHASE = 1;
	static readonly AT_TARGET = 2;
	static readonly BUBBLING_PHASE = 3;
	constructor(type: string, canBubble: boolean, cancelable: boolean);
	reset(): void;
	get bubbles(): boolean;
	cancelBubble(): void;
	get cancelable(): boolean;
	get composed(): boolean;
	get currentTarget(): REventTarget;
	get defaultPrevented(): boolean;
	get eventPhase(): number;
	get target(): REventTarget;
	get timeStamp(): number;
	get type(): string;
	get isTrusted(): boolean;
	composedPath(): REventTarget[];
	preventDefault(): void;
	stopImmediatePropagation(): void;
	stopPropagation(): void;
}
export type REventHandler<T extends REvent = REvent> = (evt: T) => void;
export type REventHandlerOptions = {
	capture?: boolean;
	once?: boolean;
	passive?: boolean;
};
export interface REventHandlerObject<T extends REvent = REvent> {
	handleEvent: REventHandler<T>;
}
export type REventListener<T extends REvent = REvent> = REventHandler<T> | REventHandlerObject<T>;
export interface REventPath {
	toArray(): REventTarget[];
}
export interface REventPathBuilder {
	build(node: REventTarget): REventPath;
}
declare class REventTarget {
	constructor(pathBuilder?: REventPathBuilder);
	addEventListener(type: string, listener: REventListener, options?: REventHandlerOptions): void;
	removeEventListener(type: string, listener: REventListener, options?: REventHandlerOptions): void;
	dispatchEvent(evt: REvent): boolean;
	addDefaultEventListener(type: string, listener: REventListener, options?: REventHandlerOptions): void;
	removeDefaultEventListener(type: string, listener: REventListener, options?: REventHandlerOptions): void;
}
export interface RCoord {
	x: number;
	y: number;
}
export interface RColor {
	r: number;
	g: number;
	b: number;
	a: number;
}
export declare class GUIEventPathBuilder implements REventPathBuilder {
	build(node: REventTarget): REventPath;
}
export declare enum NodeType {
	UNKNOWN_NODE = 0,
	ELEMENT_NODE = 1,
	TEXT_NODE = 3,
	DOCUMENT_NODE = 9
}
export type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array;
declare class IterableWrapper implements Iterable<number> {
	protected _v: Float32Array;
	[Symbol.iterator](): Iterator<number>;
	constructor(nOrArray: number | Float32Array);
	get size(): number;
	assign(other: ArrayLike<number>): this;
	getArray(): Float32Array;
	setArray(arr: Float32Array): this;
}
declare class REvent {
	static readonly NONE = 0;
	static readonly CAPTURING_PHASE = 1;
	static readonly AT_TARGET = 2;
	static readonly BUBBLING_PHASE = 3;
	constructor(type: string, canBubble: boolean, cancelable: boolean);
	reset(): void;
	get bubbles(): boolean;
	cancelBubble(): void;
	get cancelable(): boolean;
	get composed(): boolean;
	get currentTarget(): REventTarget;
	get defaultPrevented(): boolean;
	get eventPhase(): number;
	get target(): REventTarget;
	get timeStamp(): number;
	get type(): string;
	get isTrusted(): boolean;
	composedPath(): REventTarget[];
	preventDefault(): void;
	stopImmediatePropagation(): void;
	stopPropagation(): void;
}
export type REventHandler<T extends REvent = REvent> = (evt: T) => void;
export type REventHandlerOptions = {
	capture?: boolean;
	once?: boolean;
	passive?: boolean;
};
export interface REventHandlerObject<T extends REvent = REvent> {
	handleEvent: REventHandler<T>;
}
export type REventListener<T extends REvent = REvent> = REventHandler<T> | REventHandlerObject<T>;
export interface REventPath {
	toArray(): REventTarget[];
}
export interface REventPathBuilder {
	build(node: REventTarget): REventPath;
}
declare class REventTarget {
	constructor(pathBuilder?: REventPathBuilder);
	addEventListener(type: string, listener: REventListener, options?: REventHandlerOptions): void;
	removeEventListener(type: string, listener: REventListener, options?: REventHandlerOptions): void;
	dispatchEvent(evt: REvent): boolean;
	addDefaultEventListener(type: string, listener: REventListener, options?: REventHandlerOptions): void;
	removeDefaultEventListener(type: string, listener: REventListener, options?: REventHandlerOptions): void;
}
declare enum CubeFace {
	PX = 0,
	NX = 1,
	PY = 2,
	NY = 3,
	PZ = 4,
	NZ = 5
}
declare class VectorBase extends IterableWrapper {
	constructor(nOrArray: number | Float32Array);
	getChangeCallback(): () => void;
	setChangeCallback(callback: () => void): void;
	get callbackEnabled(): boolean;
	set callbackEnabled(enabled: boolean);
	changeNotify(): void;
	equalsTo(other: IterableWrapper, epsilon?: number): boolean;
	toString(): string;
	assign(other: ArrayLike<number>): this;
	isNaN(): boolean;
}
export interface IVector2Like {
	x: number;
	y: number;
}
declare class Vector2 extends VectorBase {
	constructor(x: number, y: number);
	constructor(array: number[]);
	constructor(rhs: Vector2);
	constructor(array: Float32Array);
	constructor();
	clone(): Vector2;
	get x(): number;
	set x(v: number);
	setX(v: number): this;
	get y(): number;
	set y(v: number);
	setY(v: number): this;
	get magnitude(): number;
	set magnitude(val: number);
	setMagnitude(val: number): this;
	get magnitudeSq(): number;
	set(x: number, y: number): this;
	setAndNormalize(x: number, y: number): Vector2;
	subBy(other: IVector2Like): Vector2;
	addBy(other: IVector2Like): Vector2;
	mulBy(other: IVector2Like): Vector2;
	divBy(other: IVector2Like): Vector2;
	scaleBy(f: number): Vector2;
	inplaceNormalize(): Vector2;
	inplaceInverse(): Vector2;
	inplaceMin(other: IVector2Like): Vector2;
	inplaceMax(other: IVector2Like): Vector2;
	inplaceAbs(): Vector2;
	static zero(): Vector2;
	static one(): Vector2;
	static axisPX(): Vector2;
	static axisNX(): Vector2;
	static axisPY(): Vector2;
	static axisNY(): Vector2;
	static magnitudeSq(v: IVector2Like): number;
	static magnitude(v: IVector2Like): number;
	static distance(v1: IVector2Like, v2: IVector2Like): number;
	static distanceSq(v1: IVector2Like, v2: IVector2Like): number;
	static normalize(v: IVector2Like, result?: Vector2): Vector2;
	static inverse(v: IVector2Like, result?: Vector2): Vector2;
	static sub(a: IVector2Like, b: IVector2Like, result?: Vector2): Vector2;
	static add(a: IVector2Like, b: IVector2Like, result?: Vector2): Vector2;
	static mul(a: IVector2Like, b: IVector2Like, result?: Vector2): Vector2;
	static div(a: IVector2Like, b: IVector2Like, result?: Vector2): Vector2;
	static scale(a: IVector2Like, b: number, result?: Vector2): Vector2;
	static min(a: IVector2Like, b: IVector2Like, result?: Vector2): Vector2;
	static max(a: IVector2Like, b: IVector2Like, result?: Vector2): Vector2;
	static abs(a: IVector2Like, result?: Vector2): Vector2;
	static dot(a: IVector2Like, b: IVector2Like): number;
	static cross(a: IVector2Like, b: IVector2Like): number;
}
export interface IVector3Like {
	x: number;
	y: number;
	z: number;
}
declare class Vector3 extends VectorBase {
	constructor(x: number, y: number, z: number);
	constructor(array: number[]);
	constructor(rhs: Vector3);
	constructor(array: Float32Array);
	constructor();
	clone(): Vector3;
	get x(): number;
	set x(v: number);
	setX(v: number): this;
	get y(): number;
	set y(v: number);
	setY(v: number): this;
	get z(): number;
	set z(v: number);
	setZ(v: number): this;
	get magnitude(): number;
	set magnitude(val: number);
	setMagnitude(val: number): Vector3;
	get magnitudeSq(): number;
	xy(): Vector2;
	set(x: number, y: number, z: number): Vector3;
	setAndNormalize(x: number, y: number, z: number): Vector3;
	subBy(other: IVector3Like): Vector3;
	addBy(other: IVector3Like): Vector3;
	mulBy(other: IVector3Like): Vector3;
	divBy(other: IVector3Like): Vector3;
	scaleBy(f: number): Vector3;
	crossBy(other: IVector3Like): Vector3;
	inplaceNormalize(): Vector3;
	inplaceInverse(): Vector3;
	inplaceMin(other: IVector3Like): Vector3;
	inplaceMax(other: IVector3Like): Vector3;
	inplaceAbs(): Vector3;
	static zero(): Vector3;
	static one(): Vector3;
	static axisPX(): Vector3;
	static axisNX(): Vector3;
	static axisPY(): Vector3;
	static axisNY(): Vector3;
	static axisPZ(): Vector3;
	static axisNZ(): Vector3;
	static magnitude(v: IVector3Like): number;
	static magnitudeSq(v: IVector3Like): number;
	static distance(v1: IVector3Like, v2: IVector3Like): number;
	static distanceSq(v1: IVector3Like, v2: IVector3Like): number;
	static normalize(v: IVector3Like, result?: Vector3): Vector3;
	static inverse(v: IVector3Like, result?: Vector3): Vector3;
	static sub(a: IVector3Like, b: IVector3Like, result?: Vector3): Vector3;
	static add(a: IVector3Like, b: IVector3Like, result?: Vector3): Vector3;
	static mul(a: IVector3Like, b: IVector3Like, result?: Vector3): Vector3;
	static div(a: IVector3Like, b: IVector3Like, result?: Vector3): Vector3;
	static scale(a: IVector3Like, b: number, result?: Vector3): Vector3;
	static min(a: IVector3Like, b: IVector3Like, result?: Vector3): Vector3;
	static max(a: IVector3Like, b: IVector3Like, result?: Vector3): Vector3;
	static abs(a: IVector3Like, result?: Vector3): Vector3;
	static dot(a: IVector3Like, b: IVector3Like): number;
	static cross(a: IVector3Like, b: IVector3Like, result?: Vector3): Vector3;
}
export interface IVector4Like {
	x: number;
	y: number;
	z: number;
	w: number;
}
declare class Vector4 extends VectorBase {
	constructor(x: number, y: number, z: number, w: number);
	constructor(array: number[]);
	constructor(array: Float32Array);
	constructor(rhs: Vector4);
	constructor(v3: Vector3, w: number);
	constructor();
	clone(): Vector4;
	get x(): number;
	set x(v: number);
	setX(v: number): this;
	get y(): number;
	set y(v: number);
	setY(v: number): this;
	get z(): number;
	set z(v: number);
	setZ(v: number): this;
	get w(): number;
	set w(v: number);
	setW(v: number): this;
	get magnitude(): number;
	set magnitude(val: number);
	setMagnitude(val: number): Vector4;
	get magnitudeSq(): number;
	xy(): Vector2;
	xyz(): Vector3;
	set(x: number, y: number, z: number, w: number): Vector4;
	setAndNormalize(x: number, y: number, z: number, w: number): Vector4;
	subBy(other: IVector4Like): Vector4;
	addBy(other: IVector4Like): Vector4;
	mulBy(other: IVector4Like): Vector4;
	divBy(other: IVector4Like): Vector4;
	scaleBy(f: number): Vector4;
	inplaceNormalize(): Vector4;
	inplaceInverse(): Vector4;
	inplaceMin(other: IVector4Like): Vector4;
	inplaceMax(other: IVector4Like): Vector4;
	inplaceAbs(): Vector4;
	static zero(): Vector4;
	static one(): Vector4;
	static axisPX(): Vector4;
	static axisNX(): Vector4;
	static axisPY(): Vector4;
	static axisNY(): Vector4;
	static axisPZ(): Vector4;
	static axisNZ(): Vector4;
	static axisPW(): Vector4;
	static axisNW(): Vector4;
	static magnitude(v: IVector4Like): number;
	static magnitudeSq(v: IVector4Like): number;
	static normalize(v: IVector4Like, result?: Vector4): Vector4;
	static inverse(v: IVector4Like, result?: Vector4): Vector4;
	static sub(a: IVector4Like, b: IVector4Like, result?: Vector4): Vector4;
	static add(a: IVector4Like, b: IVector4Like, result?: Vector4): Vector4;
	static mul(a: IVector4Like, b: IVector4Like, result?: Vector4): Vector4;
	static div(a: IVector4Like, b: IVector4Like, result?: Vector4): Vector4;
	static scale(a: IVector4Like, b: number, result?: Vector4): Vector4;
	static min(a: IVector4Like, b: IVector4Like, result?: Vector4): Vector4;
	static max(a: IVector4Like, b: IVector4Like, result?: Vector4): Vector4;
	static abs(a: IVector4Like, result?: Vector4): Vector4;
	static dot(a: IVector4Like, b: IVector4Like): number;
}
declare enum TextureTarget {
	Unknown = 0,
	Texture2D = 1,
	Texture3D = 2,
	TextureCubemap = 3,
	Texture2DArray = 4
}
declare enum CompareFunc {
	Unknown = 0,
	Always = 1,
	LessEqual = 2,
	GreaterEqual = 3,
	Less = 4,
	Greater = 5,
	Equal = 6,
	NotEqual = 7,
	Never = 8
}
declare enum TextureWrapping {
	Unknown = 0,
	Repeat = 1,
	MirroredRepeat = 2,
	ClampToEdge = 3
}
declare enum TextureFilter {
	Unknown = 0,
	None = 1,
	Nearest = 2,
	Linear = 3
}
declare enum TextureFormat {
	Unknown = 0,
	R8UNORM,
	R8SNORM,
	R16F,
	R32F,
	R8UI,
	R8I,
	R16UI,
	R16I,
	R32UI,
	R32I,
	RG8UNORM,
	RG8SNORM,
	RG16F,
	RG32F,
	RG8UI,
	RG8I,
	RG16UI,
	RG16I,
	RG32UI,
	RG32I,
	RGBA8UNORM,
	RGBA8UNORM_SRGB,
	RGBA8SNORM,
	BGRA8UNORM,
	BGRA8UNORM_SRGB,
	RGBA16F,
	RGBA32F,
	RGBA8UI,
	RGBA8I,
	RGBA16UI,
	RGBA16I,
	RGBA32UI,
	RGBA32I,
	D16,
	D24,
	D32F,
	D24S8,
	D32FS8,
	DXT1,
	DXT1_SRGB,
	DXT3,
	DXT3_SRGB,
	DXT5,
	DXT5_SRGB
}
declare enum PrimitiveType {
	Unknown = -1,
	TriangleList = 0,
	TriangleStrip = 1,
	TriangleFan = 2,
	LineList = 3,
	LineStrip = 4,
	PointList = 5
}
declare enum ShaderType {
	Vertex = 1,
	Fragment = 2,
	Compute = 4
}
export interface ITimer {
	begin(): void;
	end(): void;
	ended(): boolean;
	elapsed(): number;
}
declare class CPUTimer implements ITimer {
	private _cpuTimer;
	private _cpuStart;
	private _cpuTime;
	private _ended;
	constructor();
	now(): number;
	begin(): void;
	end(): void;
	ended(): boolean;
	elapsed(): number;
}
export interface ColorState {
	redMask: boolean;
	greenMask: boolean;
	blueMask: boolean;
	alphaMask: boolean;
	setColorMask(r: boolean, g: boolean, b: boolean, a: boolean): this;
}
declare enum BlendEquation {
	ADD = 1,
	SUBTRACT = 2,
	REVERSE_SUBTRACT = 3,
	MIN = 4,
	MAX = 5
}
declare enum BlendFunc {
	ZERO = 1,
	ONE = 2,
	SRC_ALPHA = 3,
	INV_SRC_ALPHA = 4,
	SRC_ALPHA_SATURATE = 5,
	DST_ALPHA = 6,
	INV_DST_ALPHA = 7,
	SRC_COLOR = 8,
	INV_SRC_COLOR = 9,
	DST_COLOR = 10,
	INV_DST_COLOR = 11,
	CONSTANT_COLOR = 12,
	INV_CONSTANT_COLOR = 13,
	CONSTANT_ALPHA = 14,
	INV_CONSTANT_ALPHA = 15
}
export interface BlendingState {
	enabled: boolean;
	srcBlendRGB: BlendFunc;
	dstBlendRGB: BlendFunc;
	srcBlendAlpha: BlendFunc;
	dstBlendAlpha: BlendFunc;
	rgbEquation: BlendEquation;
	alphaEquation: BlendEquation;
	enable(b: boolean): this;
	setBlendFunc(src: BlendFunc, dest: BlendFunc): this;
	setBlendFuncRGB(src: BlendFunc, dest: BlendFunc): this;
	setBlendFuncAlpha(src: BlendFunc, dest: BlendFunc): this;
	setBlendEquation(rgb: BlendEquation, alpha: BlendEquation): this;
}
declare enum FaceMode {
	NONE = 1,
	FRONT = 2,
	BACK = 3
}
export interface RasterizerState {
	cullMode: FaceMode;
	setCullMode(mode: FaceMode): this;
}
export interface DepthState {
	testEnabled: boolean;
	writeEnabled: boolean;
	compareFunc: CompareFunc;
	enableTest(b: boolean): this;
	enableWrite(b: boolean): this;
	setCompareFunc(func: CompareFunc): this;
}
declare enum StencilOp {
	KEEP = 1,
	ZERO = 2,
	REPLACE = 3,
	INCR = 4,
	INCR_WRAP = 5,
	DECR = 6,
	DECR_WRAP = 7,
	INVERT = 8
}
export interface StencilState {
	enabled: boolean;
	enableTwoSided: boolean;
	writeMask: number;
	writeMaskBack: number;
	failOp: StencilOp;
	failOpBack: StencilOp;
	zFailOp: StencilOp;
	zFailOpBack: StencilOp;
	passOp: StencilOp;
	passOpBack: StencilOp;
	func: CompareFunc;
	funcBack: CompareFunc;
	ref: number;
	valueMask: number;
	valueMaskBack: number;
	enable(b: boolean): this;
	enableStencilTwoside(b: boolean): this;
	setFrontWriteMask(mask: number): this;
	setBackWriteMask(mask: number): this;
	setFrontOp(fail: StencilOp, zfail: StencilOp, pass: StencilOp): this;
	setBackOp(fail: StencilOp, zfail: StencilOp, pass: StencilOp): this;
	setFrontCompareFunc(func: CompareFunc): this;
	setBackCompareFunc(func: CompareFunc): this;
	setReference(ref: number): this;
	setFrontValueMask(mask: number): this;
	setBackValueMask(mask: number): this;
}
export interface RenderStateSet {
	readonly colorState: ColorState;
	readonly blendingState: BlendingState;
	readonly rasterizerState: RasterizerState;
	readonly depthState: DepthState;
	readonly stencilState: StencilState;
	useColorState(): ColorState;
	defaultColorState(): void;
	useBlendingState(): BlendingState;
	defaultBlendingState(): void;
	useRasterizerState(): RasterizerState;
	defaultRasterizerState(): void;
	useDepthState(): DepthState;
	defaultDepthState(): void;
	useStencilState(): StencilState;
	defaultStencilState(): void;
	apply(overridden: RenderStateSet, force?: boolean): void;
}
export interface ILayoutableType {
	getLayoutAlignment(layout: PBStructLayout): number;
	getLayoutSize(layout: PBStructLayout): number;
}
export type PBStructLayout = "default" | "std140" | "packed";
declare enum PBPrimitiveType {
	NONE = 0,
	F16,
	F16VEC2,
	F16VEC3,
	F16VEC4,
	F32,
	F32VEC2,
	F32VEC3,
	F32VEC4,
	BOOL,
	BVEC2,
	BVEC3,
	BVEC4,
	I8,
	I8VEC2,
	I8VEC3,
	I8VEC4,
	I8_NORM,
	I8VEC2_NORM,
	I8VEC3_NORM,
	I8VEC4_NORM,
	I16,
	I16VEC2,
	I16VEC3,
	I16VEC4,
	I16_NORM,
	I16VEC2_NORM,
	I16VEC3_NORM,
	I16VEC4_NORM,
	I32,
	I32VEC2,
	I32VEC3,
	I32VEC4,
	I32_NORM,
	I32VEC2_NORM,
	I32VEC3_NORM,
	I32VEC4_NORM,
	U8,
	U8VEC2,
	U8VEC3,
	U8VEC4,
	U8_NORM,
	U8VEC2_NORM,
	U8VEC3_NORM,
	U8VEC4_NORM,
	U16,
	U16VEC2,
	U16VEC3,
	U16VEC4,
	U16_NORM,
	U16VEC2_NORM,
	U16VEC3_NORM,
	U16VEC4_NORM,
	U32,
	U32VEC2,
	U32VEC3,
	U32VEC4,
	U32_NORM,
	U32VEC2_NORM,
	U32VEC3_NORM,
	U32VEC4_NORM,
	MAT2,
	MAT2x3,
	MAT2x4,
	MAT3x2,
	MAT3,
	MAT3x4,
	MAT4x2,
	MAT4x3,
	MAT4
}
declare enum PBTextureType {
	TEX_1D,
	ITEX_1D,
	UTEX_1D,
	TEX_2D,
	ITEX_2D,
	UTEX_2D,
	TEX_2D_ARRAY,
	ITEX_2D_ARRAY,
	UTEX_2D_ARRAY,
	TEX_3D,
	ITEX_3D,
	UTEX_3D,
	TEX_CUBE,
	ITEX_CUBE,
	UTEX_CUBE,
	TEX_CUBE_ARRAY,
	ITEX_CUBE_ARRAY,
	UTEX_CUBE_ARRAY,
	TEX_MULTISAMPLED_2D,
	ITEX_MULTISAMPLED_2D,
	UTEX_MULTISAMPLED_2D,
	TEX_STORAGE_1D,
	TEX_STORAGE_2D,
	TEX_STORAGE_2D_ARRAY,
	TEX_STORAGE_3D,
	TEX_DEPTH_2D,
	TEX_DEPTH_2D_ARRAY,
	TEX_DEPTH_CUBE,
	TEX_DEPTH_CUBE_ARRAY,
	TEX_DEPTH_MULTISAMPLED_2D,
	TEX_EXTERNAL
}
declare enum PBSamplerAccessMode {
	UNKNOWN = 0,
	SAMPLE = 1,
	COMPARISON = 2
}
declare enum PBAddressSpace {
	UNKNOWN = "unknown",
	FUNCTION = "function",
	PRIVATE = "private",
	WORKGROUP = "workgroup",
	UNIFORM = "uniform",
	STORAGE = "storage"
}
declare enum PBTypeClass {
	UNKNOWN = 0,
	PLAIN = 1,
	ARRAY = 2,
	POINTER = 3,
	ATOMIC = 4,
	TEXTURE = 5,
	SAMPLER = 6,
	FUNCTION = 7,
	VOID = 8
}
export type TypeInfo = PrimitiveTypeDetail | StructTypeDetail | ArrayTypeDetail | PointerTypeDetail | AtomicTypeInfoDetail | SamplerTypeDetail | TextureTypeDetail | FunctionTypeDetail | null;
export interface PrimitiveTypeDetail {
	primitiveType?: PBPrimitiveType;
}
export interface StructTypeDetail {
	layout: PBStructLayout;
	structName?: string;
	structMembers?: {
		name: string;
		type: PBPrimitiveTypeInfo | PBArrayTypeInfo | PBStructTypeInfo;
		alignment: number;
		size: number;
		defaultAlignment: number;
		defaultSize: number;
	}[];
}
export interface ArrayTypeDetail {
	elementType: PBPrimitiveTypeInfo | PBArrayTypeInfo | PBStructTypeInfo;
	dimension: number;
}
export interface PointerTypeDetail {
	pointerType: PBTypeInfo;
	addressSpace: PBAddressSpace;
}
export interface AtomicTypeInfoDetail {
	type: PBPrimitiveType;
}
export interface SamplerTypeDetail {
	accessMode: PBSamplerAccessMode;
}
export interface TextureTypeDetail {
	textureType: PBTextureType;
	storageTexelFormat: TextureFormat;
	readable: boolean;
	writable: boolean;
}
export interface FunctionTypeDetail {
	name: string;
	returnType: PBTypeInfo;
	argTypes: {
		type: PBTypeInfo;
		byRef?: boolean;
	}[];
}
declare abstract class PBTypeInfo<DetailType extends TypeInfo = TypeInfo> {
	constructor(cls: PBTypeClass, detail: DetailType);
	get typeId(): string;
	isVoidType(): this is PBVoidTypeInfo;
	isPrimitiveType(): this is PBPrimitiveTypeInfo;
	isStructType(): this is PBStructTypeInfo;
	isArrayType(): this is PBArrayTypeInfo;
	isPointerType(): this is PBPointerTypeInfo;
	isAtomicType(): this is PBAtomicTypeInfo;
	isSamplerType(): this is PBSamplerTypeInfo;
	isTextureType(): this is PBTextureTypeInfo;
	isHostSharable(): boolean;
	isConstructible(): boolean;
	isStorable(): boolean;
	getConstructorOverloads(deviceType: DeviceType): PBFunctionTypeInfo[];
	abstract toBufferLayout(offset: number, layout: PBStructLayout): UniformBufferLayout;
	abstract toTypeName(deviceType: DeviceType, varName?: string): string;
}
declare class PBVoidTypeInfo extends PBTypeInfo<null> {
	constructor();
	isVoidType(): this is PBVoidTypeInfo;
	toTypeName(deviceType: DeviceType, varName?: string): string;
	toBufferLayout(offset: number): UniformBufferLayout;
}
declare class PBPrimitiveTypeInfo extends PBTypeInfo<PrimitiveTypeDetail> implements ILayoutableType {
	constructor(type: PBPrimitiveType);
	static getCachedTypeInfo(primitiveType: PBPrimitiveType): PBPrimitiveTypeInfo;
	static getCachedOverloads(deviceType: DeviceType, primitiveType: PBPrimitiveType): PBFunctionTypeInfo[];
	get primitiveType(): PBPrimitiveType;
	get scalarType(): PBPrimitiveType;
	get rows(): number;
	get cols(): number;
	get normalized(): boolean;
	getLayoutAlignment(layout: PBStructLayout): number;
	getLayoutSize(): number;
	getSize(): number;
	resizeType(rows: number, cols: number): PBPrimitiveType;
	isScalarType(): boolean;
	isVectorType(): boolean;
	isMatrixType(): boolean;
	isPrimitiveType(): this is PBPrimitiveTypeInfo;
	isHostSharable(): boolean;
	isConstructible(): boolean;
	isStorable(): boolean;
	getConstructorOverloads(deviceType: DeviceType): PBFunctionTypeInfo[];
	toTypeName(deviceType: DeviceType, varName?: string): string;
	toBufferLayout(offset: number): UniformBufferLayout;
}
declare class PBStructTypeInfo extends PBTypeInfo<StructTypeDetail> implements ILayoutableType {
	constructor(name: string, layout: PBStructLayout, members: {
		name: string;
		type: PBPrimitiveTypeInfo | PBArrayTypeInfo | PBStructTypeInfo;
	}[]);
	get layout(): PBStructLayout;
	get structName(): string;
	set structName(val: string);
	get structMembers(): {
		name: string;
		type: PBPrimitiveTypeInfo | PBArrayTypeInfo | PBStructTypeInfo;
		alignment: number;
		size: number;
		defaultAlignment: number;
		defaultSize: number;
	}[];
	extends(name: string, members: {
		name: string;
		type: PBPrimitiveTypeInfo | PBArrayTypeInfo | PBStructTypeInfo;
	}[]): PBStructTypeInfo;
	isStructType(): this is PBStructTypeInfo;
	isHostSharable(): boolean;
	isConstructible(): boolean;
	isStorable(): boolean;
	getConstructorOverloads(): PBFunctionTypeInfo[];
	toTypeName(deviceType: DeviceType, varName?: string): string;
	getLayoutAlignment(layout: PBStructLayout): number;
	getLayoutSize(layout: PBStructLayout): number;
	toBufferLayout(offset: number, layout: PBStructLayout): UniformBufferLayout;
	clone(newName?: string): PBStructTypeInfo;
	reset(name: string, layout: PBStructLayout, members: {
		name: string;
		type: PBPrimitiveTypeInfo | PBArrayTypeInfo | PBStructTypeInfo;
	}[]): void;
}
declare class PBArrayTypeInfo extends PBTypeInfo<ArrayTypeDetail> implements ILayoutableType {
	constructor(elementType: PBPrimitiveTypeInfo | PBArrayTypeInfo | PBStructTypeInfo, dimension?: number);
	get elementType(): PBPrimitiveTypeInfo | PBArrayTypeInfo | PBStructTypeInfo;
	get dimension(): number;
	isArrayType(): this is PBArrayTypeInfo;
	isHostSharable(): boolean;
	isConstructible(): boolean;
	isStorable(): boolean;
	getConstructorOverloads(deviceType: DeviceType): PBFunctionTypeInfo[];
	toTypeName(deviceType: DeviceType, varName?: string): string;
	getLayoutAlignment(layout: PBStructLayout): number;
	getLayoutSize(layout: PBStructLayout): number;
	toBufferLayout(offset: number): UniformBufferLayout;
}
declare class PBPointerTypeInfo extends PBTypeInfo<PointerTypeDetail> {
	constructor(pointerType: PBTypeInfo, addressSpace: PBAddressSpace);
	get pointerType(): PBTypeInfo;
	get addressSpace(): PBAddressSpace;
	set addressSpace(val: PBAddressSpace);
	isPointerType(): this is PBPointerTypeInfo;
	toTypeName(device: DeviceType, varName?: string): string;
	toBufferLayout(offset: number): UniformBufferLayout;
}
declare class PBAtomicTypeInfo extends PBTypeInfo<AtomicTypeInfoDetail> {
	constructor(type: PBPrimitiveType);
	get type(): PBPrimitiveType;
	isAtomicType(): this is PBAtomicTypeInfo;
	isHostSharable(): boolean;
	isStorable(): boolean;
	toTypeName(deviceType: DeviceType, varName?: string): string;
	toBufferLayout(offset: number): UniformBufferLayout;
}
declare class PBSamplerTypeInfo extends PBTypeInfo<SamplerTypeDetail> {
	constructor(accessMode: PBSamplerAccessMode);
	get accessMode(): PBSamplerAccessMode;
	isSamplerType(): this is PBSamplerTypeInfo;
	isStorable(): boolean;
	toTypeName(deviceType: DeviceType, varName?: string): string;
	toBufferLayout(offset: number): UniformBufferLayout;
}
declare class PBTextureTypeInfo extends PBTypeInfo<TextureTypeDetail> {
	constructor(textureType: PBTextureType, texelFormat?: TextureFormat, readable?: boolean, writable?: boolean);
	get textureType(): PBTextureType;
	get storageTexelFormat(): TextureFormat;
	get readable(): boolean;
	get writable(): boolean;
	isStorable(): boolean;
	is1DTexture(): boolean;
	is2DTexture(): boolean;
	is3DTexture(): boolean;
	isCubeTexture(): boolean;
	isArrayTexture(): boolean;
	isStorageTexture(): boolean;
	isDepthTexture(): boolean;
	isMultisampledTexture(): boolean;
	isExternalTexture(): boolean;
	isIntTexture(): boolean;
	isUIntTexture(): boolean;
	isTextureType(): this is PBTextureTypeInfo;
	toTypeName(deviceType: DeviceType, varName?: string): string;
	toBufferLayout(offset: number): UniformBufferLayout;
}
declare class PBFunctionTypeInfo extends PBTypeInfo<FunctionTypeDetail> {
	constructor(name: string, returnType: PBTypeInfo, argTypes: {
		type: PBTypeInfo;
		byRef?: boolean;
	}[]);
	get name(): string;
	get returnType(): PBTypeInfo;
	get argTypes(): {
		type: PBTypeInfo;
		byRef?: boolean;
	}[];
	toBufferLayout(offset: number): UniformBufferLayout;
	toTypeName(deviceType: DeviceType, varName?: string): string;
}
export interface GPUObjectList {
	textures: BaseTexture[];
	samplers: TextureSampler[];
	buffers: GPUDataBuffer[];
	programs: GPUProgram[];
	framebuffers: FrameBuffer[];
	vertexArrayObjects: VertexInputLayout[];
	bindGroups: BindGroup[];
}
export interface FramebufferCaps {
	maxDrawBuffers: number;
	supportDrawBuffers: boolean;
	supportRenderMipmap: boolean;
}
export interface MiscCaps {
	supportBlendMinMax: boolean;
	support32BitIndex: boolean;
	supportLoseContext: boolean;
	supportDebugRendererInfo: boolean;
	supportSharedUniforms: boolean;
}
export interface ShaderCaps {
	supportFragmentDepth: boolean;
	supportStandardDerivatives: boolean;
	supportShaderTextureLod: boolean;
	supportHighPrecisionFloat: boolean;
	supportHighPrecisionInt: boolean;
	maxUniformBufferSize: number;
	uniformBufferOffsetAlignment: number;
}
export interface ITextureFormatInfo {
	filterable: boolean;
	renderable: boolean;
	compressed: boolean;
}
export interface TextureCaps {
	maxTextureSize: number;
	maxCubeTextureSize: number;
	npo2Mipmapping: boolean;
	npo2Repeating: boolean;
	supportS3TC: boolean;
	supportS3TCSRGB: boolean;
	supportDepthTexture: boolean;
	support3DTexture: boolean;
	supportSRGBTexture: boolean;
	supportFloatTexture: boolean;
	supportLinearFloatTexture: boolean;
	supportHalfFloatTexture: boolean;
	supportLinearHalfFloatTexture: boolean;
	supportAnisotropicFiltering: boolean;
	supportFloatColorBuffer: boolean;
	supportHalfFloatColorBuffer: boolean;
	supportFloatBlending: boolean;
	getTextureFormatInfo(format: TextureFormat): ITextureFormatInfo;
}
export type DeviceTypeWebGL = "webgl" | "webgl2";
export type DeviceTypeWebGPU = "webgpu";
export type DeviceType = DeviceTypeWebGL | DeviceTypeWebGPU;
export interface RenderProgramConstructParams {
	vs: string;
	fs: string;
	bindGroupLayouts: BindGroupLayout[];
	vertexAttributes: number[];
}
export interface ComputeProgramConstructParams {
	source: string;
	bindGroupLayouts: BindGroupLayout[];
}
export interface GPUProgramConstructParams {
	type: "render" | "compute";
	label?: string;
	params: RenderProgramConstructParams | ComputeProgramConstructParams;
}
declare class DeviceFrameBegin extends REvent {
	static readonly NAME = "framebegin";
	device: Device;
	constructor(device: Device);
}
declare class DeviceFrameEnd extends REvent {
	static readonly NAME = "frameend";
	device: Device;
	constructor(device: Device);
}
export interface FrameInfo {
	frameCounter: number;
	frameTimestamp: number;
	elapsedTimeCPU: number;
	elapsedTimeGPU: number;
	elapsedFrame: number;
	elapsedOverall: number;
	FPS: number;
	drawCalls: number;
	computeCalls: number;
	nextFrameCall: (() => void)[];
}
declare abstract class Device extends REventTarget {
	protected _gpuMemCost: number;
	protected _disposeObjectList: GPUObject[];
	protected _beginFrameTime: number;
	protected _endFrameTime: number;
	protected _frameInfo: FrameInfo;
	protected _cpuTimer: CPUTimer;
	protected _gpuTimer: ITimer;
	protected _runningLoop: number;
	protected _frameBeginEvent: DeviceFrameBegin;
	protected _frameEndEvent: DeviceFrameEnd;
	protected _fpsCounter: {
		time: number;
		frame: number;
	};
	protected _runLoopFunc: (device: Device) => void;
	constructor();
	abstract getDeviceType(): DeviceType;
	abstract getCanvas(): HTMLCanvasElement;
	abstract isContextLost(): boolean;
	abstract getScale(): number;
	abstract getDrawingBufferWidth(): number;
	abstract getDrawingBufferHeight(): number;
	abstract getBackBufferWidth(): number;
	abstract getBackBufferHeight(): number;
	abstract getTextureCaps(): TextureCaps;
	abstract getFramebufferCaps(): FramebufferCaps;
	abstract getMiscCaps(): MiscCaps;
	abstract getShaderCaps(): ShaderCaps;
	abstract initContext(): Promise<void>;
	abstract clearFrameBuffer(clearColor: Vector4, clearDepth: number, clearStencil: number): any;
	abstract createGPUTimer(): ITimer;
	abstract createRenderStateSet(): RenderStateSet;
	abstract createSampler(options: SamplerOptions): TextureSampler;
	abstract createTexture2D(format: TextureFormat, width: number, height: number, creationFlags?: number): Texture2D;
	abstract createTexture2DFromMipmapData(data: TextureMipmapData, creationFlags?: number): Texture2D;
	abstract createTexture2DFromImage(element: TextureImageElement, creationFlags?: number): Texture2D;
	abstract loadTexture2DFromURL(url: string, mimeType?: string, creationFlags?: number): Promise<Texture2D>;
	abstract createTexture2DArray(format: TextureFormat, width: number, height: number, depth: number, creationFlags?: number): Texture2DArray;
	abstract createTexture3D(format: TextureFormat, width: number, height: number, depth: number, creationFlags?: number): Texture3D;
	abstract createCubeTexture(format: TextureFormat, size: number, creationFlags?: number): TextureCube;
	abstract createCubeTextureFromMipmapData(data: TextureMipmapData, creationFlags?: number): TextureCube;
	abstract loadCubeTextureFromURL(url: string, mimeType?: string, creationFlags?: number): Promise<TextureCube>;
	abstract createTextureVideo(el: HTMLVideoElement): TextureVideo;
	abstract reverseVertexWindingOrder(reverse: boolean): void;
	abstract isWindingOrderReversed(): boolean;
	abstract setRenderStatesOverridden(renderStates: RenderStateSet): any;
	abstract createGPUProgram(params: GPUProgramConstructParams): GPUProgram;
	abstract createBindGroup(layout: BindGroupLayout): BindGroup;
	abstract createBuffer(sizeInBytes: number, usage?: number): GPUDataBuffer;
	abstract createIndexBuffer(data: Uint16Array | Uint32Array, usage?: number): IndexBuffer;
	abstract createStructuredBuffer(structureType: PBStructTypeInfo, usage: number, data?: TypedArray): StructuredBuffer;
	abstract createVAO(vertexData: VertexData): VertexInputLayout;
	abstract createFrameBuffer(options?: IFrameBufferOptions): FrameBuffer;
	abstract setViewport(vp?: number[]): number[];
	abstract setViewport(x: number, y: number, w: number, h: number): void;
	abstract getViewport(): number[];
	abstract setScissor(scissor?: number[]): number[];
	abstract setScissor(x: number, y: number, w: number, h: number): void;
	abstract getScissor(): number[];
	abstract setProgram(program: GPUProgram): void;
	abstract getProgram(): GPUProgram;
	abstract setVertexData(vertexData: VertexInputLayout): void;
	abstract getVertexData(): VertexInputLayout;
	abstract setRenderStates(renderStates: RenderStateSet): void;
	abstract getRenderStates(): RenderStateSet;
	abstract setFramebuffer(rt: FrameBuffer): void;
	abstract getFramebuffer(): FrameBuffer;
	abstract setBindGroup(index: number, bindGroup: BindGroup, dynamicOffsets?: Iterable<number>): any;
	abstract flush(): void;
	abstract readPixels(x: number, y: number, w: number, h: number, buffer: TypedArray): Promise<void>;
	abstract readPixelsToBuffer(x: number, y: number, w: number, h: number, buffer: GPUDataBuffer): void;
	abstract looseContext(): void;
	abstract restoreContext(): void;
	protected abstract _draw(primitiveType: PrimitiveType, first: number, count: number): void;
	protected abstract _drawInstanced(primitiveType: PrimitiveType, first: number, count: number, numInstances: number): void;
	protected abstract _compute(workgroupCountX: any, workgroupCountY: any, workgroupCountZ: any): void;
	get videoMemoryUsage(): number;
	get frameInfo(): FrameInfo;
	get isRendering(): boolean;
	disposeObject(obj: GPUObject, remove?: boolean): void;
	restoreObject(obj: GPUObject): Promise<void>;
	enableGPUTimeRecording(enable: boolean): void;
	beginFrame(): boolean;
	endFrame(): void;
	draw(primitiveType: PrimitiveType, first: number, count: number): void;
	drawInstanced(primitiveType: PrimitiveType, first: number, count: number, numInstances: number): void;
	compute(workgroupCountX: any, workgroupCountY: any, workgroupCountZ: any): void;
	runNextFrame(f: () => void): void;
	cancelNextFrameCall(f: () => void): void;
	exitLoop(): void;
	runLoop(func: (device: Device) => void): void;
	getGPUObjects(): GPUObjectList;
	getGPUObjectById(uid: number): GPUObject;
	screenToDevice(val: number): number;
	deviceToScreen(val: number): number;
}
export type TextureImageElement = ImageBitmap | HTMLCanvasElement;
export type VertexStepMode = "vertex" | "instance";
export interface TextureMipmapLevelData {
	data: TypedArray;
	width: number;
	height: number;
}
export interface TextureMipmapData {
	width: number;
	height: number;
	depth: number;
	isCubemap: boolean;
	isVolume: boolean;
	isCompressed: boolean;
	arraySize: number;
	mipLevels: number;
	format: TextureFormat;
	mipDatas: TextureMipmapLevelData[][];
}
export interface IFrameBufferTextureAttachment {
	texture?: BaseTexture;
	face?: number;
	layer?: number;
	level?: number;
}
export interface IFrameBufferOptions {
	colorAttachments?: IFrameBufferTextureAttachment[];
	depthAttachment?: IFrameBufferTextureAttachment;
}
export interface UniformBufferLayout {
	byteSize: number;
	entries: UniformLayout[];
}
export interface UniformLayout {
	name: string;
	offset: number;
	byteSize: number;
	arraySize: number;
	type: PBPrimitiveType;
	subLayout: UniformBufferLayout;
}
export interface BufferBindingLayout {
	type?: "uniform" | "storage" | "read-only-storage";
	hasDynamicOffset: boolean;
	uniformLayout: UniformBufferLayout;
	minBindingSize?: number;
}
export interface SamplerBindingLayout {
	type: "filtering" | "non-filtering" | "comparison";
}
export interface TextureBindingLayout {
	sampleType: "float" | "unfilterable-float" | "depth" | "sint" | "uint";
	viewDimension: "1d" | "2d" | "2d-array" | "cube" | "cube-array" | "3d";
	multisampled: boolean;
	autoBindSampler: string;
	autoBindSamplerComparison: string;
}
export interface StorageTextureBindingLayout {
	access: "write-only";
	format: TextureFormat;
	viewDimension: "1d" | "2d";
}
export interface ExternalTextureBindingLayout {
	autoBindSampler: string;
}
export interface BindGroupLayoutEntry {
	binding: number;
	name: string;
	visibility: number;
	type: PBTypeInfo;
	buffer?: BufferBindingLayout;
	sampler?: SamplerBindingLayout;
	texture?: TextureBindingLayout;
	storageTexture?: StorageTextureBindingLayout;
	externalTexture?: ExternalTextureBindingLayout;
}
export interface BindGroupLayout {
	label?: string;
	nameMap?: {
		[name: string]: string;
	};
	entries: BindGroupLayoutEntry[];
}
export interface BindPointInfo {
	group: number;
	binding: number;
	type: PBTypeInfo;
}
export interface SamplerOptions {
	addressU?: TextureWrapping;
	addressV?: TextureWrapping;
	addressW?: TextureWrapping;
	magFilter?: TextureFilter;
	minFilter?: TextureFilter;
	mipFilter?: TextureFilter;
	lodMin?: number;
	lodMax?: number;
	compare?: CompareFunc;
	maxAnisotropy?: number;
}
export interface GPUObject<T = unknown> {
	readonly device: Device;
	readonly object: T;
	readonly uid: number;
	readonly cid: number;
	readonly disposed: boolean;
	name: string;
	restoreHandler: (tex: GPUObject) => Promise<void>;
	isVAO(): this is VertexInputLayout;
	isFramebuffer(): this is FrameBuffer;
	isSampler(): this is TextureSampler;
	isTexture(): this is BaseTexture;
	isTexture2D(): this is Texture2D;
	isTexture2DArray(): this is Texture2DArray;
	isTexture3D(): this is Texture3D;
	isTextureCube(): this is TextureCube;
	isTextureVideo(): this is TextureVideo;
	isProgram(): this is GPUProgram;
	isBuffer(): this is GPUDataBuffer;
	isBindGroup(): this is BindGroup;
	dispose(): void;
	reload(): Promise<void>;
	destroy(): void;
	restore(): Promise<void>;
}
export interface TextureSampler<T = unknown> extends GPUObject<T> {
	readonly addressModeU: TextureWrapping;
	readonly addressModeV: TextureWrapping;
	readonly addressModeW: TextureWrapping;
	readonly magFilter: TextureFilter;
	readonly minFilter: TextureFilter;
	readonly mipFilter: TextureFilter;
	readonly lodMin: number;
	readonly lodMax: number;
	readonly compare: CompareFunc;
	readonly maxAnisotropy: number;
}
export interface BaseTexture<T = unknown> extends GPUObject<T> {
	readonly target: TextureTarget;
	readonly linearColorSpace: boolean;
	readonly width: number;
	readonly height: number;
	readonly depth: number;
	readonly format: TextureFormat;
	readonly mipLevelCount: number;
	init(): void;
	generateMipmaps(): void;
	isFloatFormat(): boolean;
	isIntegerFormat(): boolean;
	isSignedFormat(): boolean;
	isCompressedFormat(): boolean;
	isFilterable(): boolean;
	isDepth(): boolean;
	getDefaultSampler(comparison: boolean): TextureSampler;
}
export interface Texture2D<T = unknown> extends BaseTexture<T> {
	update(data: TypedArray, xOffset: number, yOffset: number, width: number, height: number): void;
	updateFromElement(data: TextureImageElement, xOffset: number, yOffset: number, x: number, y: number, width: number, height: number): void;
	loadFromElement(element: TextureImageElement, creationFlags?: number): void;
	createWithMipmapData(data: TextureMipmapData, creationFlags?: number): void;
	readPixels(x: number, y: number, w: number, h: number, buffer: TypedArray): Promise<void>;
	readPixelsToBuffer(x: number, y: number, w: number, h: number, buffer: GPUDataBuffer): void;
}
export interface Texture2DArray<T = unknown> extends BaseTexture<T> {
	update(data: TypedArray, xOffset: number, yOffset: number, zOffset: number, width: number, height: number, depth: number): void;
	updateFromElement(data: TextureImageElement, xOffset: number, yOffset: number, layerIndex: number, x: number, y: number, width: number, height: number): void;
	readPixels(layer: number, x: number, y: number, w: number, h: number, buffer: TypedArray): Promise<void>;
	readPixelsToBuffer(layer: number, x: number, y: number, w: number, h: number, buffer: GPUDataBuffer): void;
}
export interface Texture3D<T = unknown> extends BaseTexture<T> {
	update(data: TypedArray, xOffset: number, yOffset: number, zOffset: number, width: number, height: number, depth: number): void;
	readPixels(layer: number, x: number, y: number, w: number, h: number, buffer: TypedArray): Promise<void>;
	readPixelsToBuffer(layer: number, x: number, y: number, w: number, h: number, buffer: GPUDataBuffer): void;
}
export interface TextureCube<T = unknown> extends BaseTexture<T> {
	update(data: TypedArray, xOffset: number, yOffset: number, width: number, height: number, face: CubeFace): void;
	updateFromElement(data: TextureImageElement, xOffset: number, yOffset: number, face: number, x: number, y: number, width: number, height: number): void;
	createWithMipmapData(data: TextureMipmapData, creationFlags?: number): void;
	readPixels(face: number, x: number, y: number, w: number, h: number, buffer: TypedArray): Promise<void>;
	readPixelsToBuffer(face: number, x: number, y: number, w: number, h: number, buffer: GPUDataBuffer): void;
}
export interface TextureVideo<T = unknown> extends BaseTexture<T> {
	readonly source: HTMLVideoElement;
	updateVideoFrame(): boolean;
}
export interface GPUDataBuffer<T = unknown> extends GPUObject<T> {
	readonly byteLength: number;
	readonly usage: number;
	bufferSubData(dstByteOffset: number, data: TypedArray, srcOffset?: number, srcLength?: number): void;
	getBufferSubData(dstBuffer?: Uint8Array, offsetInBytes?: number, sizeInBytes?: number): Promise<Uint8Array>;
}
export interface IndexBuffer<T = unknown> extends GPUDataBuffer<T> {
	readonly indexType: PBPrimitiveTypeInfo;
	readonly length: number;
}
export interface StructuredBuffer<T = unknown> extends GPUDataBuffer<T> {
	structure: PBStructTypeInfo;
	set(name: string, value: StructuredValue): any;
}
export interface VertexInputLayout<T = unknown> extends GPUObject<T> {
	readonly vertexBuffers: {
		[semantic: number]: {
			buffer: GPUDataBuffer;
			offset: number;
		};
	};
	readonly indexBuffer: IndexBuffer;
	getDrawOffset(): number;
	getVertexBuffer(location: number): StructuredBuffer;
	getIndexBuffer(): IndexBuffer;
	bind(): void;
	draw(primitiveType: PrimitiveType, first: number, count: number): void;
	drawInstanced(primitiveType: PrimitiveType, first: number, count: number, numInstances: number): any;
}
export interface FrameBuffer<T = unknown> extends GPUObject<T> {
	getViewport(): number[];
	setViewport(vp: number[]): void;
	getWidth(): number;
	getHeight(): number;
	getSampleCount(): number;
	setCubeTextureFace(index: number, face: CubeFace): void;
	setTextureLevel(index: number, level: number): void;
	setTextureLayer(index: number, layer: number): void;
	setDepthTextureLayer(layer: number): void;
	getColorAttachments(): BaseTexture[];
	getDepthAttachment(): BaseTexture;
	bind(): boolean;
	unbind(): void;
}
export interface GPUProgram<T = unknown> extends GPUObject<T> {
	readonly bindGroupLayouts: BindGroupLayout[];
	readonly type: "render" | "compute";
	getShaderSource(type: ShaderType): string;
	getCompileError(): string;
	getBindingInfo(name: string): BindPointInfo;
	use(): void;
}
export type StructuredValue = number | TypedArray | VectorBase | {
	[name: string]: StructuredValue;
};
export interface BindGroup extends GPUObject<unknown> {
	getLayout(): BindGroupLayout;
	getBuffer(name: string): StructuredBuffer;
	getTexture(name: string): BaseTexture;
	setBuffer(name: string, buffer: StructuredBuffer): void;
	setValue(name: string, value: StructuredValue): any;
	setRawData(name: string, byteOffset: number, data: TypedArray, srcPos?: number, srcLength?: number): any;
	setTexture(name: string, texture: BaseTexture, sampler?: TextureSampler): any;
	setTextureView(name: string, value: BaseTexture, level?: number, face?: number, mipCount?: number): any;
	setSampler(name: string, sampler: TextureSampler): any;
}
declare class VertexData {
	constructor();
	clone(): VertexData;
	updateTag(): void;
	getTag(): number;
	get vertexBuffers(): {
		buffer: StructuredBuffer<unknown>;
		offset: number;
		stepMode: VertexStepMode;
	}[];
	get indexBuffer(): IndexBuffer<unknown>;
	getDrawOffset(): number;
	setDrawOffset(offset: number): void;
	getVertexBuffer(location: number): StructuredBuffer;
	getIndexBuffer(): IndexBuffer;
	setVertexBuffer(buffer: StructuredBuffer, stepMode?: VertexStepMode): StructuredBuffer;
	removeVertexBuffer(buffer: StructuredBuffer): boolean;
	setIndexBuffer(buffer: IndexBuffer): IndexBuffer;
}
export declare class TextureAtlas {
	constructor(texture?: Texture2D, uvMin?: RCoord, uvMax?: RCoord, topLeftPatch9?: RCoord, bottomRightPatch9?: RCoord);
	get texture(): Texture2D;
	set texture(tex: Texture2D);
	get uvMin(): RCoord;
	set uvMin(v: RCoord);
	get uvMax(): RCoord;
	set uvMax(v: RCoord);
	get topLeftPatch9(): RCoord;
	set topLeftPatch9(v: RCoord);
	get bottomRightPatch9(): RCoord;
	set bottomRightPatch9(v: RCoord);
}
export declare class ImageManager {
	constructor(renderer: GUIRenderer);
	get renderer(): GUIRenderer;
	getImage(name: string): TextureAtlas;
	dispose(): void;
}
export interface UIRect {
	x: number;
	y: number;
	width: number;
	height: number;
}
export declare abstract class RPrimitive {
	abstract forEach(callback: (x: number, y: number, u: number, v: number) => void, thisArg?: unknown): any;
	abstract clipToRect(x: number, y: number, w: number, h: number): RPrimitive;
	abstract clone(): RPrimitive;
}
export type Vertex = {
	x: number;
	y: number;
	u?: number;
	v?: number;
};
export declare class RPolygonPrimitive extends RPrimitive {
	constructor(vertices?: Vertex[]);
	get vertices(): Vertex[];
	set vertices(v: Vertex[]);
	clone(): RPrimitive;
	forEach(callback: (x: number, y: number, u: number, v: number) => void, thisArg?: unknown): void;
	clipToRect(x: number, y: number, w: number, h: number): RPrimitive;
}
export declare class RRectPrimitive extends RPrimitive {
	constructor(x: number, y: number, w: number, h: number, uMin: number, vMin: number, uMax: number, vMax: number);
	clone(): RPrimitive;
	forEach(callback: (x: number, y: number, u: number, v: number) => void, thisArg?: unknown): void;
	clipToRect(x: number, y: number, w: number, h: number): RPrimitive;
}
export declare class RPrimitiveBatchList {
	constructor(x: number, y: number);
	get length(): number;
	get x(): number;
	set x(val: number);
	get y(): number;
	set y(val: number);
	clear(): void;
	clone(transformOptions?: {
		textureTransformFunc?: (t: Texture2D) => Texture2D;
		colorTransformFunc?: (c: RColor) => RColor;
	}): RPrimitiveBatchList;
	getBatch(index: number): RPrimitiveBatch;
	getVertices(index: number): Float32Array;
	addBatch(batch: RPrimitiveBatch): void;
	addPrimitive(prim: RPrimitive, clipper: UIRect, tex?: Texture2D, color?: RColor): void;
}
export declare class RPrimitiveBatch {
	constructor(clipper: UIRect);
	get texture(): Texture2D;
	set texture(tex: Texture2D);
	get color(): RColor;
	set color(clr: RColor);
	get length(): number;
	clone(transformOptions?: {
		textureTransformFunc?: (t: Texture2D) => Texture2D;
		colorTransformFunc?: (c: RColor) => RColor;
	}): RPrimitiveBatch;
	getPrimitive(index: number): RPrimitive;
	addPrimitive(prim: RPrimitive): void;
	setClipper(rect: UIRect): void;
	isSameClipper(rc: UIRect): boolean;
	clear(): void;
}
export interface RNodeList {
	length: number;
	item(index: number): RNode;
	entries(): Iterable<[
		number,
		RNode
	]>;
	keys(): Iterable<number>;
	values(): Iterable<RNode>;
	indexOf(node: RNode): number;
	forEach(callback: (currentValue: RNode, currentIndex?: number, listObj?: RNodeList) => void, thisArg?: unknown): void;
	[index: number]: RNode;
}
export declare class ElementStyle {
	static get defaultBackgroundColor(): RColor;
	static get defaultBorderColor(): RColor;
	static get defaultFontColor(): RColor;
	get display(): string;
	set display(val: string);
	get position(): string;
	set position(val: string);
	get overflow(): string;
	set overflow(val: string);
	get overflowX(): string;
	set overflowX(val: string);
	get overflowY(): string;
	set overflowY(val: string);
	get left(): string | number;
	set left(val: string | number);
	get top(): string | number;
	set top(val: string | number);
	get right(): string | number;
	set right(val: string | number);
	get bottom(): string | number;
	set bottom(val: string | number);
	get width(): string | number;
	set width(val: string | number);
	get minWidth(): string | number;
	set minWidth(val: string | number);
	get maxWidth(): string | number;
	set maxWidth(val: string | number);
	get height(): string | number;
	set height(val: string | number);
	get minHeight(): string | number;
	set minHeight(val: string | number);
	get maxHeight(): string | number;
	set maxHeight(val: string | number);
	get flexDirection(): string;
	set flexDirection(val: string);
	get flexWrap(): string;
	set flexWrap(val: string);
	get flexFlow(): string | number;
	set flexFlow(val: string | number);
	get alignItems(): string;
	set alignItems(val: string);
	get alignContent(): string;
	set alignContent(val: string);
	get alignSelf(): string;
	set alignSelf(val: string);
	get justifyContent(): string;
	set justifyContent(val: string);
	get flexGrow(): string | number;
	set flexGrow(val: string | number);
	get flexShrink(): string | number;
	set flexShrink(val: string | number);
	get flexBasis(): string | number;
	set flexBasis(val: string | number);
	get flex(): string | number;
	set flex(val: string | number);
	get borderColor(): string | number;
	set borderColor(val: string | number);
	get borderLeftColor(): string | number;
	set borderLeftColor(val: string | number);
	get borderTopColor(): string | number;
	set borderTopColor(val: string | number);
	get borderRightColor(): string | number;
	set borderRightColor(val: string | number);
	get borderBottomColor(): string | number;
	set borderBottomColor(val: string | number);
	get borderWidth(): string | number;
	set borderWidth(val: string | number);
	get borderLeftWidth(): string | number;
	set borderLeftWidth(val: string | number);
	get borderTopWidth(): string | number;
	set borderTopWidth(val: string | number);
	get borderRightWidth(): string | number;
	set borderRightWidth(val: string | number);
	get borderBottomWidth(): string | number;
	set borderBottomWidth(val: string | number);
	get margin(): string | number;
	set margin(val: string | number);
	get marginLeft(): string | number;
	set marginLeft(val: string | number);
	get marginTop(): string | number;
	set marginTop(val: string | number);
	get marginRight(): string | number;
	set marginRight(val: string | number);
	get marginBottom(): string | number;
	set marginBottom(val: string | number);
	get padding(): string | number;
	set padding(val: string | number);
	get paddingLeft(): string | number;
	set paddingLeft(val: string | number);
	get paddingTop(): string | number;
	set paddingTop(val: string | number);
	get paddingRight(): string | number;
	set paddingRight(val: string | number);
	get paddingBottom(): string | number;
	set paddingBottom(val: string | number);
	get zIndex(): string | number;
	set zIndex(val: string | number);
	get cursor(): string;
	set cursor(val: string);
	get backgroundColor(): string;
	set backgroundColor(val: string);
	get backgroundImage(): string;
	set backgroundImage(val: string);
	get font(): string;
	set font(val: string);
	get fontSize(): string;
	set fontSize(val: string);
	get fontFamily(): string;
	set fontFamily(val: string);
	get color(): string;
	set color(val: string);
	get pointerEvents(): string;
	set pointerEvents(val: string);
}
export declare class RResizeEvent extends REvent {
	static readonly NAME = "resize";
	constructor();
}
export declare class RMouseEvent extends REvent {
	static readonly NAME_RENDERER_MOUSEDOWN = "renderermousedown";
	static readonly NAME_RENDERER_MOUSEUP = "renderermouseup";
	static readonly NAME_RENDERER_MOUSEMOVE = "renderermousemove";
	static readonly NAME_RENDERER_MOUSECLICK = "rendererclick";
	static readonly NAME_RENDERER_MOUSEDBLCLICK = "rendererdblclick";
	static readonly NAME_RENDERER_MOUSEWHEEL = "renderermousewheel";
	static readonly NAME_RENDERER_DRAGENTER = "rendererdragenter";
	static readonly NAME_RENDERER_DRAGOVER = "rendererdragover";
	static readonly NAME_RENDERER_DRAGDROP = "rendererdragdrop";
	static readonly NAME_MOUSEDOWN = "mousedown";
	static readonly NAME_MOUSEUP = "mouseup";
	static readonly NAME_MOUSEMOVE = "mousemove";
	static readonly NAME_MOUSECLICK = "click";
	static readonly NAME_MOUSEDBLCLICK = "dblclick";
	static readonly NAME_MOUSEWHEEL = "wheel";
	static readonly NAME_MOUSEENTER = "mouseenter";
	static readonly NAME_MOUSELEAVE = "mouseleave";
	static readonly NAME_MOUSEOVER = "mouseover";
	static readonly NAME_MOUSEOUT = "mouseout";
	x: number;
	y: number;
	offsetX: number;
	offsetY: number;
	button: number;
	buttons: number;
	wheelDeltaX: number;
	wheelDeltaY: number;
	ctrlKey: boolean;
	shiftKey: boolean;
	altKey: boolean;
	metaKey: boolean;
	relatedTarget: unknown;
	constructor(type: string, x: number, y: number, offsetX: number, offsetY: number, button: number, buttons: number, wheelDeltaX: number, wheelDeltaY: number, ctrlKey: boolean, shiftKey: boolean, altKey: boolean, metaKey: boolean);
	init(x: number, y: number, offsetX: number, offsetY: number, button: number, buttons: number, wheelDeltaX: number, wheelDeltaY: number, ctrlKey: boolean, shiftKey: boolean, altKey: boolean, metaKey: boolean): void;
}
export declare class RDragEvent extends RMouseEvent {
	static readonly NAME_DRAG = "drag";
	static readonly NAME_DRAGSTART = "dragstart";
	static readonly NAME_DRAGEND = "dragend";
	static readonly NAME_DRAGOVER = "dragover";
	static readonly NAME_DRAGENTER = "dragenter";
	static readonly NAME_DRAGLEAVE = "dragleave";
	static readonly NAME_DRAGDROP = "drop";
	dataTransfer: DataTransfer;
	constructor(type: string, x: number, y: number, offsetX: number, offsetY: number, button: number, buttons: number, ctrlKey: boolean, shiftKey: boolean, altKey: boolean, metaKey: boolean, dataTransfer: DataTransfer);
}
export declare class RKeyEvent extends REvent {
	static readonly NAME_RENDERER_KEYDOWN = "rendererkeydown";
	static readonly NAME_RENDERER_KEYUP = "rendererkeyup";
	static readonly NAME_RENDERER_KEYPRESS = "rendererkeypress";
	static readonly NAME_KEYDOWN = "keydown";
	static readonly NAME_KEYUP = "keyup";
	static readonly NAME_KEYPRESS = "keypress";
	code: string;
	key: string;
	repeat: boolean;
	ctrlKey: boolean;
	shiftKey: boolean;
	altKey: boolean;
	metaKey: boolean;
	constructor(type: string, code: string, key: string, repeat: boolean, ctrlKey: boolean, shiftKey: boolean, altKey: boolean, metaKey: boolean);
}
export declare class RFocusEvent extends REvent {
	static readonly NAME_FOCUS = "focus";
	static readonly NAME_BLUR = "blur";
	constructor(type: string);
}
export declare class RElementLayoutEvent extends REvent {
	static readonly NAME = "layout";
	constructor();
}
export declare class RElementDrawEvent extends REvent {
	static readonly NAME = "draw";
	constructor();
}
export declare class RElementBuildContentEvent extends REvent {
	static readonly NAME_PREBUILD = "prebuildcontent";
	static readonly NAME_POSTBUILD = "postbuildcontent";
	batchList: RPrimitiveBatchList;
	constructor(type: string, batchList: RPrimitiveBatchList);
}
export declare class RTextEvent extends REvent {
	static readonly NAME_CONTENT_CHANGE = "textcontentchange";
	static readonly NAME_FONT_CHANGE = "textfontchange";
	constructor(type: string);
}
export declare class RValueChangeEvent extends REvent {
	static readonly NAME = "valuechange";
	value: number;
	constructor(value: number);
}
export declare class RAttributeChangeEvent extends REvent {
	static readonly NAME = "attributechange";
	name: string;
	removed: boolean;
	constructor(name: string, removed: boolean);
}
export declare class RTextContentChangeEvent extends REvent {
	static readonly NAME = "elementtextcontentchange";
	constructor();
}
export declare class RChangeEvent extends REvent {
	static readonly NAME = "change";
	constructor();
}
export declare class RDOMTreeEvent extends REvent {
	static readonly NAME_INSERTED = "elementinserted";
	static readonly NAME_REMOVED = "elementremoved";
	static readonly NAME_FOCUSED = "elementfocused";
	parent: RNode;
	node: RNode;
	constructor(type: string, parent: RNode, node: RNode);
}
export interface RClassList {
	[n: number]: string;
}
export declare class RClassList {
	constructor(el: RElement);
	get value(): string;
	set value(val: string);
	get length(): number;
	add(...args: string[]): void;
	remove(...args: string[]): void;
	toggle(className: string): boolean;
	contains(className: string): boolean;
	replace(oldClassName: string, newClassName: string): void;
}
export interface RAttr {
	name: string;
	value: string;
}
export declare class RElement extends RNode {
	constructor(uiscene: GUI);
	get children(): RNodeList;
	get childElementCount(): number;
	get nodeType(): number;
	get localName(): string;
	get tagName(): string;
	get id(): string;
	set id(id: string);
	get classList(): RClassList;
	get className(): string;
	get attributes(): RAttr[];
	get firstElementChild(): RElement;
	get lastElementChild(): RElement;
	get nextElementSibling(): RElement;
	get previousElementSibling(): RElement;
	getAttribute(k: string): string;
	setAttribute(k: string, v?: string): void;
	removeAttribute(k: string): void;
	hasAttribute(k: string): boolean;
	hasAttributes(): boolean;
	insertAdjacentElement(position: string, element: RElement): RElement;
	insertAdjacentText(position: string, text: string): string;
	matches(selectorString: string): boolean;
	cloneNode(deep: boolean): RNode;
	replaceWith(...nodes: (RNode | string)[]): void;
	remove(): RNode;
	before(...nodes: (RNode | string)[]): void;
	after(...nodes: (RNode | string)[]): void;
	append(...nodes: (RNode | string)[]): void;
	prepend(...nodes: (RNode | string)[]): void;
	querySelectorAll(selectors: string): RNodeList;
	querySelector<T extends RElement>(selectors: string): T;
	getElementById(id: string): RElement;
	getElementsByTagName(tagName: string): RNodeList;
	getElementsByClassName(classnames: string): RNodeList;
}
export declare class RText extends RNode {
	constructor(uiscene: GUI);
	get nodeType(): number;
	cloneNode(): RNode;
	get textContent(): string;
	set textContent(text: string);
	get autoWrap(): boolean;
	set autoWrap(val: boolean);
	get charMargin(): number;
	set charMargin(val: number);
	get lineHeight(): number;
	set lineHeight(val: number);
}
export declare class RDocument extends RNode {
	constructor(uiscene: GUI);
	get nodeType(): number;
	get nodeName(): string;
	get head(): RElement;
	get body(): RElement;
	get baseURI(): string;
	set baseURI(val: string);
	get textContent(): string;
	set textContent(val: string);
	get documentElement(): RElement;
	get children(): RNodeList;
	get childElementCount(): number;
	get firstElementChild(): RElement;
	get lastElementChild(): RElement;
	appendChild(child: RNode): RNode;
	insertBefore(newElement: RNode, referenceElement: RNode): RNode;
	append(...nodes: (RNode | string)[]): void;
	prepend(...nodes: (RNode | string)[]): void;
	querySelectorAll(selectors: string): RNodeList;
	querySelector<T extends RElement>(selectors: string): T;
	getElementsByTagName(tagname: string): RNodeList;
	getElementsByClassName(classnames: string): RNodeList;
	getElementById(id: string): RElement;
	createElement<T extends RElement = RElement>(tagname: string): T;
	createTextNode(): RText;
}
export interface RNode extends REventTarget {
	addEventListener(type: "mousedown" | "mouseup" | "mousemove" | "mouseclick" | "mousedblclick", listener: REventListener<RMouseEvent>, options?: REventHandlerOptions): void;
	addEventListener(type: string, listener: REventListener, options?: REventHandlerOptions): void;
}
export interface INodeVisitor {
	beginTraverseNode(w: RNode): any;
	endTraverseNode(w: RNode): any;
	visitNode(w: RNode): void;
}
export declare class RNode extends REventTarget {
	static readonly UNKNOWN_NODE = NodeType.UNKNOWN_NODE;
	static readonly ELEMENT_NODE = NodeType.ELEMENT_NODE;
	static readonly TEXT_NODE = NodeType.TEXT_NODE;
	static readonly DOCUMENT_NODE = NodeType.DOCUMENT_NODE;
	get gui(): GUI;
	get nodeType(): number;
	get nodeName(): string;
	get nodeValue(): string;
	get ownerDocument(): RDocument;
	get isConnected(): boolean;
	get parentNode(): RNode;
	get parentElement(): RElement;
	get childNodes(): RNodeList;
	get style(): ElementStyle;
	get textContent(): string;
	set textContent(text: string);
	get batchList(): RPrimitiveBatchList;
	get customDraw(): boolean;
	set customDraw(val: boolean);
	isElement(): this is RElement;
	isDocument(): this is RDocument;
	normalize(): void;
	get scrollX(): number;
	set scrollX(val: number);
	setScrollX(val: number): void;
	get scrollY(): number;
	set scrollY(val: number);
	setScrollY(val: number): void;
	setScroll(x: number, y: number): void;
	getRect(): UIRect;
	getClippedRect(): UIRect;
	getClientRect(): UIRect;
	getBorderRect(): UIRect;
	get nextSibling(): RNode;
	get previousSibling(): RNode;
	cloneNode(deep: boolean): RNode;
	getRootNode(): RNode;
	appendChild(child: RNode): RNode;
	insertBefore(newElement: RNode, referenceElement: RNode): RNode;
	removeChild(child: RNode): RNode;
	replaceChild(newChild: RNode, oldChild: RNode): RNode;
	get firstChild(): RNode;
	get lastChild(): RNode;
	contains(child: RNode): boolean;
	hasChildNodes(): boolean;
	setCapture(): void;
	releaseCapture(): void;
	traverse(v: INodeVisitor, inverse?: boolean, render?: boolean): void;
	checkContents(): void;
	draw(renderer: GUIRenderer): void;
	toAbsolute(v?: RCoord): RCoord;
}
export interface IElementConstructor {
	new (gui: GUI, ...args: unknown[]): RElement;
}
export interface ITagNameGetter {
	(element: RElement): string;
}
export declare class ElementRegistry {
	constructor();
	register(ctor: IElementConstructor, tagName: string | ITagNameGetter): void;
	createElement(gui: GUI, tagName: string): RElement;
}
export declare function tagname(name: string): (ctor: IElementConstructor) => void;
export declare class GUI extends REventTarget {
	constructor(renderer: GUIRenderer, bounds?: UIRect);
	get renderer(): GUIRenderer;
	get bounds(): UIRect;
	set bounds(rect: UIRect);
	get baseURI(): string;
	set baseURI(val: string);
	get document(): RDocument;
	get imageManager(): ImageManager;
	get mouseX(): number;
	get mouseY(): number;
	get mouseButtonState(): number;
	get ctrlKey(): boolean;
	get shiftKey(): boolean;
	get altKey(): boolean;
	get metaKey(): boolean;
	getHover(): {
		element: RNode;
		x: number;
		y: number;
	};
	getFocus(): RNode;
	setFocus(node: RNode): void;
	getCapture(): RNode;
	setCapture(node: RNode): void;
	dispose(): void;
	render(): void;
	serializeToXML(): string;
	deserializeFromXML(xml: string): Promise<any>;
	deserializeFromURL(url: string): Promise<void>;
	createElement<T extends RElement = RElement>(tagName: string): T;
	createTextNode(): RText;
	loadCSS(content: string): void;
}
export declare class GUIRenderer extends REventTarget {
	constructor(device: Device);
	get device(): Device;
	dispose(): void;
	getCanvas(): HTMLCanvasElement;
	getDrawingBufferWidth(): number;
	getDrawingBufferHeight(): number;
	screenToDevice(val: number): number;
	deviceToScreen(val: number): number;
	supportColorComposition(): boolean;
	createTexture(width: number, height: number, color: RColor, linear: boolean): Texture2D;
	clearTexture(tex: Texture2D, color: RColor): void;
	updateTextureWithImage(texture: Texture2D, bitmap: ImageData, x: number, y: number): void;
	updateTextureWithCanvas(texture: Texture2D, ctx: CanvasRenderingContext2D, cvsOffsetX: number, cvsOffsetY: number, w: number, h: number, x: number, y: number): void;
	getTextureWidth(texture: Texture2D): number;
	getTextureHeight(texture: Texture2D): number;
	disposeTexture(texture: Texture2D): void;
	setCursorStyle(style: string): void;
	getCursorStyle(): string;
	drawQuads(data: Float32Array, texture: Texture2D): void;
	flush(): void;
	pushViewport(x: number, y: number, w: number, h: number): void;
	popViewport(): void;
	pushScissor(x: number, y: number, w: number, h: number): void;
	popScissor(): void;
	beginRender(): void;
	endRender(): void;
	beginCustomDraw(node: RNode): void;
	endCustomDraw(node: RNode): void;
}
export declare function injectGUIEvents(gui: GUI, renderer: GUIRenderer): void;
export interface IAtlasInfo {
	atlasIndex: number;
	width: number;
	height: number;
	uMin: number;
	vMin: number;
	uMax: number;
	vMax: number;
}
export declare class AtlasManager {
	constructor(renderer: GUIRenderer, cacheWidth?: number, cacheHeight?: number, cachePadding?: number, linearSpace?: boolean);
	get atlasTextureRestoreHandler(): (tex: BaseTexture) => Promise<void>;
	set atlasTextureRestoreHandler(f: (tex: BaseTexture) => Promise<void>);
	getAtlasTexture(index: number): Texture2D;
	getAtlasInfo(key: string): IAtlasInfo;
	isEmpty(): boolean;
	clear(): void;
	pushCanvas(key: string, ctx: CanvasRenderingContext2D, x: number, y: number, w: number, h: number): IAtlasInfo;
	pushBitmap(key: string, bitmap: ImageData): IAtlasInfo;
}
export interface IGlyphInfo {
	atlasIndex: number;
	width: number;
	height: number;
	uMin: number;
	vMin: number;
	uMax: number;
	vMax: number;
}
export declare class GlyphManager extends AtlasManager {
	constructor(renderer: GUIRenderer, cacheWidth?: number, cacheHeight?: number, cachePadding?: number);
	getGlyphTexture(index: number): Texture2D;
	getGlyphInfo(char: string, font: Font, color: RColor): IGlyphInfo;
	measureStringWidth(str: string, charMargin: number, font: Font): number;
	clipStringToWidth(str: string, width: number, charMargin: number, start: number, font: Font): number;
	getCharWidth(char: string, font: Font): number;
}
export interface IPseudoElementCallback {
	(node: RNode, pseudoType: string): void;
}
export declare class Rule {
	constructor();
	resolve(roots: RNode[], up: boolean, allowInternal: boolean, pseudoElementCallback?: IPseudoElementCallback): void;
}
export declare class RSelector {
	constructor(s: string);
	resolve(root: RNode, excludeRoot: boolean, allowInternal: any): RNode[];
	multiResolve(roots: RNode[], allowInternal: any): RNode[];
	rules(): Rule[];
}
export declare class StyleElement extends RElement {
	constructor(uiscene: GUI);
}
export declare class RFlowElement extends RElement {
	constructor(uiscene: GUI);
}
export declare class DummyElement extends RElement {
	constructor(uiscene: GUI);
}
export declare class Button extends RElement {
	constructor(uiscene: GUI);
}
export declare class Input extends RElement {
	constructor(uiscene: GUI);
	get type(): string;
	set type(val: string);
	get value(): string;
	set value(val: string);
}
export declare class Option extends RElement {
	constructor(uiscene: GUI);
	setAttribute(k: string, v?: string): void;
}
export declare class Select extends RElement {
	constructor(uiscene: GUI);
	get value(): string;
}
export declare class Slider extends RElement {
	constructor(uiscene: GUI);
	get value(): number;
	set value(val: number);
	get rangeStart(): number;
	set rangeStart(val: number);
	get rangeEnd(): number;
	set rangeEnd(val: number);
	get blockSize(): number;
	set blockSize(val: number);
	get stepValue(): number;
	set stepValue(val: number);
	get pageValue(): number;
	set pageValue(val: number);
	get orientation(): string;
	set orientation(val: string);
	get blockColor(): string;
	set blockColor(val: string);
	get blockImage(): string;
	set blockImage(val: string);
}
export declare class ScrollBar extends Slider {
	constructor(uiscene: GUI);
	get buttonSize(): number;
	set buttonSize(val: number);
}
export declare class GUIHitTestVisitor {
	constructor(x: number, y: number);
	getHits(): {
		element: RNode;
		x: number;
		y: number;
	}[];
	beginTraverseNode(): void;
	endTraverseNode(): void;
	visitNode(w: RNode): void;
}

export as namespace sophonDom;

export {};
